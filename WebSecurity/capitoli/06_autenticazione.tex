\chapter{Autenticazione e Gestione Sessioni}

\section{Introduzione}

L'autenticazione è il processo di verifica dell'identità di un utente, mentre la gestione delle sessioni mantiene lo stato autenticato attraverso multiple richieste HTTP. Questi sono componenti critici della sicurezza web, e vulnerabilità in questi sistemi possono compromettere intere applicazioni.

\subsection{Importanza}

\begin{itemize}
    \item \textbf{Controllo accessi:} Base per autorizzazione e permessi
    \item \textbf{Responsabilità:} Tracciabilità delle azioni utente
    \item \textbf{Protezione dati:} Accesso solo ad utenti legittimi
    \item \textbf{Compliance:} Requisiti GDPR, PCI DSS, HIPAA
\end{itemize}

\subsection{Vulnerabilità comuni}

\begin{itemize}
    \item Password deboli o in chiaro
    \item Session hijacking e fixation
    \item Credential stuffing e brute force
    \item Token JWT mal configurati
    \item OAuth implementation flaws
\end{itemize}

\section{Password Hashing}

\subsection{Mai salvare password in chiaro!}

\begin{lstlisting}[language=SQL, caption=VULNERABILE - Password in chiaro]
-- MAI fare questo!
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(100)  -- Password in chiaro = DISASTRO
);

INSERT INTO users VALUES (1, 'admin', 'password123');

-- Se il database viene compromesso, tutte le password sono esposte!
\end{lstlisting}

\subsection{Perché NON usare MD5/SHA1}

\begin{lstlisting}[language=PHP, caption=INSICURO - MD5/SHA1 per password]
<?php
// INSICURO: MD5 è rotto e troppo veloce
$password = 'password123';
$hash = md5($password);  // 482c811da5d5b4bc6d497ffa98491e38

// Problemi:
// 1. MD5 è criptograficamente rotto (collisioni)
// 2. Troppo veloce → brute force facile
// 3. Nessun salt automatico → rainbow tables
// 4. GPU può calcolare miliardi di hash/secondo

// SHA1 ha gli stessi problemi
$hash = sha1($password);

// Anche SHA256 senza salt è vulnerabile
$hash = hash('sha256', $password);
?>
\end{lstlisting}

\subsection{Rainbow Tables}

\begin{verbatim}
Rainbow table: Database pre-calcolato di hash comuni

Esempio:
password123 → 482c811da5d5b4bc6d497ffa98491e38 (MD5)
admin       → 21232f297a57a5a743894a0e4a801fc3
qwerty      → d8578edf8458ce06fbc5bb76a58c5ca4

Con rainbow tables, invertire hash diventa lookup O(1)

Difesa: SALT unico per ogni password
\end{verbatim}

\subsection{bcrypt - Best Practice}

bcrypt è un algoritmo di hashing progettato specificamente per password, con salt integrato e cost factor configurabile.

\subsubsection{Come funziona bcrypt}

\begin{verbatim}
bcrypt = Blowfish cipher + Eksblowfish key setup + salt + cost factor

Hash format: $2y$10$N9qo8uLOickgx2ZMRZoMye
             │  │  │                    │
             │  │  │                    └─ Hash (22 chars)
             │  │  └─ Salt (22 chars)
             │  └─ Cost factor (2^10 = 1024 iterations)
             └─ Algorithm identifier

Cost factor:
- 10 = 2^10 = 1,024 iterations (~100ms)
- 12 = 2^12 = 4,096 iterations (~300ms)
- 14 = 2^14 = 16,384 iterations (~1.5s)

Aumentare cost rende brute force esponenzialmente più costoso
\end{verbatim}

\subsubsection{Implementazione PHP}

\begin{lstlisting}[language=PHP, caption=SICURO - bcrypt in PHP]
<?php
// Registrazione utente
function register_user($username, $password) {
    // Valida password strength
    if (strlen($password) < 12) {
        throw new Exception("Password troppo corta (min 12 caratteri)");
    }

    // Hash password con bcrypt (cost factor 12)
    $options = ['cost' => 12];
    $password_hash = password_hash($password, PASSWORD_BCRYPT, $options);

    // Esempio hash:
    // $2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K
    //  │   │  └─ Salt + Hash
    //  │   └─ Cost: 2^12 iterations
    //  └─ bcrypt identifier

    // Salva nel database
    global $pdo;
    $stmt = $pdo->prepare("INSERT INTO users (username, password_hash) VALUES (?, ?)");
    $stmt->execute([$username, $password_hash]);

    return true;
}

// Login utente
function login_user($username, $password) {
    global $pdo;

    $stmt = $pdo->prepare("SELECT id, password_hash FROM users WHERE username = ?");
    $stmt->execute([$username]);
    $user = $stmt->fetch();

    if (!$user) {
        return false;  // User not found
    }

    // Verifica password
    if (password_verify($password, $user['password_hash'])) {
        // Password corretta

        // Controlla se l'hash deve essere aggiornato
        // (es. aumentato cost factor)
        if (password_needs_rehash($user['password_hash'], PASSWORD_BCRYPT, ['cost' => 12])) {
            $new_hash = password_hash($password, PASSWORD_BCRYPT, ['cost' => 12]);
            $stmt = $pdo->prepare("UPDATE users SET password_hash = ? WHERE id = ?");
            $stmt->execute([$new_hash, $user['id']]);
        }

        return $user['id'];
    }

    return false;  // Wrong password
}

// Uso
try {
    register_user('john', 'MyS3cur3P@ssw0rd!');
    $user_id = login_user('john', 'MyS3cur3P@ssw0rd!');

    if ($user_id) {
        $_SESSION['user_id'] = $user_id;
        echo "Login successful!";
    }
} catch (Exception $e) {
    echo "Error: " . $e->getMessage();
}
?>
\end{lstlisting}

\subsubsection{Implementazione Python}

\begin{lstlisting}[language=Python, caption=SICURO - bcrypt in Python]
import bcrypt
import re

def validate_password_strength(password):
    """Valida forza password"""
    if len(password) < 12:
        raise ValueError("Password troppo corta (minimo 12 caratteri)")

    if not re.search(r'[A-Z]', password):
        raise ValueError("Password deve contenere almeno una maiuscola")

    if not re.search(r'[a-z]', password):
        raise ValueError("Password deve contenere almeno una minuscola")

    if not re.search(r'\d', password):
        raise ValueError("Password deve contenere almeno un numero")

    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        raise ValueError("Password deve contenere almeno un carattere speciale")

    return True

def register_user(username, password):
    """Registra nuovo utente con password hashed"""
    # Valida password
    validate_password_strength(password)

    # Genera salt e hash password
    # bcrypt genera automaticamente salt random
    salt = bcrypt.gensalt(rounds=12)  # 2^12 iterations
    password_hash = bcrypt.hashpw(password.encode('utf-8'), salt)

    # password_hash è bytes, es:
    # b'$2b$12$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy'

    # Salva nel database
    db.execute(
        "INSERT INTO users (username, password_hash) VALUES (?, ?)",
        (username, password_hash.decode('utf-8'))
    )

    return True

def login_user(username, password):
    """Autentica utente"""
    # Recupera hash dal database
    user = db.execute(
        "SELECT id, password_hash FROM users WHERE username = ?",
        (username,)
    ).fetchone()

    if not user:
        # User not found
        # Esegui comunque checkpw per prevenire timing attack
        bcrypt.checkpw(b"dummy", bcrypt.gensalt())
        return None

    # Verifica password
    if bcrypt.checkpw(password.encode('utf-8'), user['password_hash'].encode('utf-8')):
        return user['id']

    return None

# Uso
try:
    register_user('alice', 'Str0ng!P@ssw0rd123')
    user_id = login_user('alice', 'Str0ng!P@ssw0rd123')

    if user_id:
        session['user_id'] = user_id
        print("Login successful!")
    else:
        print("Invalid credentials")
except ValueError as e:
    print(f"Error: {e}")
\end{lstlisting}

\subsubsection{Implementazione Java}

\begin{lstlisting}[language=Java, caption=SICURO - bcrypt in Java (Spring Security)]
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

public class UserService {
    private final PasswordEncoder passwordEncoder;

    public UserService() {
        // Strength 12 = 2^12 iterations
        this.passwordEncoder = new BCryptPasswordEncoder(12);
    }

    public void registerUser(String username, String password) {
        // Valida password strength
        validatePasswordStrength(password);

        // Hash password
        String hashedPassword = passwordEncoder.encode(password);

        // Salva nel database
        User user = new User();
        user.setUsername(username);
        user.setPasswordHash(hashedPassword);
        userRepository.save(user);
    }

    public boolean loginUser(String username, String password) {
        User user = userRepository.findByUsername(username)
            .orElse(null);

        if (user == null) {
            // Esegui dummy encoding per prevenire timing attack
            passwordEncoder.encode("dummy");
            return false;
        }

        // Verifica password
        return passwordEncoder.matches(password, user.getPasswordHash());
    }

    private void validatePasswordStrength(String password) {
        if (password.length() < 12) {
            throw new IllegalArgumentException("Password troppo corta");
        }

        if (!password.matches(".*[A-Z].*")) {
            throw new IllegalArgumentException("Password deve contenere maiuscole");
        }

        if (!password.matches(".*[a-z].*")) {
            throw new IllegalArgumentException("Password deve contenere minuscole");
        }

        if (!password.matches(".*\\d.*")) {
            throw new IllegalArgumentException("Password deve contenere numeri");
        }

        if (!password.matches(".*[!@#$%^&*(),.?\":{}|<>].*")) {
            throw new IllegalArgumentException("Password deve contenere caratteri speciali");
        }
    }
}
\end{lstlisting}

\subsection{Argon2 - Lo stato dell'arte}

Argon2 è il vincitore della Password Hashing Competition (2015) e attualmente considerato il miglior algoritmo per password hashing.

\subsubsection{Varianti Argon2}

\begin{description}
    \item[Argon2d] Ottimizzato per resistenza GPU (data-dependent)
    \item[Argon2i] Ottimizzato per resistenza side-channel (data-independent)
    \item[Argon2id] Hybrid: combinazione di d e i (raccomandato)
\end{description}

\subsubsection{Parametri Argon2}

\begin{itemize}
    \item \textbf{Memory cost (m):} Memoria in KB (es. 65536 = 64MB)
    \item \textbf{Time cost (t):} Numero di iterazioni (es. 3)
    \item \textbf{Parallelism (p):} Numero di thread (es. 4)
    \item \textbf{Output length:} Lunghezza hash (es. 32 bytes)
\end{itemize}

\subsubsection{Implementazione Python}

\begin{lstlisting}[language=Python, caption=Argon2 in Python]
from argon2 import PasswordHasher
from argon2.exceptions import VerifyMismatchError

# Configurazione raccomandata (OWASP)
ph = PasswordHasher(
    time_cost=3,        # Iterazioni
    memory_cost=65536,  # 64 MB
    parallelism=4,      # 4 thread
    hash_len=32,        # 32 bytes output
    salt_len=16         # 16 bytes salt
)

def register_user_argon2(username, password):
    """Registra utente con Argon2"""
    # Hash password
    password_hash = ph.hash(password)

    # Hash format: $argon2id$v=19$m=65536,t=3,p=4$salt$hash

    # Salva nel database
    db.execute(
        "INSERT INTO users (username, password_hash) VALUES (?, ?)",
        (username, password_hash)
    )

def login_user_argon2(username, password):
    """Login con Argon2"""
    user = db.execute(
        "SELECT id, password_hash FROM users WHERE username = ?",
        (username,)
    ).fetchone()

    if not user:
        return None

    try:
        # Verifica password
        ph.verify(user['password_hash'], password)

        # Controlla se hash deve essere aggiornato
        if ph.check_needs_rehash(user['password_hash']):
            new_hash = ph.hash(password)
            db.execute(
                "UPDATE users SET password_hash = ? WHERE id = ?",
                (new_hash, user['id'])
            )

        return user['id']
    except VerifyMismatchError:
        return None

# Uso
register_user_argon2('bob', 'SuperS3cur3!P@ssw0rd')
user_id = login_user_argon2('bob', 'SuperS3cur3!P@ssw0rd')
\end{lstlisting}

\subsubsection{Confronto bcrypt vs Argon2}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Caratteristica} & \textbf{bcrypt} & \textbf{Argon2} \\
\hline
Anno & 1999 & 2015 \\
Resistenza GPU & Buona & Eccellente \\
Memory-hard & Limitata & Sì (configurabile) \\
Parallelismo & No & Sì \\
Configurabilità & Solo cost & Memory, time, parallelism \\
Maturità & Molto matura & Relativamente nuova \\
Supporto librerie & Universale & Crescente \\
Raccomandazione OWASP & Sì & Sì (preferito) \\
\hline
\end{tabular}
\end{center}

\section{Multi-Factor Authentication (MFA)}

MFA richiede due o più fattori indipendenti per autenticazione.

\subsection{Fattori di autenticazione}

\begin{enumerate}
    \item \textbf{Something you know:} Password, PIN
    \item \textbf{Something you have:} Smartphone, token hardware, smart card
    \item \textbf{Something you are:} Biometria (impronta, Face ID)
\end{enumerate}

\subsection{TOTP (Time-based One-Time Password)}

Algoritmo standard per 2FA (Google Authenticator, Authy).

\subsubsection{Come funziona TOTP}

\begin{verbatim}
1. Setup:
   - Server genera secret key (es. base32)
   - Secret condiviso con client via QR code

2. Generazione codice:
   - Timestamp corrente diviso per intervallo (30 sec)
   - HMAC-SHA1(secret, timestamp_counter)
   - Estrai 6 cifre dall'hash

3. Verifica:
   - Server calcola TOTP con stesso secret e timestamp
   - Confronta con codice fornito dall'utente
   - Permetti piccolo time skew (±1 intervallo)
\end{verbatim}

\subsubsection{Implementazione TOTP}

\begin{lstlisting}[language=Python, caption=TOTP implementation]
import pyotp
import qrcode
import io

class TOTPManager:
    @staticmethod
    def generate_secret():
        """Genera secret per nuovo utente"""
        return pyotp.random_base32()

    @staticmethod
    def get_provisioning_uri(secret, username, issuer='MyApp'):
        """Genera URI per QR code"""
        totp = pyotp.TOTP(secret)
        return totp.provisioning_uri(
            name=username,
            issuer_name=issuer
        )

    @staticmethod
    def generate_qr_code(provisioning_uri):
        """Genera QR code per setup"""
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(provisioning_uri)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")

        # Converti in bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)

        return img_bytes

    @staticmethod
    def verify_totp(secret, user_code):
        """Verifica codice TOTP"""
        totp = pyotp.TOTP(secret)

        # Verifica con time window (±30 secondi)
        return totp.verify(user_code, valid_window=1)

# Uso - Setup MFA
def setup_mfa(user_id, username):
    """Setup MFA per utente"""
    # Genera secret
    secret = TOTPManager.generate_secret()

    # Salva secret nel database (CIFRATO!)
    db.execute(
        "UPDATE users SET totp_secret = ? WHERE id = ?",
        (encrypt(secret), user_id)
    )

    # Genera QR code
    uri = TOTPManager.get_provisioning_uri(secret, username)
    qr_code = TOTPManager.generate_qr_code(uri)

    return {
        'secret': secret,  # Mostra all'utente come backup
        'qr_code': qr_code
    }

# Uso - Login con MFA
def login_with_mfa(username, password, totp_code):
    """Login con password + TOTP"""
    # Step 1: Verifica password
    user = authenticate_password(username, password)

    if not user:
        return None

    # Step 2: Verifica TOTP
    secret = decrypt(user['totp_secret'])

    if not TOTPManager.verify_totp(secret, totp_code):
        return None

    # Entrambi fattori verificati
    return user['id']

# Setup MFA
setup_data = setup_mfa(123, 'alice@example.com')
print(f"Secret: {setup_data['secret']}")
print("Scan QR code with Google Authenticator")

# Login
user_id = login_with_mfa('alice@example.com', 'password', '123456')
\end{lstlisting}

\subsection{SMS-based 2FA}

\begin{lstlisting}[language=PHP, caption=SMS 2FA (non raccomandato per alta sicurezza)]
<?php
// Nota: SMS 2FA è vulnerabile a SIM swapping
// Meglio usare TOTP, ma SMS è meglio di niente

function send_sms_code($phone_number) {
    // Genera codice 6 cifre
    $code = sprintf("%06d", mt_rand(0, 999999));

    // Salva in sessione con timestamp
    $_SESSION['sms_code'] = password_hash($code, PASSWORD_BCRYPT);
    $_SESSION['sms_code_expires'] = time() + 300;  // 5 minuti

    // Invia SMS (usa servizio come Twilio)
    send_sms($phone_number, "Il tuo codice di verifica è: $code");

    return true;
}

function verify_sms_code($user_code) {
    // Controlla scadenza
    if (!isset($_SESSION['sms_code_expires']) ||
        time() > $_SESSION['sms_code_expires']) {
        return false;
    }

    // Verifica codice
    if (password_verify($user_code, $_SESSION['sms_code'])) {
        // Invalida codice dopo uso
        unset($_SESSION['sms_code']);
        unset($_SESSION['sms_code_expires']);
        return true;
    }

    return false;
}

// Uso
send_sms_code('+1234567890');

if (verify_sms_code($_POST['code'])) {
    echo "Codice verificato!";
}
?>
\end{lstlisting}

\subsection{Backup Codes}

\begin{lstlisting}[language=Python, caption=Backup codes generation]
import secrets

def generate_backup_codes(count=10):
    """Genera backup codes per recovery"""
    codes = []

    for _ in range(count):
        # Genera codice alfanumerico 8 caratteri
        code = secrets.token_hex(4).upper()  # es. A3F5B8C2
        codes.append(code)

    return codes

def save_backup_codes(user_id, codes):
    """Salva backup codes (hashed!)"""
    for code in codes:
        code_hash = bcrypt.hashpw(code.encode(), bcrypt.gensalt())

        db.execute(
            "INSERT INTO backup_codes (user_id, code_hash, used) VALUES (?, ?, ?)",
            (user_id, code_hash.decode(), False)
        )

def verify_backup_code(user_id, code):
    """Verifica e invalida backup code"""
    codes = db.execute(
        "SELECT id, code_hash FROM backup_codes WHERE user_id = ? AND used = FALSE",
        (user_id,)
    ).fetchall()

    for row in codes:
        if bcrypt.checkpw(code.encode(), row['code_hash'].encode()):
            # Marca come usato
            db.execute(
                "UPDATE backup_codes SET used = TRUE WHERE id = ?",
                (row['id'],)
            )
            return True

    return False

# Uso
codes = generate_backup_codes()
save_backup_codes(user_id=123, codes=codes)

# Mostra all'utente UNA SOLA VOLTA
print("Backup codes (salvali in luogo sicuro!):")
for code in codes:
    print(f"  {code}")
\end{lstlisting}

\section{OAuth 2.0}

OAuth 2.0 è un framework di autorizzazione che permette applicazioni di terze parti di ottenere accesso limitato a risorse.

\subsection{Ruoli OAuth2}

\begin{description}
    \item[Resource Owner] L'utente che possiede i dati
    \item[Client] L'applicazione che vuole accedere ai dati
    \item[Authorization Server] Server che autentica utente e emette token
    \item[Resource Server] Server che ospita le risorse protette
\end{description}

\subsection{Authorization Code Flow}

\begin{verbatim}
1. Client → User: Redirect a authorization endpoint
   https://auth.example.com/oauth/authorize?
     client_id=CLIENT_ID
     &redirect_uri=https://client.com/callback
     &response_type=code
     &scope=read:profile

2. User → Auth Server: Login e autorizza

3. Auth Server → Client: Redirect con authorization code
   https://client.com/callback?code=AUTH_CODE

4. Client → Auth Server: Scambia code per token
   POST https://auth.example.com/oauth/token
   {
     "grant_type": "authorization_code",
     "code": "AUTH_CODE",
     "client_id": "CLIENT_ID",
     "client_secret": "CLIENT_SECRET",
     "redirect_uri": "https://client.com/callback"
   }

5. Auth Server → Client: Risponde con access token
   {
     "access_token": "ACCESS_TOKEN",
     "token_type": "Bearer",
     "expires_in": 3600,
     "refresh_token": "REFRESH_TOKEN"
   }

6. Client → Resource Server: Richiede risorsa con token
   GET https://api.example.com/user/profile
   Authorization: Bearer ACCESS_TOKEN

7. Resource Server → Client: Risponde con dati
\end{verbatim}

\subsection{Implementazione OAuth2 Server}

\begin{lstlisting}[language=Python, caption=OAuth2 Server con Flask-OAuthlib]
from flask import Flask, request, jsonify
from flask_oauthlib.provider import OAuth2Provider
from datetime import datetime, timedelta
import secrets

app = Flask(__name__)
oauth = OAuth2Provider(app)

# Storage (in produzione: database)
clients = {}
tokens = {}
authorization_codes = {}

@oauth.clientgetter
def load_client(client_id):
    return clients.get(client_id)

@oauth.grantgetter
def load_grant(client_id, code):
    return authorization_codes.get(code)

@oauth.tokengetter
def load_token(access_token=None, refresh_token=None):
    if access_token:
        return tokens.get(access_token)
    elif refresh_token:
        for token in tokens.values():
            if token['refresh_token'] == refresh_token:
                return token
    return None

@app.route('/oauth/authorize', methods=['GET', 'POST'])
def authorize():
    """Authorization endpoint"""
    if request.method == 'GET':
        client_id = request.args.get('client_id')
        redirect_uri = request.args.get('redirect_uri')
        scope = request.args.get('scope')

        # Mostra pagina di consenso all'utente
        return f"""
        <h1>Autorizza applicazione</h1>
        <p>L'applicazione {client_id} richiede accesso a: {scope}</p>
        <form method="POST">
            <button name="authorize" value="yes">Autorizza</button>
            <button name="authorize" value="no">Nega</button>
        </form>
        """

    if request.method == 'POST':
        if request.form.get('authorize') == 'yes':
            # Genera authorization code
            code = secrets.token_urlsafe(32)

            authorization_codes[code] = {
                'client_id': request.args.get('client_id'),
                'redirect_uri': request.args.get('redirect_uri'),
                'scope': request.args.get('scope'),
                'user_id': session['user_id'],  # Utente autenticato
                'expires_at': datetime.now() + timedelta(minutes=10)
            }

            # Redirect con code
            redirect_uri = request.args.get('redirect_uri')
            return redirect(f"{redirect_uri}?code={code}")

@app.route('/oauth/token', methods=['POST'])
def access_token():
    """Token endpoint"""
    grant_type = request.form.get('grant_type')

    if grant_type == 'authorization_code':
        code = request.form.get('code')
        grant = authorization_codes.get(code)

        if not grant or grant['expires_at'] < datetime.now():
            return jsonify({'error': 'invalid_grant'}), 400

        # Genera tokens
        access_token = secrets.token_urlsafe(32)
        refresh_token = secrets.token_urlsafe(32)

        tokens[access_token] = {
            'access_token': access_token,
            'refresh_token': refresh_token,
            'token_type': 'Bearer',
            'expires_in': 3600,
            'scope': grant['scope'],
            'user_id': grant['user_id']
        }

        # Invalida authorization code
        del authorization_codes[code]

        return jsonify(tokens[access_token])

@app.route('/api/user/profile')
def get_profile():
    """Protected resource"""
    auth_header = request.headers.get('Authorization')

    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({'error': 'Unauthorized'}), 401

    access_token = auth_header.split(' ')[1]
    token = load_token(access_token=access_token)

    if not token:
        return jsonify({'error': 'Invalid token'}), 401

    # Restituisci dati utente
    user = get_user(token['user_id'])
    return jsonify({
        'id': user['id'],
        'username': user['username'],
        'email': user['email']
    })
\end{lstlisting}

\section{JSON Web Tokens (JWT)}

JWT è uno standard per creare token di accesso che contengono claims JSON.

\subsection{Struttura JWT}

\begin{verbatim}
JWT = Header.Payload.Signature

Esempio:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

Header (Base64URL):
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload (Base64URL):
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622
}

Signature:
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
\end{verbatim}

\subsection{Implementazione JWT}

\begin{lstlisting}[language=Python, caption=JWT generation e validation]
import jwt
from datetime import datetime, timedelta
import os

SECRET_KEY = os.getenv('JWT_SECRET_KEY')  # Mai hardcodare!

def generate_jwt(user_id, username):
    """Genera JWT token"""
    payload = {
        'sub': user_id,  # Subject (user ID)
        'username': username,
        'iat': datetime.utcnow(),  # Issued at
        'exp': datetime.utcnow() + timedelta(hours=24),  # Expiration
        'iss': 'myapp.com',  # Issuer
        'aud': 'myapp.com'   # Audience
    }

    token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
    return token

def validate_jwt(token):
    """Valida e decode JWT"""
    try:
        payload = jwt.decode(
            token,
            SECRET_KEY,
            algorithms=['HS256'],
            audience='myapp.com',
            issuer='myapp.com'
        )
        return payload
    except jwt.ExpiredSignatureError:
        raise ValueError("Token scaduto")
    except jwt.InvalidTokenError:
        raise ValueError("Token non valido")

# Uso - Login
@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    user_id = authenticate(username, password)

    if not user_id:
        return jsonify({'error': 'Invalid credentials'}), 401

    # Genera JWT
    token = generate_jwt(user_id, username)

    return jsonify({
        'token': token,
        'token_type': 'Bearer'
    })

# Uso - Protected endpoint
@app.route('/api/protected')
def protected():
    auth_header = request.headers.get('Authorization')

    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({'error': 'No token provided'}), 401

    token = auth_header.split(' ')[1]

    try:
        payload = validate_jwt(token)
        return jsonify({
            'message': f'Hello {payload["username"]}!',
            'user_id': payload['sub']
        })
    except ValueError as e:
        return jsonify({'error': str(e)}), 401
\end{lstlisting}

\subsection{JWT Vulnerabilities}

\subsubsection{1. Algorithm Confusion (None algorithm)}

\begin{lstlisting}[language=Python, caption=VULNERABILE - None algorithm]
# VULNERABILE: Accetta algorithm "none"
payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256', 'none'])

# Attacker può creare token con alg: "none" e firma vuota
# {
#   "alg": "none",
#   "typ": "JWT"
# }.{
#   "sub": "admin",
#   "admin": true
# }.

# FIX: Specifica esplicitamente algoritmi permessi
payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])  # Solo HS256
\end{lstlisting}

\subsubsection{2. Weak Secret Key}

\begin{lstlisting}[language=Python, caption=VULNERABILE - Weak secret]
# VULNERABILE: Secret debole
SECRET_KEY = 'secret'  # Facilmente brute-forceable

# Attacker può:
# 1. Brute force il secret
# 2. Creare token validi firmati con secret trovato

# FIX: Usa secret forte, lungo, random
import secrets
SECRET_KEY = secrets.token_urlsafe(32)
# es: 'x7r_9FzK3mPqN8vT2wY5hJ1gD4cB6aE0sU-iO'
\end{lstlisting}

\subsubsection{3. Missing Expiration}

\begin{lstlisting}[language=Python, caption=VULNERABILE - No expiration]
# VULNERABILE: Token senza scadenza
payload = {
    'sub': user_id,
    'username': username
    # Manca 'exp'!
}

# Token valido per sempre = rischio se rubato

# FIX: Sempre impostare scadenza
payload = {
    'sub': user_id,
    'username': username,
    'exp': datetime.utcnow() + timedelta(hours=1)  # Scade in 1 ora
}
\end{lstlisting}

\subsection{JWT Best Practices}

\begin{itemize}
    \item[$\square$] Usa secret key forte (>256 bit random)
    \item[$\square$] Specifica algoritmo esplicitamente
    \item[$\square$] Imposta sempre \texttt{exp} (expiration)
    \item[$\square$] Usa \texttt{iat} (issued at) per tracking
    \item[$\square$] Valida \texttt{iss} (issuer) e \texttt{aud} (audience)
    \item[$\square$] Non mettere dati sensibili nel payload (è solo base64)
    \item[$\square$] Usa HTTPS per trasmissione token
    \item[$\square$] Implementa token refresh mechanism
    \item[$\square$] Considera token revocation (blacklist)
    \item[$\square$] Per dati sensibili, considera JWE (encrypted JWT)
\end{itemize}

\section{Session Management}

\subsection{Session Fixation}

\begin{lstlisting}[language=PHP, caption=VULNERABILE - Session fixation]
<?php
// VULNERABILE
session_start();

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'];
    $password = $_POST['password'];

    if (authenticate($username, $password)) {
        $_SESSION['user_id'] = get_user_id($username);
        // BUG: Usa stesso session ID di prima del login!
    }
}

// Attack:
// 1. Attacker visita site e ottiene PHPSESSID=abc123
// 2. Attacker invia link alla vittima: site.com?PHPSESSID=abc123
// 3. Vittima fa login (mantiene PHPSESSID=abc123)
// 4. Attacker usa PHPSESSID=abc123 → è autenticato come vittima!
?>
\end{lstlisting}

\begin{lstlisting}[language=PHP, caption=SICURO - Regenerate session ID]
<?php
// SICURO
session_start();

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $username = $_POST['username'];
    $password = $_POST['password'];

    if (authenticate($username, $password)) {
        // Rigenera session ID dopo login
        session_regenerate_id(true);  // true = delete old session

        $_SESSION['user_id'] = get_user_id($username);
    }
}
?>
\end{lstlisting}

\subsection{Session Hijacking Prevention}

\begin{lstlisting}[language=Python, caption=Session fingerprinting]
import hashlib

def generate_session_fingerprint(request):
    """Crea fingerprint basato su User-Agent e IP"""
    user_agent = request.headers.get('User-Agent', '')
    ip_address = request.remote_addr

    fingerprint = hashlib.sha256(
        (user_agent + ip_address).encode()
    ).hexdigest()

    return fingerprint

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')

    user_id = authenticate(username, password)

    if user_id:
        session.clear()
        session['user_id'] = user_id
        session['fingerprint'] = generate_session_fingerprint(request)

        return redirect('/dashboard')

@app.before_request
def validate_session():
    """Valida session fingerprint su ogni richiesta"""
    if 'user_id' in session:
        current_fingerprint = generate_session_fingerprint(request)

        if session.get('fingerprint') != current_fingerprint:
            # Possibile session hijacking
            session.clear()
            return redirect('/login?error=session_hijacked')
\end{lstlisting}

\section{Esercizi CTF-Style}

\subsection{Challenge 1: Weak Password Hash}

Database dump:
\begin{verbatim}
users:
- username: admin
- password_hash: 5f4dcc3b5aa765d61d8327deb882cf99
\end{verbatim}

\textbf{Task:} Cracka la password.

\textbf{Soluzione:}
\begin{verbatim}
echo -n "5f4dcc3b5aa765d61d8327deb882cf99" | hashid
# MD5

# Usa rainbow table o brute force
echo -n "password" | md5sum
# 5f4dcc3b5aa765d61d8327deb882cf99

Password: "password"
Flag: CTF{w34k_h4sh_br0k3n}
\end{verbatim}

\subsection{Challenge 2: JWT Algorithm Confusion}

Token JWT con alg: RS256 (public key signature).

\textbf{Task:} Bypassa validazione cambiando algoritmo a HS256.

\textbf{Soluzione:}
\begin{verbatim}
1. Decode JWT
2. Cambia header: "alg": "HS256"
3. Usa public key come secret per firmare con HS256
4. Server valida con public key come secret HMAC
5. Bypass!

Flag: CTF{jwt_4lg_c0nfus10n}
\end{verbatim}

\subsection{Challenge 3: TOTP Bruteforce}

TOTP con time window troppo ampio.

\textbf{Flag:} CTF{t0tp_t1m3_w1nd0w_t00_l4rg3}

\section{Conclusioni}

L'autenticazione sicura è fondamentale per proteggere applicazioni e utenti. Le chiavi sono:

\begin{enumerate}
    \item \textbf{Hash password correttamente:} bcrypt o Argon2
    \item \textbf{Implementa MFA:} TOTP è il minimo
    \item \textbf{Usa OAuth2:} Per delegated authorization
    \item \textbf{JWT con cautela:} Valida attentamente, usa secret forti
    \item \textbf{Session management:} Regenerate ID, fingerprinting
\end{enumerate}

La security è un processo continuo: monitora, testa, aggiorna. Le minacce evolvono, e anche le nostre difese devono evolversi.

\textbf{Stay secure!}
