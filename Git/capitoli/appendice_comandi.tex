\chapter{Appendice: Reference Rapida Comandi}

\section*{Introduzione}
Questa appendice è una reference rapida di tutti i comandi Git più importanti, organizzati per categoria. Ogni comando include sintassi, descrizione breve e opzioni comuni.

\section{Setup e Configurazione}

\subsection{Configurazione Iniziale}

\begin{lstlisting}
# Imposta nome utente globale
git config --global user.name "Your Name"

# Imposta email globale
git config --global user.email "your.email@example.com"

# Imposta editor di default
git config --global core.editor "vim"
git config --global core.editor "code --wait"  # VS Code

# Visualizza configurazione
git config --list
git config --list --show-origin  # mostra file sorgente

# Visualizza configurazione specifica
git config user.name
git config user.email

# Configurazione locale (solo repository corrente)
git config --local user.name "Work Name"

# Rimuovi configurazione
git config --global --unset user.name
\end{lstlisting}

\subsection{Alias Utili}

\begin{lstlisting}
# Alias comuni
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.unstage 'reset HEAD --'

# Alias avanzati
git config --global alias.last 'log -1 HEAD'
git config --global alias.visual 'log --oneline --graph --all --decorate'
git config --global alias.aliases 'config --get-regexp alias'

# Uso
git st           # invece di git status
git visual       # log grafico
\end{lstlisting}

\subsection{Configurazioni Utili}

\begin{lstlisting}
# Colori in output
git config --global color.ui auto

# Cache credentials (HTTPS)
git config --global credential.helper cache
git config --global credential.helper 'cache --timeout=3600'

# Default branch name
git config --global init.defaultBranch main

# Line endings
git config --global core.autocrlf true   # Windows
git config --global core.autocrlf input  # Mac/Linux

# gitignore globale
git config --global core.excludesfile ~/.gitignore_global
\end{lstlisting}

\section{Repository: Creazione e Clonazione}

\begin{lstlisting}
# Inizializza repository locale
git init
git init my-project  # crea directory e inizializza

# Clona repository remoto
git clone <url>
git clone <url> <directory-name>
git clone -b <branch> <url>  # clona branch specifico

# Clone shallow (solo ultimo commit)
git clone --depth 1 <url>

# Clone con submodules
git clone --recursive <url>
\end{lstlisting}

\section{Status e Informazioni}

\begin{lstlisting}
# Status working directory
git status
git status -s          # formato breve
git status -sb         # breve con branch info

# Visualizza modifiche
git diff               # working directory vs staging
git diff --staged      # staging vs ultimo commit
git diff HEAD          # working directory vs ultimo commit
git diff <branch1> <branch2>  # confronta branch

# Log commits
git log
git log --oneline      # una riga per commit
git log --graph        # grafico ASCII
git log --all          # tutti i branch
git log -n 5           # ultimi 5 commit
git log --since="2 weeks ago"
git log --author="Name"
git log --grep="keyword"  # cerca in commit messages
git log -- <file>      # cronologia file specifico

# Log avanzato
git log --oneline --graph --all --decorate
git log --stat         # mostra file modificati
git log -p             # mostra patch (diff)
git log --follow <file>  # segue rename

# Mostra commit specifico
git show <commit-hash>
git show HEAD
git show HEAD~3        # 3 commit indietro
\end{lstlisting}

\section{Staging e Commit}

\begin{lstlisting}
# Aggiungi file a staging
git add <file>
git add .              # tutti i file nella directory
git add -A             # tutti i file nel repository
git add *.js           # pattern
git add -p             # interattivo (per hunk)

# Rimuovi da staging
git reset HEAD <file>
git restore --staged <file>  # Git 2.23+

# Commit
git commit -m "message"
git commit -am "message"  # add + commit (solo tracked files)
git commit --amend        # modifica ultimo commit
git commit --amend -m "new message"  # cambia messaggio

# Rimuovi file
git rm <file>          # rimuove e stage
git rm --cached <file> # rimuove da Git, mantieni locale
git rm -r <directory>  # ricorsivo

# Rinomina/Sposta file
git mv <old> <new>
\end{lstlisting}

\section{Branch}

\begin{lstlisting}
# Lista branch
git branch             # locali
git branch -r          # remoti
git branch -a          # tutti
git branch -v          # con ultimo commit
git branch -vv         # con tracking info

# Crea branch
git branch <name>
git branch <name> <commit>  # da commit specifico

# Cambia branch
git checkout <branch>
git switch <branch>    # Git 2.23+

# Crea e cambia branch
git checkout -b <name>
git switch -c <name>   # Git 2.23+

# Rinomina branch
git branch -m <old-name> <new-name>
git branch -m <new-name>  # rinomina branch corrente

# Cancella branch
git branch -d <name>   # safe delete (merged)
git branch -D <name>   # force delete

# Branch tracking
git branch -u origin/<branch>  # imposta upstream
git branch --unset-upstream    # rimuovi upstream
\end{lstlisting}

\section{Merge}

\begin{lstlisting}
# Merge branch nel corrente
git merge <branch>

# Merge con opzioni
git merge <branch> --no-ff     # crea sempre merge commit
git merge <branch> --squash    # squash tutti i commit
git merge <branch> -m "message"

# Abbandona merge
git merge --abort

# Merge strategies
git merge -X ours <branch>     # preferisci versione corrente
git merge -X theirs <branch>   # preferisci versione in merge

# Merge tool
git mergetool
git mergetool --tool=vimdiff
\end{lstlisting}

\section{Rebase}

\begin{lstlisting}
# Rebase branch corrente su altro branch
git rebase <branch>
git rebase origin/main

# Rebase interattivo
git rebase -i HEAD~3   # ultimi 3 commit
git rebase -i <commit>

# Durante rebase
git rebase --continue  # dopo risoluzione conflitti
git rebase --abort     # abbandona
git rebase --skip      # salta commit corrente

# Opzioni rebase
git rebase -i --autosquash  # auto squash commit fixup/squash
\end{lstlisting}

\section{Remote Repository}

\begin{lstlisting}
# Lista remote
git remote
git remote -v          # con URL

# Aggiungi remote
git remote add <name> <url>
git remote add origin https://github.com/user/repo.git

# Rimuovi/rinomina remote
git remote remove <name>
git remote rename <old> <new>

# Mostra info remote
git remote show origin

# Modifica URL remote
git remote set-url origin <new-url>

# Fetch (scarica senza merge)
git fetch
git fetch origin
git fetch --all        # tutti i remote
git fetch --prune      # rimuovi reference obsoleti

# Pull (fetch + merge)
git pull
git pull origin main
git pull --rebase      # rebase invece di merge
git pull --ff-only     # solo fast-forward

# Push
git push
git push origin main
git push -u origin main  # imposta upstream
git push --all         # tutti i branch
git push --tags        # tutti i tag
git push --force       # PERICOLO: forza push
git push --force-with-lease  # forza ma verifica remote
git push origin --delete <branch>  # cancella branch remoto
\end{lstlisting}

\section{Stash}

\begin{lstlisting}
# Salva modifiche
git stash
git stash save "message"
git stash -u           # include untracked files
git stash --all        # include anche ignored files

# Lista stash
git stash list

# Applica stash
git stash apply        # applica ultimo, mantieni stash
git stash apply stash@{2}  # applica specifico
git stash pop          # applica e rimuovi stash

# Visualizza stash
git stash show
git stash show -p      # con diff

# Rimuovi stash
git stash drop stash@{0}
git stash clear        # rimuovi tutti

# Crea branch da stash
git stash branch <branch-name>
\end{lstlisting}

\section{Reset e Revert}

\begin{lstlisting}
# Reset (modifica HEAD)
git reset <file>       # unstage file (mixed)
git reset              # unstage tutto

git reset --soft HEAD~1     # sposta HEAD, mantieni staging + working
git reset --mixed HEAD~1    # (default) resetta staging
git reset --hard HEAD~1     # PERICOLO: resetta tutto

# Reset a commit specifico
git reset --hard <commit>
git reset --hard origin/main

# Revert (crea commit che annulla)
git revert <commit>
git revert HEAD
git revert HEAD~3
git revert <commit1> <commit2>  # multipli

# Opzioni revert
git revert --no-commit <commit>  # revert senza committare
git revert --abort     # abbandona revert in corso
\end{lstlisting}

\section{Cherry-Pick}

\begin{lstlisting}
# Applica commit da altro branch
git cherry-pick <commit>
git cherry-pick <commit1> <commit2>
git cherry-pick <commit-start>..<commit-end>

# Opzioni
git cherry-pick --no-commit <commit>  # applica senza commit
git cherry-pick -e <commit>  # modifica messaggio
git cherry-pick -x <commit>  # aggiungi reference originale

# Durante cherry-pick con conflitti
git cherry-pick --continue
git cherry-pick --abort
git cherry-pick --skip
\end{lstlisting}

\section{Tag}

\begin{lstlisting}
# Lista tag
git tag
git tag -l "v1.*"      # pattern

# Crea tag
git tag <tag-name>     # lightweight
git tag -a <tag-name> -m "message"  # annotated
git tag -a <tag-name> <commit>  # su commit specifico

# Mostra tag
git show <tag-name>

# Push tag
git push origin <tag-name>
git push origin --tags  # tutti i tag
git push --follow-tags  # solo annotated

# Cancella tag
git tag -d <tag-name>  # locale
git push origin --delete <tag-name>  # remoto
git push origin :refs/tags/<tag-name>  # alternativa

# Checkout tag
git checkout <tag-name>  # detached HEAD
git checkout -b <branch-name> <tag-name>  # crea branch
\end{lstlisting}

\section{Reflog}

\begin{lstlisting}
# Visualizza reflog
git reflog
git reflog show HEAD
git reflog show <branch>

# Limita output
git reflog -5          # ultimi 5 movimenti

# Reset usando reflog
git reset --hard HEAD@{2}
git reset --hard main@{yesterday}

# Crea branch da reflog
git branch <branch-name> HEAD@{3}

# Cleanup reflog
git reflog expire --expire=now --all
git reflog expire --expire=30.days.ago --all
\end{lstlisting}

\section{Bisect}

\begin{lstlisting}
# Inizia bisect
git bisect start

# Marca commit good/bad
git bisect bad         # commit corrente ha bug
git bisect good <commit>  # commit senza bug

# Durante bisect
git bisect good        # commit corrente ok
git bisect bad         # commit corrente ha bug
git bisect skip        # non testabile

# Bisect automatico
git bisect run <script>

# Termina bisect
git bisect reset

# Visualizza log bisect
git bisect log
\end{lstlisting}

\section{Informazioni e Diagnostica}

\begin{lstlisting}
# Verifica integrità repository
git fsck
git fsck --full

# Conta oggetti
git count-objects -v
git count-objects -vH  # human readable

# Garbage collection
git gc
git gc --aggressive --prune=now

# Blame (chi ha modificato ogni riga)
git blame <file>
git blame -L 10,20 <file>  # solo righe 10-20
git blame -w <file>  # ignora whitespace

# Grep (cerca nel codice)
git grep "pattern"
git grep -n "pattern"  # con numeri riga
git grep --count "pattern"  # conta occorrenze

# Trova commit che ha aggiunto/rimosso stringa
git log -S "function_name"
git log -G "regex_pattern"

# Mostra chi ha introdotto un file
git log --diff-filter=A -- <file>

# File tree
git ls-tree HEAD
git ls-tree -r HEAD    # ricorsivo
git ls-tree -r HEAD --name-only  # solo nomi
\end{lstlisting}

\section{Pulizia e Manutenzione}

\begin{lstlisting}
# Rimuovi file untracked
git clean -n           # dry run (mostra cosa rimuove)
git clean -f           # rimuovi file
git clean -fd          # rimuovi file e directory
git clean -fx          # include ignored files

# Ottimizzazione
git gc --auto
git repack -a -d
git prune

# Verifica repository
git fsck --full --no-dangling
\end{lstlisting}

\section{Submodules}

\begin{lstlisting}
# Aggiungi submodule
git submodule add <url> <path>

# Inizializza submodules dopo clone
git submodule init
git submodule update

# Clone con submodules
git clone --recursive <url>

# Update submodules
git submodule update --remote

# Rimuovi submodule
git submodule deinit <path>
git rm <path>
\end{lstlisting}

\section{Worktree}

\begin{lstlisting}
# Crea worktree (multiple working directory)
git worktree add <path> <branch>
git worktree add ../hotfix hotfix-branch

# Lista worktree
git worktree list

# Rimuovi worktree
git worktree remove <path>
git worktree prune
\end{lstlisting}

\section{Advanced}

\begin{lstlisting}
# Filter branch (riscrive cronologia)
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD

# Filter repo (tool moderno)
git filter-repo --path file-to-keep --invert-paths

# Patch
git format-patch -1 HEAD  # crea patch da ultimo commit
git apply <patch-file>    # applica patch
git am <patch-file>       # applica come commit

# Archive
git archive --format=zip HEAD > archive.zip
git archive --format=tar.gz --prefix=project/ HEAD > project.tar.gz

# Bundle (repository portabile)
git bundle create repo.bundle --all
git clone repo.bundle -b main new-repo

# Sparse checkout
git sparse-checkout init --cone
git sparse-checkout set folder1 folder2

# Rerere (riuso resolution)
git config --global rerere.enabled true
\end{lstlisting}

\section{Shortlog e Contributors}

\begin{lstlisting}
# Lista contributors
git shortlog -sn       # ordina per numero commit
git shortlog -sne      # include email

# Statistiche
git log --author="Name" --oneline | wc -l  # commit per autore
git log --since="1 year ago" --oneline | wc -l  # commit ultimo anno
\end{lstlisting}

\section{Tabella Riassuntiva: Annullare Modifiche}

\begin{center}
\small
\begin{tabular}{|p{4cm}|p{5cm}|p{3cm}|}
\hline
\textbf{Scenario} & \textbf{Comando} & \textbf{Pericolo} \\
\hline
File modificato (unstaged) & \texttt{git restore <file>} & SÌ (perdi modifiche) \\
\hline
File in staging & \texttt{git restore --staged <file>} & NO \\
\hline
Modifica ultimo commit & \texttt{git commit --amend} & Medio (se già pushato) \\
\hline
Annulla ultimo commit & \texttt{git reset --soft HEAD\textasciitilde1} & NO \\
\hline
Annulla + unstage & \texttt{git reset HEAD\textasciitilde1} & NO \\
\hline
Distruggi ultimo commit & \texttt{git reset --hard HEAD\textasciitilde1} & SÌ (perdi modifiche) \\
\hline
Annulla commit pushato & \texttt{git revert <commit>} & NO (sicuro) \\
\hline
\end{tabular}
\end{center}

\section{Tabella Riassuntiva: Reset}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Opzione} & \textbf{HEAD} & \textbf{Staging} & \textbf{Working Dir} \\
\hline
\texttt{--soft} & Modifica & Invariato & Invariato \\
\texttt{--mixed} (default) & Modifica & Resetta & Invariato \\
\texttt{--hard} & Modifica & Resetta & Resetta \\
\hline
\end{tabular}
\end{center}

\section{Simboli Speciali}

\begin{lstlisting}
HEAD        # Commit corrente
HEAD~1      # 1 commit indietro
HEAD~3      # 3 commit indietro
HEAD^       # Parent del commit (equivalente a HEAD~1)
HEAD^^      # 2 commit indietro

# In merge commits (multiple parents)
HEAD^1      # Primo parent
HEAD^2      # Secondo parent

# Combinazioni
main~3      # 3 commit indietro da main
origin/main # Branch main su remote origin

# Reference
@           # Shortcut per HEAD
@{-1}       # Branch precedente
main@{yesterday}  # main di ieri
main@{2.days.ago} # main 2 giorni fa
\end{lstlisting}

\section{Pattern .gitignore}

\begin{lstlisting}
# Commenti
# Questo è un commento

# File specifico
debug.log

# Tutti i file con estensione
*.log
*.tmp

# Directory
node_modules/
dist/

# Pattern ricorsivo
**/*.pyc

# Negazione (non ignorare)
!important.log

# Solo in root
/TODO.txt

# Tutti tranne
build/*
!build/version.txt
\end{lstlisting}

\section{Caratteri Speciali in Comandi}

\begin{lstlisting}
# Range di commit
git log <commit1>..<commit2>    # da commit1 a commit2 (escluso commit1)
git log <commit1>...<commit2>   # symmetric difference

# Tutti i commit di branch2 non in branch1
git log branch1..branch2

# Commit raggiungibili da HEAD ma non da origin/main
git log origin/main..HEAD

# Tutti i file modificati tra commit
git diff <commit1>..<commit2>
\end{lstlisting}

\begin{tcolorbox}[colback=green!10, colframe=green!60, title=Suggerimento]
Stampa questa appendice e tienila a portata di mano! I comandi Git sono tanti, ma con la pratica i più comuni diventeranno automatici.
\end{tcolorbox}
