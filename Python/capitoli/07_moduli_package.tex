% Modulo 07 — Moduli e Package
\chapter{Moduli e Package}

\section{Introduzione}
Organizzare codice in moduli e package, import e percorso di ricerca.

Questa descrizione spiega come strutturare un progetto in unità coerenti, evitare conflitti di nomi e adottare convenzioni di import leggibili. Tocchiamo \texttt{\_\_init\_\_.py}, percorsi relativi/assoluti e il ruolo di \texttt{sys.path}.

Un buon design dei package rende il codice estensibile e manutenibile, facilitando test, riuso e distribuzione.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Creare e importare moduli.
  \item Strutturare package con \texttt{\_\_init\_\_.py}.
  \item Comprendere \texttt{sys.path} e import relativi.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Import]
\texttt{from pkg.mod import func} e \texttt{import pkg.mod as m}
\end{tcolorbox}

\begin{tcolorbox}[title=Strutturazione e convenzioni]
La scelta tra \textbf{import assoluti e relativi} è importante per la chiarezza. Gli import assoluti dovrebbero essere preferiti poiché evitano ambiguità derivanti da import relativi profondi, rendendo il codice più leggibile e manutenibile.

Quando si organizzano package, è importante \textbf{mantenere } \texttt{\_\_init\_\_} \textbf{ minimale}. Il file dovrebbe contenere solo re-export selettivi e costanti del package, evitando logica complessa che rende difficile comprendere l'API.

La \textbf{progettazione dell'API di package} è fondamentale. Decidere consapevolmente cosa esporre dal livello radice e cosa mantenere come implementazione interna (tramite nome prefissato con underscore) crea un'interfaccia pulita per i consumatori.

Un principio importante è evitare \textbf{side-effect all'import}. L'import di un modulo non dovrebbe avere conseguenze osservabili come apertura di file o connessioni di database; queste operazioni dovrebbero essere inizializzate su richiesta esplicita.

Infine, \textbf{documentare le dipendenze interne} tra moduli riduce l'accoppiamento e facilita i refactoring futuri. Una struttura chiara aiuta a evitare cicli di dipendenza.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{Modulo semplice}
\begin{lstlisting}
# file: util.py
def say(msg):
    print(msg)

# file: app.py
import util
util.say("Ciao")
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- Il modulo \texttt{util.py} definisce una funzione e viene importato in \texttt{app.py}.
- \texttt{import util} carica il modulo e ne usa il namespace: \texttt{util.say(...)}.
- Preferire import espliciti (funzioni o nomi) quando la UX lo richiede: \texttt{from util import say}.
- Evitare side-effect all'import: l'esecuzione dovrebbe avvenire in \texttt{main()} o funzioni dedicate.
\end{tcolorbox}

\subsection{Package}
\begin{lstlisting}
# pkg/__init__.py
# pkg/tools.py
def add(a, b):
    return a + b

# main.py
from pkg.tools import add
print(add(2, 3))
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- Un package è una cartella (\texttt{pkg/}) con moduli; \texttt{\_\_init\_\_.py} può essere vuoto o fare re-export.
- \texttt{from pkg.tools import add} importa simboli dal modulo \texttt{tools} all'interno del package.
- Mantenere \texttt{\_\_init\_\_.py} minimale e documentare l'API pubblica con \verb|__all__| se necessario.
- Preferire import assoluti per chiarezza; usare relativi solo all'interno del package.
\end{tcolorbox}

\subsection{sys.path}
\begin{lstlisting}
import sys
print(sys.path)
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \texttt{sys.path} è la lista di percorsi in cui Python cerca moduli e package.
- Modificare \texttt{sys.path} a runtime è possibile ma va limitato a script/CLI, non a librerie.
- Per la distribuzione, usare package installabili invece di aggiungere path manualmente.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
I moduli e package sono particolarmente utili per creare librerie interne di utilità condivise tra progetti scollegati, centralizzando funzionalità comuni e riducendo duplicazione di codice.

L'organizzazione di applicazioni complesse beneficia della suddivisione in sottopackage tematici come \texttt{core} per la logica centrale, \texttt{api} per le interfacce esterne e \texttt{cli} per comandi da linea di comando, migliorando la navigabilità e la manutenibilità.

La separazione di plugin ed estensioni in moduli dedicati caricabili dinamicamente permette di estendere le funzionalità dell'applicazione senza modificare il core, seguendo il principio Open/Closed.

Infine, il re-export dell'API pubblica dal package root migliora l'esperienza utente, permettendo import concisi come \verb|from mypackage import MyClass| invece di percorsi lunghi come \verb|from mypackage.internal.core import MyClass|.
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Crea un package con due moduli e import incrociati.
  \item Implementa un modulo \texttt{mathutil} con funzioni di base.
  \item Usa alias negli import e confronta leggibilità.
  \item Esplora \texttt{sys.path} e aggiungi un percorso temporaneo.
  \item Organizza un progetto in package e sottopackage.
\end{enumerate}

\section{Riepilogo}
Hai organizzato codice con moduli e package in modo pulito.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
- Organizzare progetti medio-grandi in package coerenti.
- Definire API pubblica del package con re-export.
- Isolare plugin/estensioni con moduli dedicati.
- Preparare distribuzione e riuso interno.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
La scelta tra \textbf{import assoluti e relativi} è una decisione di design importante. Import assoluti dovrebbero essere preferiti per la loro chiarezza e universalità; import relativi sono utili principalmente all'interno di pacchetti for evitare nomi lunghi, ma possono creare ambiguità se non usati con attenzione.

Il file \verb|__init__.py| è lo strumento principale per \textbf{controllare l'esposizione del pacchetto}. È possibile usare \verb|__all__| per definire esplicitamente l'API pubblica, facendo sì che solo i simboli elencati siano importabili con `from pkg import *`.

Una \textbf{struttura di moduli} ben progettata separa le responsabilità chiaramente e evita cicli di dipendenze che compromettono il mantenimento. Predisporre sottopacchetti coerenti che riflettono la struttura logica del progetto facilita la navigazione e la comprensione.

Infine, \textbf{ambienti e dipendenze} dovrebbero essere gestiti attentamente. Congelare le versioni delle dipendenze in un file di requisiti (come `requirements.txt`) e documentare vincoli di compatibilità assicura che il codice funzioni in modo prevedibile in diversi ambienti.
\end{tcolorbox}

\paragraph{Distribuzione} Valutare packaging con \verb|pyproject.toml| e strumenti moderni; integrare test e lint nel processo di rilascio.
Consulta: \url{https://docs.python.org/3/tutorial/modules.html}.
