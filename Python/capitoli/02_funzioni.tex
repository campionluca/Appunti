% Modulo 02 — Funzioni
\chapter{Funzioni}

\section{Introduzione}
Le funzioni sono blocchi riutilizzabili di codice. In Python si definiscono con \texttt{def}, possono avere parametri, valori di default, \texttt{*args} e \texttt{**kwargs}, e restituiscono valori con \texttt{return}.

Questa descrizione illustra come strutturare funzioni piccole e focalizzate, come documentarle con docstring e come scegliere le firme per rendere il codice facile da testare e riutilizzare. Discuteremo anche gli effetti dello scope e delle chiusure per evitare comportamenti inattesi.

Padroneggiare le funzioni consente di organizzare il progetto in unità logiche, ridurre duplicazioni e migliorare la leggibilità, con impatto diretto su manutenzione e qualità.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Definire funzioni con parametri e valori di default.
  \item Usare \texttt{*args} e \texttt{**kwargs} per flessibilità negli argomenti.
  \item Comprendere la visibilità delle variabili (LEGB) e le docstring.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Firma delle Funzioni]
Esempio: \texttt{def greet(name: str, upper: bool = False) -> str: ...}
Docstring: descrive comportamento, parametri e return.
\end{tcolorbox}

\begin{tcolorbox}[title=Purezza ed effetti collaterali]
Preferisci funzioni pure (stessa input $\rightarrow$ stessa output, senza effetti esterni) quando possibile. Riduci dipendenze globali e I/O nella logica, isolandole in layer dedicati per facilitare test e riuso.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{Funzione semplice}
\begin{lstlisting}
def add(a, b):
    """Ritorna la somma di a e b."""
    return a + b

print(add(2, 3))
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Definizione}: `def add(a, b)` crea una funzione; il docstring descrive contratto.  
- \textbf{Return}: restituisce somma di due argomenti; pura, senza I/O.  
- \textbf{Invocazione}: `print(add(...))` compone I/O con logica; separare in pratica.
\end{tcolorbox}

\subsection{Default, *args e **kwargs}
\begin{lstlisting}
def greet(name, upper=False):
    msg = f"Ciao, {name}!"
    return msg.upper() if upper else msg

def total(*args):
    return sum(args)

def describe(**kwargs):
    return ", ".join(f"{k}={v}" for k, v in kwargs.items())

print(greet("Ada", upper=True))
print(total(1, 2, 3))
print(describe(lang="Python", version=3.11))
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Default}: `upper=False` definisce parametro opzionale; evita default mutabili.  
- \textbf{*args}: raccoglie posizione variabile di argomenti in una tupla.  
- \textbf{**kwargs}: raccoglie coppie chiave/valore in un dizionario; utile per parametri nominati flessibili.
\end{tcolorbox}

\subsection{Scope e lambda}
\begin{lstlisting}
factor = 2
def mul(x):
    return x * factor  # legge dalla closure globale

double = lambda x: x * 2
print(mul(5), double(5))
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Scope}: `mul` legge `factor` dallo scope esterno (E nel LEGB).  
- \textbf{Lambda}: funzioni anonime per espressioni semplici; preferire `def` per logiche complesse.  
- \textbf{Effetti}: nessun I/O dentro `mul`; la stampa è separata.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
\begin{itemize}
  \item Librerie di utilità con funzioni riusabili e ben documentate.
\item Calcoli e trasformazioni di dati separati dall'I/O.
  \item API interne con firme stabili e test unitari.
\end{itemize}
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Scrivi una funzione che calcola il fattoriale di un numero (iterativa e ricorsiva).
  \item Crea una funzione \texttt{safe\_div(a, b)} che gestisce divisione per zero.
  \item Implementa una funzione che normalizza una lista di numeri tra 0 e 1.
  \item Usa \texttt{*args} per sommare un numero variabile di valori.
  \item Scrivi una funzione che formatta una stringa con parametri via \texttt{**kwargs}.
\end{enumerate}

\section{Riepilogo}
Hai imparato a definire funzioni, gestire parametri flessibili e comprendere scope e lambda.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
- Progettare API di modulo e funzioni riutilizzabili.
- Funzioni pure per testabilità e caching.
- Higher-order functions per composizione.
- Validazione e parsing input incapsulati.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
Nella progettazione delle \textbf{firme delle funzioni}, è opportuno preferire parametri nominali (keyword) per migliorare la chiarezza delle chiamate. Usare argomenti obbligatori per gli input essenziali e parametri opzionali con valori di default per quelli meno critici rende l'API più intuitiva.

Un errore comune riguarda l'uso di \textbf{default mutabili}. Assegnare una lista o un dizionario come valore di default (ad esempio, \verb|def f(x=[])|) è un anti-pattern pericoloso perché il valore di default viene creato una sola volta all'atto della definizione della funzione, causando sharing indesiderato tra chiamate. La soluzione è usare \verb|None| come default e inizializzare l'oggetto mutabile all'interno della funzione.

I parametri \textbf{\*args e \*\*kwargs} sono utili per accettare un numero variabile di argomenti, permettendo grande flessibilità nella firma della funzione. Tuttavia, è essenziale documentare chiaramente cosa viene accettato e, nel caso di \*\*kwargs, quali chiavi sono supportate.

La documentazione mediante \textbf{docstring e annotazioni di tipo} è fondamentale per comunicare il contratto di una funzione. Docstring dovrebbero spiegare comportamento, parametri, valore di ritorno e possibili eccezioni; le annotazioni di tipo facilitano l'inferenza e comunicano le aspettative ai lettori e agli strumenti di analisi statica.

Un principio importante è la distinzione tra \textbf{purezza e effetti collaterali}. Preferire funzioni pure (quelle che non modificano stato esterno e non dipendono da esso) quando possibile rende il codice testabile e prevedibile. Gli effetti collaterali come I/O e mutazioni dovrebbero essere isolati ai confini del sistema.

Concetti avanzati come \textbf{closure e currying} permettono di chiudere valori nell'ambiente per creare funzioni specializzate. Tuttavia, è necessario prestare attenzione alla cattura di variabili mutevoli, poiché il comportamento può diventare sorprendente se le variabili cambiano valore dopo la definizione della closure.
\end{tcolorbox}

\begin{tcolorbox}[title=Per chi viene da C/Java/JS: firme e scope]
\textbf{Annotazioni di tipo}: sono opzionali e non vincolanti a runtime; servono a lettori e strumenti.  
\textbf{Keyword arguments}: chiamate come `func(x=1, y=2)` aumentano la chiarezza rispetto agli argomenti posizionali.  
\textbf{LEGB scope}: Local, Enclosing, Global, Built-in: risoluzione dei nomi dall'interno verso l'esterno; evita dipendenze da globali.

Esempi commentati:
\begin{lstlisting}
# Default mutabile: anti-pattern
def append_item_bad(item, bucket=[]):
    bucket.append(item)
    return bucket

# Uso corretto
def append_item(item, bucket=None):
    if bucket is None:
        bucket = []
    bucket.append(item)
    return bucket

# Keyword arguments e type hint
from typing import Iterable, Callable

def transform(xs: Iterable[int], fn: Callable[[int], int]) -> list[int]:
    return [fn(x) for x in xs]

data = [1, 2, 3]
res = transform(xs=data, fn=lambda x: x * 2)
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Default mutabile}: `bucket=[]` condivide lista tra chiamate; bug classico.  
- \textbf{Pattern corretto}: usa `None` e inizializza all'interno per isolare stato.
- \textbf{Type hints}: `Iterable[int]` e `Callable` comunicano contratto; non impongono a runtime.  
- \textbf{Keyword args}: chiamata `transform(xs=data, fn=...)` aumenta chiarezza dei parametri.
\end{tcolorbox}
\end{tcolorbox}

\begin{tcolorbox}[title={Idiomi: funzioni piccole, composizione, map/filter}]
La \textbf{composizione} di funzioni piccole e pure è uno dei principi cardine della programmazione funzionale e di un buon design software. Costruire pipeline componibili consente di combinare operazioni semplici per risolvere problemi complessi, migliorando la testabilità e la riusabilità.

Le funzioni \textbf{map e filter} rappresentano operazioni fondamentali su collezioni. È possibile usarle direttamente (`map(f, xs)` e `filter(pred, xs)`) oppure preferire le list comprehension `[f(x) for x in xs]` e `[x for x in xs if pred(x)]` che spesso risultano più leggibili e Pythonici.

La \textbf{documentazione mediante docstring} dovrebbe includere esempi d'uso chiari e descrivere i contratti della funzione. I commenti all'interno della funzione dovrebbero spiegare il "perché" piuttosto che il "cosa", evitando commenti superflui che semplicemente ripetono il codice.

\begin{lstlisting}
def normalize(xs):
    """Riporta i valori in [0, 1]."""
    m = max(xs) or 1
    return [x / m for x in xs]

def pipeline(xs):
    return normalize([x for x in xs if x > 0])

print(pipeline([-2, 3, 6]))  # [0.5, 1.0]
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Docstring}: descrive contratto e output atteso.  
- \textbf{max or 1}: fallback per evitare divisione per zero su lista vuota.  
- \textbf{Comprensione}: crea nuova lista normalizzata; `pipeline` mostra composizione filtrando positivi.
\end{tcolorbox}
\end{tcolorbox}

\paragraph{Composizione} Creare pipeline di funzioni piccole e testabili; separare parsing, validazione e trasformazione, restituendo strutture dati chiare.
Consulta: \url{https://docs.python.org/3/tutorial/controlflow.html#defining-functions} e PEP 8 per docstring.
