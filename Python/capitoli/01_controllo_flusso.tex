% Modulo 01 — Controllo del Flusso
\chapter{Controllo del Flusso}

\section{Introduzione}
Questo modulo copre le strutture di controllo fondamentali in Python: condizioni, cicli e controllo del flusso dell'esecuzione.

La descrizione mette in evidenza quando preferire costrutti semplici e leggibili, come ridurre la complessità dei rami condizionali e come evitare loop inefficienti. Vedremo pattern comuni (guard clauses, early return) e insidie tipiche (condizioni annidate, off-by-one).

Capire bene il controllo del flusso è essenziale per scrivere codice chiaro, testabile e performante in scenari come elaborazione di liste, validazione di input e automazione di compiti ripetitivi.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Utilizzare \texttt{if}, \texttt{elif}, \texttt{else} con operatori di confronto e logici.
  \item Scrivere cicli \texttt{for} e \texttt{while}, usare \texttt{break}, \texttt{continue}, \texttt{pass}.
  \item Iterare su sequenze e range in modo idiomatico.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Operatori]
Confronto: \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}. Logici: \texttt{and}, \texttt{or}, \texttt{not}. Appartenenza: \texttt{in}, \texttt{not in}.
\end{tcolorbox}

\begin{tcolorbox}[title=Precedenza e short-circuit]
Gli operatori logici valutano da sinistra a destra e possono interrompere la valutazione (\emph{short-circuit}). Usa parentesi per evitare ambiguità e preferisci condizioni semplici con guard clauses ed \emph{early return} per migliorare leggibilità.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{Condizioni}
\begin{lstlisting}
eta = 18
if eta < 18:
    print("Minorenne")
elif eta == 18:
    print("Appena maggiorenne")
else:
    print("Maggiorenne")
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Branching}: catene `if/elif/else` gestiscono casi esclusivi.  
- \textbf{Confronto}: `==` vs `<`; preferire condizioni semplici e nomi espliciti.  
- \textbf{I/O}: la stampa è l'effetto; separare logica dal lato utente quando possibile.
\end{tcolorbox}

\subsection{Cicli for e while}
\begin{lstlisting}
# for su range
for i in range(3):
    print(i)

# while con condizione
count = 0
while count < 3:
    print(count)
    count += 1
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{range}: genera 0..2; preferire `enumerate(seq)` quando si itera su collezioni.  
- \textbf{while}: usa condizione booleana e aggiorna stato (`count += 1`).  
- \textbf{Chiarezza}: evitare `while True` con break se un range o un iterabile è sufficiente.
\end{tcolorbox}

\subsection{break e continue}
\begin{lstlisting}
for n in range(10):
    if n == 5:
        break
    if n % 2 == 0:
        continue
    print(n)  # stampa solo dispari prima del 5
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{break}: interrompe il ciclo quando `n == 5`; utile per early exit.  
- \textbf{continue}: salta iterazioni per numeri pari; riduce annidamento.  
- \textbf{Intento}: il commento esplicita comportamento; preferire condizioni leggibili a logica implicita.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
\begin{itemize}
  \item Validazione di input con condizioni chiare e rami ben definiti.
  \item Elaborazione di liste/dizionari con loop e filtri.
  \item Workflow di automazione con controlli su stati e errori.
\end{itemize}
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Data una temperatura, stampa "Freddo", "Tiepido" o "Caldo" usando \texttt{if/elif/else}.
  \item Stampa i numeri da 1 a 100, sostituisci multipli di 3 con "Fizz" e di 5 con "Buzz".
  \item Calcola la somma dei numeri pari da 1 a 50.
  \item Chiedi numeri all'utente finché digita 0, poi stampa il totale.
  \item Itera su una lista di stringhe e stampa solo quelle con lunghezza \(> 3\).
\end{enumerate}

\section{Riepilogo}
Hai visto le strutture di controllo principali per governare il flusso del programma.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
- Orchestrare logiche di business e validazioni.
- Implementare state machine e menu interattivi.
- Gestire retry/backoff e circuit breaker semplificati.
- Costruire pipeline di elaborazione condizionale.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
I \textbf{condizionali} sono la base del controllo del flusso. È fondamentale usare \verb|if/elif/else| con condizioni semplici e leggibili; quando una condizione diventa complessa, è consigliabile scomporla in variabili intermedie che documentino l'intenzione del codice.

Un concetto importante riguarda lo \textbf{short-circuit} degli operatori logici. Gli operatori \verb|and| e \verb|or| interrompono la valutazione non appena l'esito è determinato, il che ha implicazioni sia per le prestazioni sia per la semantica del codice. Questo meccanismo può essere sfruttato intenzionalmente, ma deve essere fatto con consapevolezza per evitare comportamenti inattesi.

Quando si scrive codice iterativo, la scelta tra \textbf{cicli} \verb|for| e \verb|while| dipende dalla natura del problema: \verb|for| è preferito quando si itera su sequenze o iterabili definiti, mentre \verb|while| è più adatto per condizioni generali. Gli statement \verb|break| e \verb|continue| permettono di controllare il flusso, ma dovrebbero essere usati con parsimonia per evitare di rendere il codice difficile da seguire.

Una caratteristica spesso trascurata è la \textbf{clausola else su for/while}, che viene eseguita se il ciclo termina senza incontrare un \verb|break|. Questo è particolarmente utile per rilevare quando una condizione di ricerca non è stata soddisfatta, eliminando la necessità di flag booleani.

Lavorando con \verb|range|, è importante ricordare che \verb|range(n)| esclude \verb|n|, il che può causare errori off-by-one se non si fa attenzione. Inoltre, è preferibile usare l'enumerazione con \verb|enumerate| piuttosto che mantenere contatori manuali.

L'\textbf{operatore walrus (:=)}, introdotto in Python 3.8, consente di assegnare e usare un valore nella stessa espressione. Può rendere più espressivi alcuni pattern di lettura e validazione, ma il suo abuso riduce la chiarezza del codice; deve essere usato con discernimento.
\end{tcolorbox}

\begin{tcolorbox}[title=Per chi viene da C/Java/JS: tradurre i pattern]
\textbf{for}: in Python itera su elementi, non sugli indici; usa `enumerate(xs)` per avere coppie `(i, x)`.  
\textbf{break/continue}: come in C/Java; la clausola `else` su `for/while` è eseguita se non avviene `break`.  
\textbf{switch}: usa `if/elif` o `dict` di funzioni per dispatch.  
\textbf{Comprehension}: preferire `[f(x) for x in xs if cond]` a loop con accumulatore quando leggibile.

Esempi commentati:
\begin{lstlisting}
# C/Java style (concettuale)
sum = 0
for (int i = 0; i < n; i++) {
    if (arr[i] % 2 == 0) continue;
    sum += arr[i];
}

# Python idiomatico
total = 0
for x in arr:
    if x % 2 == 0:
        continue
    total += x

# Python compatto: solo dispari
total = sum(x for x in arr if x % 2 == 1)

# for-else: cerca elemento; se non trovato, esegui fallback
target = 42
for x in arr:
    if x == target:
        print("trovato")
        break
else:
    print("non trovato")
\end{lstlisting}
\begin{tcolorbox}[title=Spiegazione del codice]
- \textbf{Indice vs elemento}: il primo snippet mostra stile basato su indice; in Python si preferisce iterare su elementi (`for x in arr`).  
- \textbf{Filtri}: usare `continue` per saltare i pari; l'alternativa compatta usa generator expression in `sum(...)`.  
- \textbf{for-else}: il blocco `else` si esegue solo se il ciclo non ha usato `break` (elemento non trovato); utile per ricerca con fallback.  
- \textbf{Stato}: `total` accumula; separare accumulo dalla logica di decisione semplifica i test.
\end{tcolorbox}
\end{tcolorbox}

\begin{tcolorbox}[title=Idiomi utili e anti-pattern]
Le \textbf{guard clauses} sono un pattern elegante per ridurre l'annidamento dei condizionali. Invece di nidificare blocchi if/else profondamente, è possibile controllare le precondizioni in anticipo e tornare o sollevare eccezioni subito se non sono soddisfatte. Questo rende il codice più leggibile e facile da seguire.

Quando si implementano \textbf{validazioni}, è importante definire predicati chiari e leggibili. Evitare condizioni composte troppo complicate; se necessario, estrarre la logica in funzioni ausiliarie con nomi espliciti che comunichino l'intento.

Per le operazioni di \textbf{accumulazione}, Python offre funzioni built-in come `sum`, `any` e `all`, nonché il modulo `itertools` che forniscono soluzioni ottimizzate ed espressive. Usare queste al posto di loop manuali non solo è più idiomatico, ma spesso più efficiente.

Infine, è importante essere consapevoli degli \textbf{anti-pattern}: usare loop con indice+lookup quando si potrebbe iterare direttamente su elementi, o permettere che l'annidamento dei condizionali diventi troppo profondo senza fattorizzare funzioni ausiliarie, rende il codice difficile da mantenere. Queste pratiche dovrebbero essere evitate attivamente durante lo sviluppo.
\end{tcolorbox}

\paragraph{Pattern raccomandati} Sostituire annidamenti profondi con return anticipati o funzioni ausiliarie. Separare la costruzione dei dati dalla loro validazione, riducendo la complessità cognitiva.
Consulta: \url{https://docs.python.org/3/tutorial/controlflow.html}.
