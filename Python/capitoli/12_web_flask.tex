% Modulo 12 — Web Development con Flask
\chapter{Web Development con Flask}

\section{Introduzione}
Creare applicazioni web leggere con Flask: routing, template e richieste.

La descrizione introduce il ciclo richiesta-risposta, la definizione di rotte e l'uso dei template per generare HTML dinamico. Discutiamo buone pratiche di struttura (\texttt{create\_app}, blueprint) e cenni a gestione errori e form.

Flask è adatto a API e piccoli siti, microservizi e prototipi veloci con una curva di apprendimento contenuta.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Definire route e gestire metodi HTTP.
  \item Usare template Jinja2.
  \item Gestire form e parametri.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Struttura di app e ciclo richiesta]
L'uso della \textbf{app factory} (pattern \texttt{create\_app}) e dei blueprint è essenziale per applicazioni Flask non banali. Questo pattern consente di creare istanze separate di app per test e configurazioni diverse, e permette di modularizzare il codice in blueprint che raggruppano rotte correlate.

Comprendere i \textbf{context di applicazione e richiesta} è cruciale. Flask mantiene context thread-local per l'app e per la richiesta corrente, che consentono di accedere a dati globali senza passarli esplicitamente. Le variabili \texttt{g} e \texttt{session} permettono di archiviare dati per richiesta e per utente rispettivamente.

Il \textbf{routing} e i \textbf{metodi HTTP} sono il cuore di qualsiasi app web. Definire rotte che rispondono ai metodi HTTP appropriati (GET, POST, PUT, DELETE) e implementare una \textbf{validazione input} robusta è essenziale per la sicurezza e l'affidabilità.

L'uso di \textbf{template Jinja2} consente una chiara separazione tra presentazione e logica. Anziché concatenare HTML in Python, Jinja2 permette di definire template che ricevono dati e generano HTML dinamico.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{App base}
\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/")
def home():
    return "Hello Flask"

# avvia: flask --app app run
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \texttt{Flask(\_\_name\_\_)} crea l'app; \texttt{@app.route} definisce una route.
- Separare creazione app in factory (\texttt{create\_app}) per testing/configurazioni.
- Avviare con CLI \texttt{flask}; gestire segreti/config via variabili d'ambiente.
\end{tcolorbox}

\subsection{Parametri}
\begin{lstlisting}
from flask import request
@app.route("/echo")
def echo():
    msg = request.args.get("msg", "")
    return f"{msg}"
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- I parametri query si leggono da \texttt{request.args}; validare e sanificare input.
- Usare metodi HTTP corretti (GET per lettura, POST per invio dati).
- Gestire errori e codici di risposta appropriati (400/404/500).
\end{tcolorbox}

\subsection{Template}
\begin{lstlisting}
from flask import render_template
@app.route("/page")
def page():
    return render_template("page.html", title="Demo")
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \texttt{render\_template} usa Jinja2: separa presentazione dalla logica.
- Passare variabili al template e evitare concatenazioni manuali di HTML.
- Proteggere da XSS/CSRF; usare form e token sicuri.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
- Micro API per servizi interni.
- Piccoli siti con template dinamici.
- Dashboard leggere con form e validazioni.
- Prototipi rapidi di microservizi.
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Crea una route \texttt{/hello/<name>}.
  \item Gestisci un form POST e visualizza i dati.
  \item Servi un template con una lista iterata.
  \item Aggiungi gestione errori 404 custom.
  \item Separa app in \texttt{create\_app()} e blueprint.
\end{enumerate}

\section{Riepilogo}
Hai definito una piccola app Flask con rotte e template.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
- Microservizi e API interne.
- Siti dinamici con template.
- Dashboard leggere con form e validazioni.
- Prototipi rapidi integrati con DB/servizi.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
Il pattern \textbf{app factory} consente di creare l'app con funzioni dedicate, permettendo diverse configurazioni per test e produzione. Questo migliora la testabilità e la flessibilità dell'applicazione.

I \textbf{blueprint} sono un meccanismo per modularizzare viste e API, consentendo di raggruppare rotte correlate e isolare dipendenze. Questo rende le applicazioni più scalabili e manutenibili.

La gestione del \textbf{contesto di richiesta} è fondamentale in Flask. L'oggetto \verb|request| contiene i dati della richiesta HTTP, mentre \verb|g| serve per archiviare dati per richiesta e \verb|session| per dati persistenti tra richieste. È importante gestire questi in modo sicuro e evitare variabili globali che rendono il codice difficile da testare.

Quando si usano \textbf{template Jinja2}, è importante separare chiaramente la presentazione dalla logica. Inoltre, Jinja2 fornisce escape automatico di default per proteggere da XSS; tuttavia, è necessario implementare protezioni CSRF e validare l'input lato server.

Il \textbf{testing} di applicazioni Flask dovrebbe usare il test client fornito da Flask per verificare percorsi, metodi HTTP e stati. Integrare test nel processo CI garantisce che regressioni siano rilevate immediatamente.
\end{tcolorbox}

\paragraph{Deployment} Differenziare configurazione sviluppo/produzione, log, e gestione errori; preferire server WSGI adeguati e reverse proxy.
Consulta: \url{https://flask.palletsprojects.com/}.
