% Modulo 09 — Decoratori, Iteratori e Generatori
\chapter{Decoratori, Iteratori e Generatori}

\section{Introduzione}
Pattern avanzati per estendere comportamento di funzioni e gestire serie di dati.

Questa descrizione mostra come comporre comportamenti senza modificare il codice esistente (decoratori), come iterare su flussi in modo lazy (iteratori) e generare sequenze efficienti (generatori) riducendo uso di memoria.

Questi strumenti rendono il codice più espressivo e performante in logging, validazione, pipeline di dati e elaborazioni su grandi volumi.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Scrivere decoratori semplici.
  \item Implementare iteratori personalizzati.
  \item Usare generatori con \texttt{yield} e comprensioni generator.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Decoratori]
\texttt{@decorator} avvolge funzioni per aggiungere comportamento.
\end{tcolorbox}

\begin{tcolorbox}[title=Iterazione e valutazione lazy]
Gli \textbf{iteratori} sono oggetti che consumano elementi uno alla volta, il che riduce significativamente l'uso di memoria rispetto a materialisare l'intera collezione in una lista. Questo è particolarmente importante quando si lavora con grandi volumi di dati o flussi potenzialmente infiniti.

I \textbf{generatori con yield} forniscono un modo elegante per modellare pipeline e flussi di dati. Anziché construire e immagazzinare una lista completa, i generatori producono valori su richiesta, permettendo programmi memory-efficient e composabili.

La composizione di trasformazioni con \textbf{generator expression e itertools} è un pattern fondamentale per pipeline dati complesse. Generator expression (scritte come `(expr for item in collection)`) e funzioni da `itertools` consentono di concatenare operazioni di filtraggio, trasformazione e aggregazione in modo dichiarativo e efficiente.

Un concetto importante in questo contesto è \textbf{backpressure}: il principio che il produttore dovrebbe produrre solo quanto richiesto dal consumatore. I generatori rispettano naturalmente questo principio, calcolando il valore successivo solo quando richiesto.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{Decoratore}
\begin{lstlisting}
def log_calls(fn):
    def wrapper(*a, **k):
        print("chiamata", fn.__name__)
        return fn(*a, **k)
    return wrapper

@log_calls
def hello():
    print("hello")
hello()
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- Il decoratore \texttt{log\_calls} avvolge la funzione per eseguire codice prima/dopo.
- Usare \verb|functools.wraps| su \texttt{wrapper} per preservare metadati (nome, docstring).
- I decoratori sono ottimi per logging, validazione, caching e autorizzazioni.
\end{tcolorbox}

\subsubsection{Flusso di esecuzione del decoratore}

Ecco come funziona un decoratore visivamente:

\begin{center}
\begin{tikzpicture}[
    node distance=1.2cm,
    box/.style={rectangle, draw, thick, minimum width=3.5cm, minimum height=0.8cm, align=center, font=\small},
    func/.style={box, fill=blue!20},
    deco/.style={box, fill=orange!20},
    code/.style={box, fill=green!15},
    arrow/.style={->, thick, >=stealth}
]
    % Definizione
    \node[above, font=\small\bfseries] at (2,6.5) {1. Definizione};
    \node[deco] (def_deco) at (0,6) {\texttt{def log\_calls(fn):}};
    \node[code] (def_wrap) at (0,5) {\texttt{def wrapper(*a, **k):}};
    \node[code] (def_body) at (0,4) {... codice decoratore ...};
    \node[code] (def_ret) at (0,3) {\texttt{return wrapper}};

    \node[func] (def_func) at (4.5,5) {@log\_calls\\def hello():};
    \node[code] (def_fbody) at (4.5,4) {print("hello")};

    \draw[arrow, blue] (def_func) -- (def_deco) node[midway, above, font=\footnotesize] {decorato};

    % Chiamata
    \node[above, font=\small\bfseries] at (2,1.5) {2. Chiamata: hello()};

    \node[deco] (call_wrapper) at (0,1) {wrapper(*a, **k)};
    \node[code] (call_pre) at (0,0) {print("chiamata hello")};
    \node[func] (call_orig) at (0,-1) {fn(*a, **k)};
    \node[code] (call_hello) at (0,-2) {print("hello")};
    \node[code] (call_post) at (0,-3) {return risultato};

    \draw[arrow] (call_wrapper) -- (call_pre);
    \draw[arrow] (call_pre) -- (call_orig);
    \draw[arrow] (call_orig) -- (call_hello);
    \draw[arrow] (call_hello) -- (call_post);

    % Output
    \node[box, fill=yellow!20, text width=4cm, right=1cm of call_pre] (output) {
        \textbf{Output:}\\
        \texttt{chiamata hello}\\
        \texttt{hello}
    };

    % Spiegazione visiva
    \node[below, font=\footnotesize, align=left, text width=7cm] at (2,-4) {
        Il decoratore \textbf{avvolge} la funzione originale:\\
        wrapper $\rightarrow$ codice pre $\rightarrow$ funzione originale $\rightarrow$ codice post
    };
\end{tikzpicture}
\end{center}

\subsubsection{Decorator con parametri}

\begin{lstlisting}
def repeat(n):
    def decorator(fn):
        def wrapper(*a, **k):
            for _ in range(n):
                result = fn(*a, **k)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Ciao {name}!")

greet("Mario")  # Stampa 3 volte
\end{lstlisting}

\begin{center}
\begin{tikzpicture}[
    node distance=0.8cm,
    box/.style={rectangle, draw, thick, minimum width=4cm, minimum height=0.7cm, align=center, font=\footnotesize},
    level1/.style={box, fill=red!15},
    level2/.style={box, fill=orange!15},
    level3/.style={box, fill=yellow!15},
    func/.style={box, fill=blue!15},
    arrow/.style={->, thick, >=stealth}
]
    \node[level1] (repeat) at (0,4) {repeat(3) — ritorna decorator};
    \node[level2] (decorator) at (0,3) {decorator(greet) — ritorna wrapper};
    \node[level3] (wrapper) at (0,2) {wrapper(*a, **k) — esegue loop};
    \node[func] (greet) at (0,1) {greet(name) — 3 volte};

    \draw[arrow] (repeat) -- (decorator);
    \draw[arrow] (decorator) -- (wrapper);
    \draw[arrow] (wrapper) -- (greet);

    \node[right=0.5cm of repeat, font=\footnotesize, align=left] {Livello 1: Parametri decorator};
    \node[right=0.5cm of decorator, font=\footnotesize, align=left] {Livello 2: Decorator vero};
    \node[right=0.5cm of wrapper, font=\footnotesize, align=left] {Livello 3: Wrapper};
    \node[right=0.5cm of greet, font=\footnotesize, align=left] {Funzione originale};
\end{tikzpicture}
\end{center}

\begin{nota}
I decorator con parametri sono funzioni che ritornano decorator. La sintassi \texttt{@repeat(3)} chiama prima \texttt{repeat(3)}, che ritorna un decorator, che poi viene applicato a \texttt{greet}.
\end{nota}

\subsection{Iteratore}
\begin{lstlisting}
class Count:
    def __init__(self, n):
        self.n = n; self.i = 0
    def __iter__(self): return self
    def __next__(self):
        if self.i >= self.n: raise StopIteration
        v = self.i; self.i += 1; return v
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- Implementa il protocollo iteratore con \verb|__iter__| e \verb|__next__|.
- Solleva \texttt{StopIteration} per segnalare fine; consuma elemento per chiamata.
- Preferire iteratori/generatori per flussi potenzialmente grandi o infiniti.
\end{tcolorbox}

\subsection{Generatore}
\begin{lstlisting}
def gen(n):
    for i in range(n):
        yield i
print(list(gen(3)))
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- I generatori producono valori lazily con \texttt{yield}; consumati da \texttt{for} o \texttt{list(...)}.
- Consentono pipeline efficienti e gestione di risorse con \verb|try/finally|.
- Comporre trasformazioni con generator expression e moduli come \texttt{itertools}.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
- Logging/monitoring trasparente con decoratori.
- Streaming di file/HTTP con trasformazioni lazy.
- Validazione/autorità dei parametri senza cambiare funzioni originali.
- Rate limiting e retry come decoratori riutilizzabili.
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Crea un decoratore che misura il tempo di esecuzione.
  \item Implementa un iteratore sui numeri pari fino a N.
  \item Scrivi un generatore di Fibonacci.
  \item Usa una generator expression per filtrare valori.
  \item Implementa un decoratore che valida tipi di argomenti.
\end{enumerate}

\section{Riepilogo}
Hai esplorato decoratori, iteratori e generatori in pratica.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
- Strumentazione trasparente (logging, timing) con decoratori.
- Pipeline dati lazy e streaming efficiente.
- Validazioni, autorizzazioni e caching via decoratori.
- Generator expression per filtri e trasformazioni.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
Il \textbf{protocollo iteratore} è implementato attraverso i metodi \verb|__iter__| (che ritorna self o un iteratore) e \verb|__next__| (che ritorna il valore successivo o solleva StopIteration). Comprendere questo protocollo consente di creare oggetti custom iterabili che si integrano perfettamente con il resto dell'ecosistema Python.

I \textbf{generatori} sono un'applicazione potente del protocollo iteratore, che permette di usare \verb|yield| per pipeline lazy e flussi di dati efficienti. Un aspetto spesso dimenticato è la gestione della cleanup: è possibile usare \verb|finally| dentro un generatore per eseguire codice di pulizia quando il generatore termina o viene chiuso.

I \textbf{decoratori} sono un meccanismo per incapsulare cross-cutting concerns come logging, caching e autorizzazione senza modificare il codice originale. È importante usare \verb|functools.wraps| per preservare i metadati della funzione originale (nome, docstring) nel wrapper.

Per \textbf{caching} di risultati, \verb|functools.lru_cache| è uno strumento essenziale per ottimizzare funzioni pure ricorsive o computazionalmente costose. È importante definire attentamente le dimensioni della cache e considerare politiche di invalidazione quando appropriato.
\end{tcolorbox}

\paragraph{Pattern} Combinare generatori e decoratori per pipeline efficienti e componibili; preferire iterazione lazy per dataset grandi.
Consulta: \url{https://docs.python.org/3/faq/programming.html#what-are-decorators}.
