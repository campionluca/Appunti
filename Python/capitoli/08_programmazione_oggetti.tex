% Modulo 08 — Programmazione a Oggetti (OOP)
\chapter{Programmazione a Oggetti (OOP)}

\section{Introduzione}
Classi, oggetti, ereditarietà, incapsulamento e polimorfismo in Python.

La descrizione chiarisce quando introdurre classi rispetto a funzioni e strutture dati, come modellare entità e relazioni e come usare metodi speciali per integrare con l'ecosistema Python. Accenniamo anche a \texttt{dataclasses} come alternativa leggera.

Applicare correttamente OOP aiuta a organizzare sistemi complessi, isolare responsabilità e facilitare evoluzione e test.

\section{Obiettivi di Apprendimento}
\begin{itemize}
  \item Definire classi e metodi.
  \item Usare ereditarietà e overriding.
  \item Applicare proprietà e metodi speciali.
\end{itemize}

\section{Concetti Fondamentali}
\begin{tcolorbox}[title=Metodi speciali]
\texttt{\_\_init\_\_}, \texttt{\_\_repr\_\_}, \texttt{\_\_str\_\_}, \texttt{\_\_len\_\_}, ecc.
\end{tcolorbox}

\begin{tcolorbox}[title=Principi di design OOP]
Il \textbf{Single Responsibility Principle (SRP)} stabilisce che ogni classe deve avere una responsabilità chiara e ben definita, facilitando la comprensione e la manutenzione del codice.

La \textbf{composizione dovrebbe essere preferita all'ereditarietà} quando si progettano relazioni tra classi, poiché offre maggiore flessibilità e riduce l'accoppiamento. L'ereditarietà va riservata ai casi in cui esiste una vera relazione "è un" tra le classi.

Il \textbf{Liskov Substitution Principle (LSP)} richiede che le sottoclassi rispettino sempre i contratti della classe base, garantendo che possano essere usate in modo intercambiabile senza alterare la correttezza del programma.

L'\textbf{incapsulamento} è fondamentale: mantenere lo stato interno privato ed esporre solo metodi pubblici chiari che rispettano gli invarianti della classe protegge da modifiche inconsistenti e semplifica l'uso dell'API.

Per oggetti-dati semplici, le \texttt{dataclasses} riducono significativamente il boilerplate, generando automaticamente metodi come \verb|__init__|, \verb|__repr__| e \verb|__eq__|.
\end{tcolorbox}

\section{Esempi Pratici}
\subsection{Classe base}
\begin{lstlisting}
class Punto:
    def __init__(self, x, y):
        self.x = x; self.y = y
    def __repr__(self):
        return f"Punto({self.x}, {self.y})"
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \texttt{\_\_init\_\_} inizializza lo stato; \texttt{\_\_repr\_\_} fornisce una rappresentazione utile al debug.
- Evitare di mescolare responsabilità: la classe modella un punto, non gestisce I/O.
- Per oggetti-dato, considerare \texttt{dataclasses} per ridurre boilerplate.
\end{tcolorbox}

\subsection{Ereditarietà}
\begin{lstlisting}
class Veicolo:
    def muovi(self):
        print("Mi muovo")

class Auto(Veicolo):
    def muovi(self):
        print("Guido")
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \texttt{Auto} eredita da \texttt{Veicolo} e fa override di \texttt{muovi}.
- Applicare LSP: la sottoclasse deve rispettare l'interfaccia/contratto della base.
- Preferire composizione quando l'ereditarietà non rappresenta una relazione "è un".
\end{tcolorbox}

\subsection{Proprietà}
\begin{lstlisting}
class User:
    def __init__(self, name):
        self._name = name
    @property
    def name(self):
        return self._name
\end{lstlisting}

\begin{tcolorbox}[title=Spiegazione]
- \verb|@property| espone un attributo calcolato/validato mantenendo un'interfaccia pulita.
- L'underscore (\texttt{\_name}) indica convenzione di attributo "interno"; non è enforced.
- Aggiungere setter solo se necessario per invarianti; altrimenti mantenere immutabilità.
\end{tcolorbox}

\begin{tcolorbox}[title=Casi d'uso]
La programmazione a oggetti è particolarmente efficace per modellare entità di dominio come \texttt{Ordine}, \texttt{Prodotto} e \texttt{Utente}, permettendo di rappresentare la logica di business in modo naturale e intuitivo attraverso classi che incapsulano dati e comportamenti.

I pattern come Adapter e Strategy sfruttano il polimorfismo per variare il comportamento in runtime, consentendo di selezionare dinamicamente algoritmi o implementazioni diverse senza modificare il codice cliente.

L'uso di Value Object immutabili migliora la sicurezza e la testabilità del codice, eliminando effetti collaterali indesiderati e semplificando il ragionamento sul flusso dei dati.

Le astrazioni per driver di database o API permettono di definire interfacce stabili con implementazioni intercambiabili, facilitando testing con mock e permettendo di sostituire provider esterni senza impatto sul resto del sistema.
\end{tcolorbox}

\section{Esercizi}
\begin{enumerate}
  \item Implementa una classe \texttt{Rettangolo} con area e perimetro.
  \item Crea gerarchia \texttt{Animale} $\rightarrow$ \texttt{Cane}/\texttt{Gatto} con override.
  \item Usa \texttt{@property} per validare attributi.
  \item Implementa un contenitore con metodi speciali di sequenza.
  \item Aggiungi un metodo di classe per creare da stringa.
\end{enumerate}

\section{Riepilogo}
Hai applicato i concetti chiave di OOP in Python.

\section{Contesto e Applicazioni}
\begin{tcolorbox}[title=Contesto e Applicazioni]
La programmazione orientata agli oggetti trova applicazione naturale nella modellazione di domini complessi, dove entità come ordini, utenti e prodotti vengono rappresentate come classi che incapsulano sia dati che comportamenti, rendendo il codice più vicino al problema reale.

Nello sviluppo di interfacce utente, l'OOP permette di creare componenti riutilizzabili basati su pattern consolidati, favorendo la composizione di elementi UI complessi da blocchi più semplici e facilitando la manutenzione.

I sistemi estensibili beneficiano particolarmente dell'OOP attraverso interfacce e astrazioni ben definite, che permettono l'implementazione di plugin e estensioni senza modificare il codice esistente, seguendo il principio Open/Closed.

Dal punto di vista del testing, il polimorfismo e il mocking sono strumenti essenziali: la capacità di sostituire implementazioni concrete con mock objects permette di testare comportamenti in isolamento, migliorando qualità e affidabilità del software.
\end{tcolorbox}

\section{Approfondimenti}
\begin{tcolorbox}[title=Spiegazioni dettagliate]
La scelta tra \textbf{composizione ed ereditarietà} è una decisione di design fondamentale. La composizione dovrebbe essere privilegiata per la sua flessibilità, mentre l'ereditarietà va riservata ai casi in cui esiste una vera relazione "è un" tra le classi.

Le \textbf{dataclass} sono uno strumento potente per ridurre il boilerplate nelle classi di dati, generando automaticamente metodi comuni. L'immutabilità può essere enforced con il parametro \verb|frozen=True|, creando Value Objects sicuri.

L'uso di \textbf{proprietà e incapsulamento} con il decoratore \verb|@property| permette di esporre interfacce pulite mantenendo il controllo sugli accessi agli attributi. È importante validare gli invarianti della classe in getter e setter per garantire consistenza.

I \textbf{metodi speciali (dunder methods)} come \verb|__repr__|, \verb|__eq__| e \verb|__hash__| dovrebbero essere implementati in base all'identità del dominio: oggetti che rappresentano la stessa entità devono essere uguali, e oggetti usabili come chiavi di dizionario devono essere hashable e immutabili.

L'uso di \textbf{type hints} agevola strumenti di analisi statica e migliora la documentazione del codice. È essenziale mantenere le annotazioni aggiornate e coerenti con l'implementazione per evitare confusione.
\end{tcolorbox}

\paragraph{Progettazione} Definire responsabilità piccole e coese, evitare classi “tuttofare”. Integrare test di unità per gli invarianti principali.
Consulta: \url{https://docs.python.org/3/tutorial/classes.html}.
