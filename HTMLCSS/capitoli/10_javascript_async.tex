\chapter{Async/Await e Fetch API}
\label{cap:javascript_async}

\section{Cos'è l'Asincronia}

Il codice asincrono permette al browser di continuare a eseguire altre operazioni mentre attende il completamento di operazioni lunghe (richieste di rete, lettura file, timer).

\begin{nota}
JavaScript è single-threaded. L'asincronia non crea nuovi thread, ma usa event loop e callback per eseguire operazioni senza bloccare il thread principale.
\end{nota}

\section{Promises}

Una Promise rappresenta il risultato futuro di un'operazione asincrona: riuscita (resolved) o fallita (rejected).

\subsection{Creare Promise}

\begin{lstlisting}[language=JavaScript]
// Creare una Promise
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    const success = true;
    if (success) {
      resolve("Operazione completata!");
    } else {
      reject("Operazione fallita!");
    }
  }, 2000);
});

// Usare la Promise con .then() e .catch()
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error));
\end{lstlisting}

\subsection{Concatenare Promise (Promise Chains)}

\begin{lstlisting}[language=JavaScript]
// Promise chain: ogni .then() ritorna una nuova Promise
fetch("/api/users/1")
  .then(response => response.json())
  .then(user => {
    console.log("Utente:", user.name);
    return fetch(`/api/posts/${user.id}`);
  })
  .then(response => response.json())
  .then(posts => console.log("Post:", posts))
  .catch(error => console.error("Errore:", error));
\end{lstlisting}

\begin{attenzione}
Se dimentichi \texttt{return} in un .then(), la Promise successiva riceverà \texttt{undefined}. Sempre ritornare il valore/Promise.
\end{attenzione}

\subsection{Promise.all() e Promise.race()}

\begin{lstlisting}[language=JavaScript]
// Promise.all: attendi che TUTTE le Promise si risolvano
Promise.all([
  fetch("/api/users").then(r => r.json()),
  fetch("/api/posts").then(r => r.json()),
  fetch("/api/comments").then(r => r.json())
])
  .then(([users, posts, comments]) => {
    console.log("Tutti i dati caricati:", users, posts, comments);
  })
  .catch(error => console.error("Errore:", error));

// Promise.race: ritorna il risultato della prima Promise risolta
Promise.race([
  fetch("/api/slow").then(r => r.json()),
  new Promise((_, reject) => setTimeout(() => reject("Timeout"), 5000))
])
  .then(result => console.log("Primo risultato:", result))
  .catch(error => console.error("Errore:", error));
\end{lstlisting}

\section{Async e Await}

\subsection{Sintassi async/await}

Async/await rende il codice asincrono più leggibile, come se fosse sincrono.

\begin{lstlisting}[language=JavaScript]
// Funzione asincrona
async function fetchUser(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    const user = await response.json();
    console.log("Utente:", user);
    return user;
  } catch (error) {
    console.error("Errore:", error);
  }
}

// Chiamare la funzione asincrona
fetchUser(1);
\end{lstlisting}

\begin{nota}
\texttt{await} pausa l'esecuzione della funzione finché la Promise non si risolve. \texttt{await} funziona solo dentro una funzione \texttt{async}.
\end{nota}

\subsection{Error Handling con try/catch}

\begin{lstlisting}[language=JavaScript]
async function loadData() {
  try {
    // Codice che potrebbe fallire
    const response = await fetch("/api/data");
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    const data = await response.json();
    console.log("Dati:", data);
    return data;
  } catch (error) {
    console.error("Errore durante il caricamento:", error.message);
    // Gestire l'errore (mostrare messaggio, riprovare, etc.)
  } finally {
    console.log("Operazione completata (successo o fallimento)");
  }
}
\end{lstlisting}

\subsection{Async con funzioni freccia}

\begin{lstlisting}[language=JavaScript]
// Funzione freccia asincrona
const fetchData = async () => {
  const response = await fetch("/api/data");
  return await response.json();
};

// Usare il risultato
fetchData().then(data => console.log(data));

// O usare await nella funzione padre
async function main() {
  const data = await fetchData();
  console.log(data);
}
\end{lstlisting}

\subsection{Eseguire Promise in parallelo}

\begin{lstlisting}[language=JavaScript]
// SBAGLIATO: sequenziale (troppo lento)
async function loadDataSequential() {
  const user = await fetch("/api/user").then(r => r.json());
  const posts = await fetch("/api/posts").then(r => r.json());
  const comments = await fetch("/api/comments").then(r => r.json());
  return { user, posts, comments };
}

// CORRETTO: parallelo (più veloce)
async function loadDataParallel() {
  const [user, posts, comments] = await Promise.all([
    fetch("/api/user").then(r => r.json()),
    fetch("/api/posts").then(r => r.json()),
    fetch("/api/comments").then(r => r.json())
  ]);
  return { user, posts, comments };
}
\end{lstlisting}

\section{Fetch API}

\subsection{GET Request}

\begin{lstlisting}[language=JavaScript]
// Forma semplice
const data = await fetch("/api/users/1")
  .then(r => r.json());

// Forma completa con headers
const response = await fetch("https://api.example.com/users", {
  method: "GET",
  headers: {
    "Content-Type": "application/json",
    "Authorization": "Bearer token123"
  }
});

if (!response.ok) {
  throw new Error(`HTTP ${response.status}`);
}

const data = await response.json();
console.log(data);
\end{lstlisting}

\subsection{POST Request}

\begin{lstlisting}[language=JavaScript]
async function createUser(user) {
  const response = await fetch("/api/users", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      name: user.name,
      email: user.email,
      age: user.age
    })
  });

  if (!response.ok) {
    throw new Error("Errore nella creazione dell'utente");
  }

  const newUser = await response.json();
  return newUser;
}

// Usare la funzione
createUser({ name: "Marco", email: "marco@example.com", age: 25 })
  .then(user => console.log("Utente creato:", user))
  .catch(error => console.error(error));
\end{lstlisting}

\subsection{PUT e DELETE Request}

\begin{lstlisting}[language=JavaScript]
// PUT: Aggiornare risorsa
async function updateUser(userId, updates) {
  const response = await fetch(`/api/users/${userId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(updates)
  });
  return await response.json();
}

// DELETE: Eliminare risorsa
async function deleteUser(userId) {
  const response = await fetch(`/api/users/${userId}`, {
    method: "DELETE"
  });
  if (!response.ok) {
    throw new Error("Errore nell'eliminazione");
  }
  return response.status === 204 ? null : response.json();
}

// Usare
updateUser(1, { name: "Marco Rossi", age: 26 });
deleteUser(1);
\end{lstlisting}

\begin{attenzione}
Ricorda di controllare \texttt{response.ok} dopo fetch. Una risposta con status 404 non genera automaticamente un'eccezione; devi controllare manualmente!
\end{attenzione}

\subsection{Gestire JSON e FormData}

\begin{lstlisting}[language=JavaScript]
// Inviare JSON
async function sendJSON() {
  const response = await fetch("/api/data", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message: "Ciao" })
  });
  return response.json();
}

// Inviare FormData (file upload)
async function uploadFile(file) {
  const formData = new FormData();
  formData.append("file", file);
  formData.append("title", "Mio file");

  const response = await fetch("/api/upload", {
    method: "POST",
    body: formData
    // NON settare Content-Type, il browser lo farà
  });
  return response.json();
}

// Usare
const fileInput = document.querySelector("input[type='file']");
fileInput.addEventListener("change", (e) => {
  uploadFile(e.target.files[0]);
});
\end{lstlisting}

\section{Esercizio Pratico: Weather App}

\subsection{Specifica}

Crea una weather app che:
- Accetta una città in input
- Fetcha dati meteo da API pubblica (OpenWeatherMap o JSONPlaceholder)
- Mostra temperatura, descrizione, umidità
- Salva le ultime 5 città cercate
- Permette di ricercare città con debounce

\subsection{HTML/CSS/JavaScript}

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weather App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .container {
      background: white;
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    }

    h1 {
      color: #333;
      text-align: center;
      margin-top: 0;
    }

    .search-box {
      margin-bottom: 30px;
    }

    .search-box input {
      width: 100%;
      padding: 12px;
      font-size: 16px;
      border: 2px solid #ddd;
      border-radius: 8px;
      box-sizing: border-box;
      transition: border-color 0.3s;
    }

    .search-box input:focus {
      outline: none;
      border-color: #667eea;
    }

    .weather-info {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: none;
    }

    .weather-info.show {
      display: block;
    }

    .temp {
      font-size: 48px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .description {
      font-size: 18px;
      margin-bottom: 15px;
      text-transform: capitalize;
    }

    .details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      font-size: 14px;
    }

    .detail-item {
      background: rgba(255,255,255,0.2);
      padding: 10px;
      border-radius: 4px;
    }

    .error {
      background: #fee;
      color: #c00;
      padding: 15px;
      border-radius: 8px;
      display: none;
      margin-bottom: 20px;
    }

    .error.show {
      display: block;
    }

    .history {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #ddd;
    }

    .history h3 {
      margin-top: 0;
      color: #333;
    }

    .history-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .history-item {
      background: #f0f0f0;
      padding: 8px 12px;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 14px;
    }

    .history-item:hover {
      background: #667eea;
      color: white;
    }

    .loading {
      text-align: center;
      color: #667eea;
      display: none;
      margin: 20px 0;
    }

    .loading.show {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Meteo App</h1>

    <div class="search-box">
      <input
        type="text"
        id="city-input"
        placeholder="Scrivi il nome di una città..."
        autocomplete="off"
      >
    </div>

    <div class="loading" id="loading">Caricamento...</div>

    <div class="error" id="error-message"></div>

    <div class="weather-info" id="weather-info">
      <div class="temp" id="temp"></div>
      <div class="description" id="description"></div>
      <div class="details">
        <div class="detail-item">
          <strong>Umidità:</strong> <span id="humidity"></span>%
        </div>
        <div class="detail-item">
          <strong>Vento:</strong> <span id="wind"></span> km/h
        </div>
        <div class="detail-item">
          <strong>Sensazione:</strong> <span id="feels"></span>$^\circ$C
        </div>
        <div class="detail-item">
          <strong>Città:</strong> <span id="city-name"></span>
        </div>
      </div>
    </div>

    <div class="history" id="history-section" style="display: none;">
      <h3>Ultime ricerche</h3>
      <div class="history-list" id="history-list"></div>
    </div>
  </div>

  <script>
    class WeatherApp {
      constructor() {
        this.apiKey = "8b3e2f8f5c0c4b1a8d5e6f7g8h9i0j";
        this.history = JSON.parse(localStorage.getItem("weather-history")) || [];
        this.debounceTimer = null;
        this.init();
      }

      init() {
        const input = document.getElementById("city-input");
        input.addEventListener("input", (e) => this.handleSearch(e.target.value));
        this.renderHistory();
      }

      handleSearch(query) {
        clearTimeout(this.debounceTimer);

        if (!query) return;

        this.debounceTimer = setTimeout(() => {
          this.searchCity(query);
        }, 500);
      }

      async searchCity(city) {
        try {
          this.showLoading(true);
          this.hideError();

          // Usare API pubblica (esempio con JSONPlaceholder mock)
          const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${this.apiKey}&units=metric&lang=it`
          );

          if (!response.ok) {
            if (response.status === 404) {
              throw new Error("Città non trovata");
            }
            throw new Error("Errore nel caricamento dei dati meteo");
          }

          const data = await response.json();
          this.displayWeather(data);
          this.addToHistory(city);
        } catch (error) {
          this.showError(error.message);
        } finally {
          this.showLoading(false);
        }
      }

      displayWeather(data) {
        const info = document.getElementById("weather-info");
        document.getElementById("temp").textContent = Math.round(data.main.temp) + "$^\circ$C";
        document.getElementById("description").textContent = data.weather[0].description;
        document.getElementById("humidity").textContent = data.main.humidity;
        document.getElementById("wind").textContent = Math.round(data.wind.speed * 3.6);
        document.getElementById("feels").textContent = Math.round(data.main.feels_like);
        document.getElementById("city-name").textContent = data.name + ", " + data.sys.country;

        info.classList.add("show");
      }

      addToHistory(city) {
        this.history = this.history.filter(c => c.toLowerCase() !== city.toLowerCase());
        this.history.unshift(city);
        this.history = this.history.slice(0, 5);
        localStorage.setItem("weather-history", JSON.stringify(this.history));
        this.renderHistory();
      }

      renderHistory() {
        if (this.history.length === 0) {
          document.getElementById("history-section").style.display = "none";
          return;
        }

        document.getElementById("history-section").style.display = "block";
        const list = document.getElementById("history-list");
        list.innerHTML = "";

        this.history.forEach(city => {
          const item = document.createElement("div");
          item.className = "history-item";
          item.textContent = city;
          item.onclick = () => this.searchCity(city);
          list.appendChild(item);
        });
      }

      showLoading(show) {
        document.getElementById("loading").classList.toggle("show", show);
      }

      showError(message) {
        const error = document.getElementById("error-message");
        error.textContent = message;
        error.classList.add("show");
      }

      hideError() {
        document.getElementById("error-message").classList.remove("show");
      }
    }

    new WeatherApp();
  </script>
</body>
</html>
\end{lstlisting}

\begin{nota}
Nota: l'API key è fittizia. Registrati su openweathermap.org per una vera API key.
\end{nota}

\section{Esercizi}

\subsection{Esercizio 1 (Intermedio)}
Fetch una lista di post da JSONPlaceholder (/posts) e mostra titolo e corpo in una lista.

\subsection{Esercizio 2 (Intermedio)}
Crea una funzione che fetcha 3 risorse diverse in parallelo e le mostra tutte.

\subsection{Esercizio 3 (Avanzato)}
Crea un form che invia dati POST a una API. Gestisci success e errori con try/catch.

\subsection{Esercizio 4 (Avanzato)}
Implementa un retry mechanism: se una fetch fallisce, ritenta fino a 3 volte prima di rinunciare.

\section{Riepilogo}

\begin{itemize}
  \item Promise rappresentano risultati futuri di operazioni asincrone
  \item .then() e .catch() per gestire Promise
  \item \texttt{async/await} è zucchero sintattico per Promise chains
  \item \texttt{await} pausa l'esecuzione finché Promise non si risolve
  \item \texttt{try/catch/finally} per error handling con async/await
  \item Fetch API con \texttt{fetch(url, options)} per richieste HTTP
  \item Controllare sempre \texttt{response.ok} dopo fetch
  \item \texttt{response.json()} per parsare JSON
  \item Combinare fetch con async/await per codice leggibile
  \item Usare \texttt{Promise.all()} per parallelizzare richieste
\end{itemize}
