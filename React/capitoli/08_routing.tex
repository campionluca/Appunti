% 08_routing.tex - React Router v6, Routes, Navigation, Protected Routes, Lazy Loading

\chapter{Routing con React Router}
\label{ch:routing}

\section{Introduzione al Routing in React}

Il routing è essenziale per creare applicazioni React multi-pagina (SPA - Single Page Application). React Router è la libreria standard per la gestione del routing in React, permettendo di navigare tra diverse "pagine" senza ricaricare il browser.

\subsection{Cos'è React Router}

React Router è una libreria che sincronizza l'UI con l'URL del browser, permettendo di:

\begin{itemize}
\item Creare applicazioni multi-pagina
\item Gestire la navigazione dichiarativa
\item Implementare route nidificate
\item Proteggere route con autenticazione
\item Implementare lazy loading per code splitting
\item Gestire parametri URL e query string
\end{itemize}

\subsection{Installazione}

\begin{lstlisting}[caption={Installazione di React Router}]
# Installazione con npm
npm install react-router-dom

# Installazione con yarn
yarn add react-router-dom

# Installazione con pnpm
pnpm add react-router-dom
\end{lstlisting}

\begin{tcolorbox}[title=React Router v6]
Questo capitolo si concentra su React Router v6, che introduce cambiamenti significativi rispetto alla v5. Le API sono più semplici e l'approccio è più dichiarativo.
\end{tcolorbox}

\section{Setup Iniziale}

\subsection{Struttura Base dell'Applicazione}

\begin{lstlisting}[caption={Setup iniziale con BrowserRouter}]
// main.jsx o index.jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
\end{lstlisting}

\subsection{Componente App con Routes}

\begin{lstlisting}[caption={App.jsx con routes di base}]
import { Routes, Route, Link } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Contact from './pages/Contact';
import NotFound from './pages/NotFound';

function App() {
  return (
    <div className="app">
      {/* Navigation */}
      <nav>
        <ul>
          <li><Link to="/">Home</Link></li>
          <li><Link to="/about">About</Link></li>
          <li><Link to="/contact">Contact</Link></li>
        </ul>
      </nav>

      {/* Routes */}
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
        <Route path="*" element={<NotFound />} />
      </Routes>
    </div>
  );
}

export default App;
\end{lstlisting}

\subsection{Componenti Pagina di Base}

\begin{lstlisting}[caption={Esempi di componenti pagina}]
// pages/Home.jsx
function Home() {
  return (
    <div>
      <h1>Home Page</h1>
      <p>Benvenuto nella home page!</p>
    </div>
  );
}

export default Home;

// pages/About.jsx
function About() {
  return (
    <div>
      <h1>About Page</h1>
      <p>Informazioni sull'applicazione</p>
    </div>
  );
}

export default About;

// pages/NotFound.jsx
import { Link } from 'react-router-dom';

function NotFound() {
  return (
    <div>
      <h1>404 - Pagina Non Trovata</h1>
      <p>La pagina che stai cercando non esiste.</p>
      <Link to="/">Torna alla Home</Link>
    </div>
  );
}

export default NotFound;
\end{lstlisting}

\section{Navigazione}

\subsection{Link Component}

Il componente \texttt{Link} è usato per creare link che non ricaricano la pagina.

\begin{lstlisting}[caption={Utilizzo del componente Link}]
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      {/* Link semplice */}
      <Link to="/">Home</Link>

      {/* Link con classi CSS */}
      <Link to="/about" className="nav-link">About</Link>

      {/* Link con inline style */}
      <Link to="/contact" style={{ color: 'blue' }}>Contact</Link>

      {/* Link con state (passa dati alla route) */}
      <Link to="/profile" state={{ from: 'navigation' }}>
        Profile
      </Link>
    </nav>
  );
}
\end{lstlisting}

\subsection{NavLink Component}

\texttt{NavLink} è una versione speciale di \texttt{Link} che sa quando è attivo.

\begin{lstlisting}[caption={NavLink per navigazione attiva}]
import { NavLink } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      {/* NavLink con classe attiva automatica */}
      <NavLink
        to="/"
        className={({ isActive }) => isActive ? 'active' : ''}
      >
        Home
      </NavLink>

      {/* NavLink con stile attivo */}
      <NavLink
        to="/about"
        style={({ isActive }) => ({
          color: isActive ? 'red' : 'blue',
          fontWeight: isActive ? 'bold' : 'normal'
        })}
      >
        About
      </NavLink>

      {/* NavLink con end (esatto match del path) */}
      <NavLink
        to="/"
        end
        className={({ isActive }) => isActive ? 'active' : ''}
      >
        Home (exact)
      </NavLink>
    </nav>
  );
}

// CSS
// .active {
//   color: red;
//   font-weight: bold;
//   border-bottom: 2px solid red;
// }
\end{lstlisting}

\subsection{Navigazione Programmatica}

Usare \texttt{useNavigate} per navigare da codice (es. dopo submit form).

\begin{lstlisting}[caption={useNavigate per navigazione programmatica}]
import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Simula login
    const success = await login(username, password);

    if (success) {
      // Naviga alla dashboard dopo login
      navigate('/dashboard');

      // Naviga con replace (non aggiunge alla history)
      // navigate('/dashboard', { replace: true });

      // Naviga passando state
      // navigate('/dashboard', { state: { user: userData } });
    }
  };

  // Torna indietro
  const goBack = () => {
    navigate(-1); // Come browser back button
  };

  // Vai avanti
  const goForward = () => {
    navigate(1);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* form fields */}
      <button type="submit">Login</button>
      <button type="button" onClick={goBack}>Indietro</button>
    </form>
  );
}
\end{lstlisting}

\section{Parametri URL}

\subsection{Route Parameters}

I parametri URL permettono di creare route dinamiche.

\begin{lstlisting}[caption={Route con parametri}]
import { Routes, Route } from 'react-router-dom';
import UserProfile from './pages/UserProfile';
import BlogPost from './pages/BlogPost';

function App() {
  return (
    <Routes>
      {/* Parametro singolo */}
      <Route path="/users/:userId" element={<UserProfile />} />

      {/* Parametri multipli */}
      <Route path="/blog/:category/:postId" element={<BlogPost />} />

      {/* Parametro opzionale (con ?) */}
      <Route path="/products/:id?" element={<Products />} />
    </Routes>
  );
}
\end{lstlisting}

\subsection{useParams Hook}

Accedere ai parametri URL con \texttt{useParams}.

\begin{lstlisting}[caption={Accesso ai parametri con useParams}]
import { useParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

function UserProfile() {
  const { userId } = useParams(); // Estrai parametro dall'URL
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        setUser(data);
      } catch (error) {
        console.error('Errore:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchUser();
  }, [userId]); // Ri-esegui quando userId cambia

  if (loading) return <div>Caricamento...</div>;
  if (!user) return <div>Utente non trovato</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
      <p>User ID: {userId}</p>
    </div>
  );
}
\end{lstlisting}

\subsection{Esempio: Blog con Parametri Multipli}

\begin{lstlisting}[caption={Blog post con categoria e ID}]
import { useParams, Link } from 'react-router-dom';

function BlogPost() {
  const { category, postId } = useParams();
  const [post, setPost] = useState(null);

  useEffect(() => {
    // Fetch post based on category and postId
    fetch(`/api/blog/${category}/${postId}`)
      .then(res => res.json())
      .then(setPost);
  }, [category, postId]);

  if (!post) return <div>Loading...</div>;

  return (
    <article>
      <div className="breadcrumb">
        <Link to="/blog">Blog</Link> /
        <Link to={`/blog/${category}`}>{category}</Link> /
        {post.title}
      </div>

      <h1>{post.title}</h1>
      <p className="category">Categoria: {category}</p>
      <div className="content">{post.content}</div>
    </article>
  );
}
\end{lstlisting}

\section{Query Parameters}

\subsection{useSearchParams Hook}

Gestire query string (?page=1\&sort=asc) con \texttt{useSearchParams}.

\begin{lstlisting}[caption={Gestione query parameters}]
import { useSearchParams } from 'react-router-dom';

function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();

  // Leggi query params
  const page = searchParams.get('page') || '1';
  const sort = searchParams.get('sort') || 'name';
  const category = searchParams.get('category');

  // Aggiorna query params
  const updatePage = (newPage) => {
    setSearchParams({ page: newPage, sort, category });
  };

  const updateSort = (newSort) => {
    setSearchParams({ page, sort: newSort, category });
  };

  // Rimuovi un query param
  const clearCategory = () => {
    const params = new URLSearchParams(searchParams);
    params.delete('category');
    setSearchParams(params);
  };

  return (
    <div>
      <h1>Prodotti</h1>

      {/* Filtri */}
      <div>
        <button onClick={() => updateSort('name')}>Ordina per Nome</button>
        <button onClick={() => updateSort('price')}>Ordina per Prezzo</button>
      </div>

      {/* Paginazione */}
      <div>
        <button onClick={() => updatePage(parseInt(page) - 1)}>
          Precedente
        </button>
        <span>Pagina {page}</span>
        <button onClick={() => updatePage(parseInt(page) + 1)}>
          Successivo
        </button>
      </div>

      {/* Mostra filtri attivi */}
      <div>
        Ordinamento: {sort}
        {category && (
          <span>
            , Categoria: {category}
            <button onClick={clearCategory}>X</button>
          </span>
        )}
      </div>
    </div>
  );
}
\end{lstlisting}

\subsection{Esempio Completo: Ricerca e Filtri}

\begin{lstlisting}[caption={Sistema di ricerca con filtri URL}]
import { useSearchParams, useNavigate } from 'react-router-dom';
import { useState, useEffect } from 'react';

function ProductSearch() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);

  // Estrai parametri dalla URL
  const query = searchParams.get('q') || '';
  const category = searchParams.get('category') || 'all';
  const minPrice = searchParams.get('minPrice') || '';
  const maxPrice = searchParams.get('maxPrice') || '';

  // Form state locale
  const [searchInput, setSearchInput] = useState(query);

  // Fetch prodotti quando cambiano i parametri
  useEffect(() => {
    const fetchProducts = async () => {
      setLoading(true);
      const params = new URLSearchParams(searchParams);
      const response = await fetch(`/api/products?${params}`);
      const data = await response.json();
      setProducts(data);
      setLoading(false);
    };

    fetchProducts();
  }, [searchParams]);

  // Handler per il form di ricerca
  const handleSearch = (e) => {
    e.preventDefault();
    setSearchParams(prev => {
      const params = new URLSearchParams(prev);
      if (searchInput) {
        params.set('q', searchInput);
      } else {
        params.delete('q');
      }
      return params;
    });
  };

  // Handler per cambio categoria
  const handleCategoryChange = (newCategory) => {
    setSearchParams(prev => {
      const params = new URLSearchParams(prev);
      params.set('category', newCategory);
      return params;
    });
  };

  // Handler per filtro prezzo
  const handlePriceFilter = (min, max) => {
    setSearchParams(prev => {
      const params = new URLSearchParams(prev);
      if (min) params.set('minPrice', min);
      else params.delete('minPrice');
      if (max) params.set('maxPrice', max);
      else params.delete('maxPrice');
      return params;
    });
  };

  // Reset tutti i filtri
  const resetFilters = () => {
    setSearchParams({});
    setSearchInput('');
  };

  return (
    <div className="product-search">
      {/* Search Form */}
      <form onSubmit={handleSearch}>
        <input
          type="text"
          value={searchInput}
          onChange={(e) => setSearchInput(e.target.value)}
          placeholder="Cerca prodotti..."
        />
        <button type="submit">Cerca</button>
      </form>

      {/* Filters */}
      <div className="filters">
        <select
          value={category}
          onChange={(e) => handleCategoryChange(e.target.value)}
        >
          <option value="all">Tutte le categorie</option>
          <option value="electronics">Elettronica</option>
          <option value="clothing">Abbigliamento</option>
          <option value="books">Libri</option>
        </select>

        <input
          type="number"
          placeholder="Prezzo min"
          value={minPrice}
          onChange={(e) => handlePriceFilter(e.target.value, maxPrice)}
        />

        <input
          type="number"
          placeholder="Prezzo max"
          value={maxPrice}
          onChange={(e) => handlePriceFilter(minPrice, e.target.value)}
        />

        <button onClick={resetFilters}>Reset Filtri</button>
      </div>

      {/* Active Filters Display */}
      <div className="active-filters">
        {query && <span>Ricerca: "{query}"</span>}
        {category !== 'all' && <span>Categoria: {category}</span>}
        {(minPrice || maxPrice) && (
          <span>
            Prezzo: {minPrice || '0'} - {maxPrice || '∞'}
          </span>
        )}
      </div>

      {/* Results */}
      {loading ? (
        <div>Caricamento...</div>
      ) : (
        <div className="products">
          {products.map(product => (
            <div key={product.id} className="product">
              <h3>{product.name}</h3>
              <p>{product.price}€</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
\end{lstlisting}

\section{Route Nidificate (Nested Routes)}

Le route nidificate permettono di creare layout con sottopagine.

\subsection{Layout con Outlet}

\begin{lstlisting}[caption={Layout componente con Outlet}]
import { Outlet, Link } from 'react-router-dom';

// Layout principale con sidebar
function DashboardLayout() {
  return (
    <div className="dashboard">
      <aside className="sidebar">
        <h2>Dashboard</h2>
        <nav>
          <Link to="/dashboard">Overview</Link>
          <Link to="/dashboard/stats">Statistiche</Link>
          <Link to="/dashboard/settings">Impostazioni</Link>
          <Link to="/dashboard/users">Utenti</Link>
        </nav>
      </aside>

      <main className="content">
        {/* Qui vengono renderizzate le route figlie */}
        <Outlet />
      </main>
    </div>
  );
}

export default DashboardLayout;
\end{lstlisting}

\subsection{Configurazione Route Nidificate}

\begin{lstlisting}[caption={Setup di route nidificate}]
import { Routes, Route } from 'react-router-dom';
import DashboardLayout from './layouts/DashboardLayout';
import DashboardHome from './pages/dashboard/Home';
import DashboardStats from './pages/dashboard/Stats';
import DashboardSettings from './pages/dashboard/Settings';
import DashboardUsers from './pages/dashboard/Users';

function App() {
  return (
    <Routes>
      {/* Route principale con nested routes */}
      <Route path="/dashboard" element={<DashboardLayout />}>
        {/* Index route (default) */}
        <Route index element={<DashboardHome />} />

        {/* Nested routes */}
        <Route path="stats" element={<DashboardStats />} />
        <Route path="settings" element={<DashboardSettings />} />
        <Route path="users" element={<DashboardUsers />} />
      </Route>
    </Routes>
  );
}
\end{lstlisting}

\subsection{Route Nidificate Multilivello}

\begin{lstlisting}[caption={Nesting profondo con più livelli}]
import { Routes, Route } from 'react-router-dom';

function App() {
  return (
    <Routes>
      <Route path="/" element={<RootLayout />}>
        <Route index element={<Home />} />

        {/* Blog con nested routes */}
        <Route path="blog" element={<BlogLayout />}>
          <Route index element={<BlogHome />} />
          <Route path=":category" element={<CategoryLayout />}>
            <Route index element={<CategoryHome />} />
            <Route path=":postId" element={<BlogPost />} />
          </Route>
        </Route>

        {/* Admin con nested routes */}
        <Route path="admin" element={<AdminLayout />}>
          <Route index element={<AdminDashboard />} />
          <Route path="users" element={<UsersLayout />}>
            <Route index element={<UsersList />} />
            <Route path=":userId" element={<UserDetail />} />
            <Route path=":userId/edit" element={<UserEdit />} />
          </Route>
        </Route>
      </Route>
    </Routes>
  );
}
\end{lstlisting}

\section{Protected Routes (Route Protette)}

Le route protette richiedono autenticazione per l'accesso.

\subsection{Componente ProtectedRoute}

\begin{lstlisting}[caption={Implementazione di route protetta}]
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from './hooks/useAuth'; // Custom hook per auth

function ProtectedRoute({ children }) {
  const { isAuthenticated, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return <div>Caricamento...</div>;
  }

  if (!isAuthenticated) {
    // Redirect al login, salvando la location corrente
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
}

export default ProtectedRoute;
\end{lstlisting}

\subsection{Utilizzo delle Protected Routes}

\begin{lstlisting}[caption={Setup di route protette}]
import { Routes, Route } from 'react-router-dom';
import ProtectedRoute from './components/ProtectedRoute';

function App() {
  return (
    <Routes>
      {/* Route pubbliche */}
      <Route path="/" element={<Home />} />
      <Route path="/login" element={<Login />} />
      <Route path="/register" element={<Register />} />

      {/* Route protette */}
      <Route
        path="/dashboard"
        element={
          <ProtectedRoute>
            <Dashboard />
          </ProtectedRoute>
        }
      />

      <Route
        path="/profile"
        element={
          <ProtectedRoute>
            <Profile />
          </ProtectedRoute>
        }
      />

      {/* Nested protected routes */}
      <Route
        path="/admin"
        element={
          <ProtectedRoute>
            <AdminLayout />
          </ProtectedRoute>
        }
      >
        <Route index element={<AdminDashboard />} />
        <Route path="users" element={<AdminUsers />} />
      </Route>
    </Routes>
  );
}
\end{lstlisting}

\subsection{Hook useAuth Personalizzato}

\begin{lstlisting}[caption={Custom hook per autenticazione}]
import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Controlla se c'è un utente loggato (es. da localStorage)
    const checkAuth = async () => {
      try {
        const token = localStorage.getItem('token');
        if (token) {
          const response = await fetch('/api/auth/me', {
            headers: { Authorization: `Bearer ${token}` }
          });
          if (response.ok) {
            const userData = await response.json();
            setUser(userData);
          }
        }
      } catch (error) {
        console.error('Auth check failed:', error);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email, password) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    });

    if (response.ok) {
      const { user, token } = await response.json();
      localStorage.setItem('token', token);
      setUser(user);
      return true;
    }
    return false;
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        loading,
        login,
        logout
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth deve essere usato dentro AuthProvider');
  }
  return context;
}
\end{lstlisting}

\subsection{Route con Ruoli (Role-Based)}

\begin{lstlisting}[caption={Route protette per ruolo}]
import { Navigate } from 'react-router-dom';
import { useAuth } from './hooks/useAuth';

function RoleProtectedRoute({ children, allowedRoles }) {
  const { user, isAuthenticated, loading } = useAuth();

  if (loading) {
    return <div>Caricamento...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  if (allowedRoles && !allowedRoles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
}

// Utilizzo
function App() {
  return (
    <Routes>
      {/* Solo admin */}
      <Route
        path="/admin"
        element={
          <RoleProtectedRoute allowedRoles={['admin']}>
            <AdminPanel />
          </RoleProtectedRoute>
        }
      />

      {/* Admin e moderatori */}
      <Route
        path="/moderation"
        element={
          <RoleProtectedRoute allowedRoles={['admin', 'moderator']}>
            <ModerationPanel />
          </RoleProtectedRoute>
        }
      />

      {/* Tutti gli utenti autenticati */}
      <Route
        path="/dashboard"
        element={
          <RoleProtectedRoute>
            <Dashboard />
          </RoleProtectedRoute>
        }
      />
    </Routes>
  );
}
\end{lstlisting}

\section{Lazy Loading e Code Splitting}

Il lazy loading carica i componenti solo quando necessario, riducendo il bundle iniziale.

\subsection{Setup Base con React.lazy}

\begin{lstlisting}[caption={Lazy loading di base}]
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';

// Lazy import
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Profile = lazy(() => import('./pages/Profile'));

function App() {
  return (
    <Suspense fallback={<div>Caricamento...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/dashboard" element={<Dashboard />} />
        <Route path="/profile" element={<Profile />} />
      </Routes>
    </Suspense>
  );
}
\end{lstlisting}

\subsection{Loading Component Personalizzato}

\begin{lstlisting}[caption={Componente loading personalizzato}]
function LoadingSpinner() {
  return (
    <div className="loading-container">
      <div className="spinner"></div>
      <p>Caricamento in corso...</p>
    </div>
  );
}

// CSS per spinner
// .spinner {
//   border: 4px solid #f3f3f3;
//   border-top: 4px solid #3498db;
//   border-radius: 50%;
//   width: 40px;
//   height: 40px;
//   animation: spin 1s linear infinite;
// }
//
// @keyframes spin {
//   0% { transform: rotate(0deg); }
//   100% { transform: rotate(360deg); }
// }

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Routes>
        {/* routes */}
      </Routes>
    </Suspense>
  );
}
\end{lstlisting}

\subsection{Lazy Loading con Error Boundary}

\begin{lstlisting}[caption={Gestione errori nel lazy loading}]
import { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error loading component:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-container">
          <h2>Errore nel caricamento</h2>
          <p>{this.state.error?.message}</p>
          <button onClick={() => window.location.reload()}>
            Ricarica Pagina
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Utilizzo
function App() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<LazyHome />} />
          <Route path="/dashboard" element={<LazyDashboard />} />
        </Routes>
      </Suspense>
    </ErrorBoundary>
  );
}
\end{lstlisting}

\subsection{Preloading delle Route}

\begin{lstlisting}[caption={Precaricamento route al hover}]
import { lazy } from 'react';
import { Link } from 'react-router-dom';

// Lazy imports
const Dashboard = lazy(() => import('./pages/Dashboard'));

// Funzione per preload
const preloadDashboard = () => {
  import('./pages/Dashboard');
};

function Navigation() {
  return (
    <nav>
      <Link to="/">Home</Link>

      {/* Preload al mouseenter */}
      <Link
        to="/dashboard"
        onMouseEnter={preloadDashboard}
        onFocus={preloadDashboard}
      >
        Dashboard
      </Link>
    </nav>
  );
}
\end{lstlisting}

\section{useLocation Hook}

\texttt{useLocation} fornisce accesso alla location corrente.

\begin{lstlisting}[caption={Utilizzo di useLocation}]
import { useLocation, useNavigate } from 'react-router-dom';
import { useEffect } from 'react';

function Analytics() {
  const location = useLocation();

  useEffect(() => {
    // Track page view
    console.log('Page view:', location.pathname);
    // analytics.track('page_view', { path: location.pathname });
  }, [location]);

  return null;
}

function LoginPage() {
  const location = useLocation();
  const navigate = useNavigate();

  const handleLogin = async (credentials) => {
    const success = await login(credentials);

    if (success) {
      // Redirect alla pagina da cui l'utente veniva
      const from = location.state?.from?.pathname || '/dashboard';
      navigate(from, { replace: true });
    }
  };

  return (
    <div>
      <h1>Login</h1>
      {location.state?.from && (
        <p>Devi effettuare il login per accedere a questa pagina</p>
      )}
      {/* form */}
    </div>
  );
}
\end{lstlisting}

\section{Applicazione Completa}

\subsection{Struttura del Progetto}

\begin{lstlisting}[caption={Struttura directory consigliata}]
src/
├── components/
│   ├── common/
│   │   ├── LoadingSpinner.jsx
│   │   ├── ErrorBoundary.jsx
│   │   └── Navigation.jsx
│   ├── auth/
│   │   ├── ProtectedRoute.jsx
│   │   └── RoleProtectedRoute.jsx
│   └── layout/
│       ├── RootLayout.jsx
│       ├── DashboardLayout.jsx
│       └── AdminLayout.jsx
├── pages/
│   ├── Home.jsx
│   ├── About.jsx
│   ├── Login.jsx
│   ├── Register.jsx
│   ├── NotFound.jsx
│   ├── dashboard/
│   │   ├── Dashboard.jsx
│   │   ├── Stats.jsx
│   │   └── Settings.jsx
│   └── admin/
│       ├── AdminPanel.jsx
│       └── Users.jsx
├── hooks/
│   └── useAuth.js
├── context/
│   └── AuthContext.jsx
├── App.jsx
└── main.jsx
\end{lstlisting}

\subsection{App.jsx Completa}

\begin{lstlisting}[caption={Configurazione completa dell'app}]
import { lazy, Suspense } from 'react';
import { Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import ErrorBoundary from './components/common/ErrorBoundary';
import LoadingSpinner from './components/common/LoadingSpinner';
import ProtectedRoute from './components/auth/ProtectedRoute';
import RoleProtectedRoute from './components/auth/RoleProtectedRoute';
import RootLayout from './components/layout/RootLayout';
import DashboardLayout from './components/layout/DashboardLayout';
import AdminLayout from './components/layout/AdminLayout';

// Lazy loaded pages
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Login = lazy(() => import('./pages/Login'));
const Register = lazy(() => import('./pages/Register'));
const Dashboard = lazy(() => import('./pages/dashboard/Dashboard'));
const Stats = lazy(() => import('./pages/dashboard/Stats'));
const Settings = lazy(() => import('./pages/dashboard/Settings'));
const AdminPanel = lazy(() => import('./pages/admin/AdminPanel'));
const AdminUsers = lazy(() => import('./pages/admin/Users'));
const NotFound = lazy(() => import('./pages/NotFound'));

function App() {
  return (
    <AuthProvider>
      <ErrorBoundary>
        <Suspense fallback={<LoadingSpinner />}>
          <Routes>
            {/* Root layout */}
            <Route path="/" element={<RootLayout />}>
              {/* Public routes */}
              <Route index element={<Home />} />
              <Route path="about" element={<About />} />
              <Route path="login" element={<Login />} />
              <Route path="register" element={<Register />} />

              {/* Protected dashboard routes */}
              <Route
                path="dashboard"
                element={
                  <ProtectedRoute>
                    <DashboardLayout />
                  </ProtectedRoute>
                }
              >
                <Route index element={<Dashboard />} />
                <Route path="stats" element={<Stats />} />
                <Route path="settings" element={<Settings />} />
              </Route>

              {/* Admin routes (role-based) */}
              <Route
                path="admin"
                element={
                  <RoleProtectedRoute allowedRoles={['admin']}>
                    <AdminLayout />
                  </RoleProtectedRoute>
                }
              >
                <Route index element={<AdminPanel />} />
                <Route path="users" element={<AdminUsers />} />
              </Route>

              {/* 404 */}
              <Route path="*" element={<NotFound />} />
            </Route>
          </Routes>
        </Suspense>
      </ErrorBoundary>
    </AuthProvider>
  );
}

export default App;
\end{lstlisting}

\section{Best Practices}

\begin{tcolorbox}[title=Best Practices per Routing]
\begin{itemize}
\item Usa sempre \texttt{BrowserRouter} per SPA moderne
\item Implementa lazy loading per route pesanti
\item Proteggi route sensibili con autenticazione
\item Usa \texttt{NavLink} per navigazione con stato attivo
\item Gestisci sempre la route 404
\item Usa \texttt{Suspense} con fallback significativi
\item Implementa Error Boundaries per lazy loaded routes
\item Traccia navigazione con analytics
\item Usa nested routes per layout condivisi
\item Preferisci useNavigate a window.location
\end{itemize}
\end{tcolorbox}

\section{Conclusioni}

React Router v6 offre un sistema di routing potente e flessibile per applicazioni React. Con le sue API dichiarative, supporto per lazy loading, route protette e navigazione programmatica, permette di creare SPA complesse e performanti con ottima user experience.
