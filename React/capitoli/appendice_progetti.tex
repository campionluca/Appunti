% appendice_progetti.tex - Progetti Completi: Todo App, E-commerce, Dashboard

\chapter{Appendice: Progetti Completi}
\label{app:projects}

\section{Introduzione}

Questa appendice presenta tre progetti completi funzionanti che dimostrano best practices, pattern e tecniche avanzate di React.

\section{Progetto 1: Todo App Completa}

Un'applicazione Todo con tutte le features moderne: filtri, local storage, editing inline e statistiche.

\subsection{Struttura del Progetto}

\begin{lstlisting}[caption={Struttura directory Todo App}]
todo-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TodoForm.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TodoList.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TodoItem.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TodoFilters.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TodoStats.jsx
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useTodos.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useLocalStorage.js
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ vite.config.js
\end{lstlisting}

\subsection{Custom Hooks}

\begin{lstlisting}[caption={useLocalStorage hook}]
// hooks/useLocalStorage.js
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error('Error loading from localStorage:', error);
      return initialValue;
    }
  });

  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Error saving to localStorage:', error);
    }
  }, [key, value]);

  return [value, setValue];
}

export default useLocalStorage;
\end{lstlisting}

\begin{lstlisting}[caption={useTodos hook}]
// hooks/useTodos.js
import { useCallback } from 'react';
import useLocalStorage from './useLocalStorage';

function useTodos() {
  const [todos, setTodos] = useLocalStorage('todos', []);

  const addTodo = useCallback((text) => {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date().toISOString()
    };
    setTodos(prev => [...prev, newTodo]);
  }, [setTodos]);

  const toggleTodo = useCallback((id) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id
          ? { ...todo, completed: !todo.completed }
          : todo
      )
    );
  }, [setTodos]);

  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, [setTodos]);

  const updateTodo = useCallback((id, newText) => {
    setTodos(prev =>
      prev.map(todo =>
        todo.id === id
          ? { ...todo, text: newText }
          : todo
      )
    );
  }, [setTodos]);

  const clearCompleted = useCallback(() => {
    setTodos(prev => prev.filter(todo => !todo.completed));
  }, [setTodos]);

  return {
    todos,
    addTodo,
    toggleTodo,
    deleteTodo,
    updateTodo,
    clearCompleted
  };
}

export default useTodos;
\end{lstlisting}

\subsection{Componenti}

\begin{lstlisting}[caption={TodoForm component}]
// components/TodoForm.jsx
import { useState } from 'react';

function TodoForm({ onAdd }) {
  const [input, setInput] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (input.trim()) {
      onAdd(input.trim());
      setInput('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="todo-form">
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Cosa devi fare?"
        className="todo-input"
      />
      <button type="submit" className="todo-add-btn">
        Aggiungi
      </button>
    </form>
  );
}

export default TodoForm;
\end{lstlisting}

\begin{lstlisting}[caption={TodoItem component}]
// components/TodoItem.jsx
import { useState } from 'react';

function TodoItem({ todo, onToggle, onDelete, onUpdate }) {
  const [isEditing, setIsEditing] = useState(false);
  const [editText, setEditText] = useState(todo.text);

  const handleSave = () => {
    if (editText.trim()) {
      onUpdate(todo.id, editText.trim());
      setIsEditing(false);
    }
  };

  const handleCancel = () => {
    setEditText(todo.text);
    setIsEditing(false);
  };

  if (isEditing) {
    return (
      <li className="todo-item editing">
        <input
          type="text"
          value={editText}
          onChange={(e) => setEditText(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') handleSave();
            if (e.key === 'Escape') handleCancel();
          }}
          className="todo-edit-input"
          autoFocus
        />
        <button onClick={handleSave} className="save-btn">Salva</button>
        <button onClick={handleCancel} className="cancel-btn">Annulla</button>
      </li>
    );
  }

  return (
    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
        className="todo-checkbox"
      />

      <span
        onDoubleClick={() => setIsEditing(true)}
        className="todo-text"
      >
        {todo.text}
      </span>

      <div className="todo-actions">
        <button
          onClick={() => setIsEditing(true)}
          className="edit-btn"
          title="Modifica"
        >
          ‚úèÔ∏è
        </button>
        <button
          onClick={() => onDelete(todo.id)}
          className="delete-btn"
          title="Elimina"
        >
          üóëÔ∏è
        </button>
      </div>
    </li>
  );
}

export default TodoItem;
\end{lstlisting}

\begin{lstlisting}[caption={TodoList component}]
// components/TodoList.jsx
import TodoItem from './TodoItem';

function TodoList({ todos, onToggle, onDelete, onUpdate }) {
  if (todos.length === 0) {
    return (
      <div className="empty-state">
        <p>Nessun todo. Aggiungine uno!</p>
      </div>
    );
  }

  return (
    <ul className="todo-list">
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={onToggle}
          onDelete={onDelete}
          onUpdate={onUpdate}
        />
      ))}
    </ul>
  );
}

export default TodoList;
\end{lstlisting}

\begin{lstlisting}[caption={TodoFilters component}]
// components/TodoFilters.jsx
function TodoFilters({ filter, setFilter }) {
  const filters = [
    { value: 'all', label: 'Tutti' },
    { value: 'active', label: 'Attivi' },
    { value: 'completed', label: 'Completati' }
  ];

  return (
    <div className="todo-filters">
      {filters.map(f => (
        <button
          key={f.value}
          onClick={() => setFilter(f.value)}
          className={`filter-btn ${filter === f.value ? 'active' : ''}`}
        >
          {f.label}
        </button>
      ))}
    </div>
  );
}

export default TodoFilters;
\end{lstlisting}

\begin{lstlisting}[caption={TodoStats component}]
// components/TodoStats.jsx
function TodoStats({ todos }) {
  const total = todos.length;
  const completed = todos.filter(t => t.completed).length;
  const active = total - completed;
  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

  return (
    <div className="todo-stats">
      <div className="stat">
        <span className="stat-label">Totale:</span>
        <span className="stat-value">{total}</span>
      </div>

      <div className="stat">
        <span className="stat-label">Attivi:</span>
        <span className="stat-value">{active}</span>
      </div>

      <div className="stat">
        <span className="stat-label">Completati:</span>
        <span className="stat-value">{completed}</span>
      </div>

      <div className="stat">
        <span className="stat-label">Progresso:</span>
        <span className="stat-value">{percentage}%</span>
      </div>

      <div className="progress-bar">
        <div
          className="progress-fill"
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  );
}

export default TodoStats;
\end{lstlisting}

\subsection{App Principale}

\begin{lstlisting}[caption={App.jsx completo}]
// App.jsx
import { useState, useMemo } from 'react';
import useTodos from './hooks/useTodos';
import TodoForm from './components/TodoForm';
import TodoList from './components/TodoList';
import TodoFilters from './components/TodoFilters';
import TodoStats from './components/TodoStats';
import './App.css';

function App() {
  const {
    todos,
    addTodo,
    toggleTodo,
    deleteTodo,
    updateTodo,
    clearCompleted
  } = useTodos();

  const [filter, setFilter] = useState('all');

  // Filtra todos in base al filtro selezionato
  const filteredTodos = useMemo(() => {
    switch (filter) {
      case 'active':
        return todos.filter(todo => !todo.completed);
      case 'completed':
        return todos.filter(todo => todo.completed);
      default:
        return todos;
    }
  }, [todos, filter]);

  const hasCompleted = todos.some(todo => todo.completed);

  return (
    <div className="app">
      <header className="app-header">
        <h1>üìù Todo App</h1>
      </header>

      <main className="app-main">
        <TodoForm onAdd={addTodo} />

        <TodoStats todos={todos} />

        <TodoFilters filter={filter} setFilter={setFilter} />

        <TodoList
          todos={filteredTodos}
          onToggle={toggleTodo}
          onDelete={deleteTodo}
          onUpdate={updateTodo}
        />

        {hasCompleted && (
          <button
            onClick={clearCompleted}
            className="clear-completed-btn"
          >
            Elimina Completati
          </button>
        )}
      </main>
    </div>
  );
}

export default App;
\end{lstlisting}

\section{Progetto 2: E-commerce Product Catalog}

Un catalogo prodotti e-commerce con carrello, filtri e checkout.

\subsection{Struttura}

\begin{lstlisting}[caption={Struttura E-commerce App}]
ecommerce-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductCard.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductList.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductFilters.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Cart.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CartItem.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Checkout.jsx
‚îÇ   ‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CartContext.jsx
‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products.js
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
\end{lstlisting}

\subsection{Context per Carrello}

\begin{lstlisting}[caption={CartContext.jsx}]
// context/CartContext.jsx
import { createContext, useContext, useReducer } from 'react';

const CartContext = createContext();

function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingIndex = state.items.findIndex(
        item => item.id === action.payload.id
      );

      if (existingIndex >= 0) {
        const newItems = [...state.items];
        newItems[existingIndex].quantity += 1;
        return { ...state, items: newItems };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };

    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload)
      };

    case 'UPDATE_QUANTITY':
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      };

    case 'CLEAR_CART':
      return { ...state, items: [] };

    default:
      return state;
  }
}

export function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  const addItem = (product) => {
    dispatch({ type: 'ADD_ITEM', payload: product });
  };

  const removeItem = (productId) => {
    dispatch({ type: 'REMOVE_ITEM', payload: productId });
  };

  const updateQuantity = (productId, quantity) => {
    if (quantity <= 0) {
      removeItem(productId);
    } else {
      dispatch({ type: 'UPDATE_QUANTITY', payload: { id: productId, quantity } });
    }
  };

  const clearCart = () => {
    dispatch({ type: 'CLEAR_CART' });
  };

  const totalItems = state.items.reduce((sum, item) => sum + item.quantity, 0);

  const totalPrice = state.items.reduce(
    (sum, item) => sum + (item.price * item.quantity),
    0
  );

  return (
    <CartContext.Provider
      value={{
        items: state.items,
        addItem,
        removeItem,
        updateQuantity,
        clearCart,
        totalItems,
        totalPrice
      }}
    >
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}
\end{lstlisting}

\subsection{Componenti Prodotto}

\begin{lstlisting}[caption={ProductCard component}]
// components/ProductCard.jsx
import { useCart } from '../context/CartContext';

function ProductCard({ product }) {
  const { addItem } = useCart();

  return (
    <div className="product-card">
      <img
        src={product.image}
        alt={product.name}
        className="product-image"
      />

      <div className="product-info">
        <h3 className="product-name">{product.name}</h3>
        <p className="product-category">{product.category}</p>
        <p className="product-description">{product.description}</p>

        <div className="product-footer">
          <span className="product-price">{product.price.toFixed(2)}‚Ç¨</span>

          <button
            onClick={() => addItem(product)}
            className="add-to-cart-btn"
          >
            Aggiungi al Carrello
          </button>
        </div>
      </div>
    </div>
  );
}

export default ProductCard;
\end{lstlisting}

\begin{lstlisting}[caption={ProductList component}]
// components/ProductList.jsx
import { useState, useMemo } from 'react';
import ProductCard from './ProductCard';
import ProductFilters from './ProductFilters';

function ProductList({ products }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [category, setCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');

  // Filtra e ordina prodotti
  const filteredProducts = useMemo(() => {
    let result = products;

    // Filtra per ricerca
    if (searchTerm) {
      result = result.filter(p =>
        p.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    // Filtra per categoria
    if (category !== 'all') {
      result = result.filter(p => p.category === category);
    }

    // Ordina
    result = [...result].sort((a, b) => {
      switch (sortBy) {
        case 'price-asc':
          return a.price - b.price;
        case 'price-desc':
          return b.price - a.price;
        case 'name':
        default:
          return a.name.localeCompare(b.name);
      }
    });

    return result;
  }, [products, searchTerm, category, sortBy]);

  return (
    <div className="product-list-container">
      <ProductFilters
        searchTerm={searchTerm}
        setSearchTerm={setSearchTerm}
        category={category}
        setCategory={setCategory}
        sortBy={sortBy}
        setSortBy={setSortBy}
      />

      <div className="product-grid">
        {filteredProducts.length === 0 ? (
          <p>Nessun prodotto trovato</p>
        ) : (
          filteredProducts.map(product => (
            <ProductCard key={product.id} product={product} />
          ))
        )}
      </div>
    </div>
  );
}

export default ProductList;
\end{lstlisting}

\begin{lstlisting}[caption={Cart component}]
// components/Cart.jsx
import { useCart } from '../context/CartContext';
import CartItem from './CartItem';

function Cart({ isOpen, onClose }) {
  const { items, totalItems, totalPrice, clearCart } = useCart();

  if (!isOpen) return null;

  return (
    <div className="cart-overlay" onClick={onClose}>
      <div className="cart-sidebar" onClick={(e) => e.stopPropagation()}>
        <div className="cart-header">
          <h2>Carrello ({totalItems})</h2>
          <button onClick={onClose} className="close-btn">√ó</button>
        </div>

        <div className="cart-items">
          {items.length === 0 ? (
            <p className="empty-cart">Il carrello √® vuoto</p>
          ) : (
            items.map(item => (
              <CartItem key={item.id} item={item} />
            ))
          )}
        </div>

        {items.length > 0 && (
          <div className="cart-footer">
            <div className="cart-total">
              <span>Totale:</span>
              <span className="total-price">{totalPrice.toFixed(2)}‚Ç¨</span>
            </div>

            <button className="checkout-btn">
              Procedi al Checkout
            </button>

            <button onClick={clearCart} className="clear-cart-btn">
              Svuota Carrello
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

export default Cart;
\end{lstlisting}

\subsection{App Principale E-commerce}

\begin{lstlisting}[caption={App E-commerce completo}]
// App.jsx
import { useState } from 'react';
import { CartProvider } from './context/CartContext';
import ProductList from './components/ProductList';
import Cart from './components/Cart';
import { products } from './data/products';
import './App.css';

function App() {
  const [cartOpen, setCartOpen] = useState(false);

  return (
    <CartProvider>
      <div className="app">
        <header className="app-header">
          <h1>üõí E-Shop</h1>

          <button
            onClick={() => setCartOpen(true)}
            className="cart-icon-btn"
          >
            Carrello
          </button>
        </header>

        <main className="app-main">
          <ProductList products={products} />
        </main>

        <Cart isOpen={cartOpen} onClose={() => setCartOpen(false)} />
      </div>
    </CartProvider>
  );
}

export default App;
\end{lstlisting}

\section{Progetto 3: Dashboard Analytics}

Una dashboard con grafici, metriche e data fetching.

\subsection{Struttura Dashboard}

\begin{lstlisting}[caption={Struttura Dashboard}]
dashboard-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MetricCard.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Chart.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ RecentActivity.jsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UserTable.jsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Sidebar.jsx
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAnalytics.js
‚îÇ   ‚îú‚îÄ‚îÄ App.jsx
‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
\end{lstlisting}

\subsection{Hook per Analytics}

\begin{lstlisting}[caption={useAnalytics hook}]
// hooks/useAnalytics.js
import { useState, useEffect } from 'react';

function useAnalytics() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchAnalytics = async () => {
      try {
        setLoading(true);

        // Simula API call
        await new Promise(resolve => setTimeout(resolve, 1000));

        const mockData = {
          metrics: {
            totalUsers: 15420,
            activeUsers: 8732,
            revenue: 245689,
            conversion: 3.2
          },
          chartData: Array.from({ length: 12 }, (_, i) => ({
            month: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu',
                   'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'][i],
            value: Math.floor(Math.random() * 5000) + 2000
          })),
          recentActivity: [
            { id: 1, user: 'Mario Rossi', action: 'Nuovo ordine', time: '2 min fa' },
            { id: 2, user: 'Laura Bianchi', action: 'Registrazione', time: '15 min fa' },
            { id: 3, user: 'Giuseppe Verdi', action: 'Pagamento', time: '1 ora fa' }
          ]
        };

        setData(mockData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchAnalytics();

    // Refresh ogni 30 secondi
    const interval = setInterval(fetchAnalytics, 30000);

    return () => clearInterval(interval);
  }, []);

  return { data, loading, error };
}

export default useAnalytics;
\end{lstlisting}

\subsection{Dashboard App Completo}

\begin{lstlisting}[caption={Dashboard App.jsx}]
// App.jsx
import useAnalytics from './hooks/useAnalytics';
import MetricCard from './components/MetricCard';
import Chart from './components/Chart';
import RecentActivity from './components/RecentActivity';

function App() {
  const { data, loading, error } = useAnalytics();

  if (loading) {
    return (
      <div className="loading-container">
        <div className="spinner"></div>
        <p>Caricamento dashboard...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="error-container">
        <p>Errore: {error}</p>
      </div>
    );
  }

  return (
    <div className="dashboard">
      <header className="dashboard-header">
        <h1>üìä Analytics Dashboard</h1>
      </header>

      <main className="dashboard-main">
        <section className="metrics-grid">
          <MetricCard
            title="Utenti Totali"
            value={data.metrics.totalUsers.toLocaleString()}
            icon="üë•"
            trend="+12%"
          />

          <MetricCard
            title="Utenti Attivi"
            value={data.metrics.activeUsers.toLocaleString()}
            icon="‚úÖ"
            trend="+8%"
          />

          <MetricCard
            title="Revenue"
            value={`‚Ç¨${(data.metrics.revenue / 1000).toFixed(1)}K`}
            icon="üí∞"
            trend="+23%"
          />

          <MetricCard
            title="Conversione"
            value={`${data.metrics.conversion}%`}
            icon="üìà"
            trend="+0.5%"
          />
        </section>

        <section className="chart-section">
          <Chart data={data.chartData} />
        </section>

        <section className="activity-section">
          <RecentActivity activities={data.recentActivity} />
        </section>
      </main>
    </div>
  );
}

export default App;
\end{lstlisting}

\section{Best Practices Implementate}

\begin{tcolorbox}[title=Best Practices nei Progetti]
\begin{itemize}
\item \textbf{Separazione delle Responsabilit√†}: Componenti piccoli e focalizzati
\item \textbf{Custom Hooks}: Logica riutilizzabile estratta in hooks
\item \textbf{Context API}: State management per dati globali (carrello)
\item \textbf{Memoization}: useMemo per calcoli costosi e filtri
\item \textbf{Local Storage}: Persistenza dati (todo app)
\item \textbf{Error Handling}: Gestione errori in data fetching
\item \textbf{Loading States}: Feedback visivo durante operazioni async
\item \textbf{Accessibility}: Uso corretto di semantica HTML
\item \textbf{Performance}: Ottimizzazioni con React.memo dove necessario
\item \textbf{Code Organization}: Struttura chiara e manutenibile
\end{itemize}
\end{tcolorbox}

\section{Deployment}

\subsection{Build per Produzione}

\begin{lstlisting}[caption={Build e deployment}]
# Build con Vite
npm run build

# Preview build locale
npm run preview

# Deploy su Netlify
netlify deploy --prod --dir=dist

# Deploy su Vercel
vercel --prod

# Deploy su GitHub Pages
npm run build
git add dist -f
git commit -m "Deploy"
git subtree push --prefix dist origin gh-pages
\end{lstlisting}

\section{Conclusioni}

Questi tre progetti dimostrano applicazioni React complete e funzionanti con:

\begin{itemize}
\item \textbf{Todo App}: State management locale, custom hooks, local storage
\item \textbf{E-commerce}: Context API, reducer pattern, carrello funzionale
\item \textbf{Dashboard}: Data fetching, visualizzazione dati, analytics
\end{itemize}

Studiare e modificare questi progetti √® il modo migliore per imparare React in modo pratico e approfondito.
