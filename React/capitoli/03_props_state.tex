\chapter{Props e State Management}

\section{Props: Dati Immutabili}

Le props (properties) sono il meccanismo primario per passare dati in React. Sono immutabili dal punto di vista del componente che le riceve.

\subsection{Props Immutability}

\begin{lstlisting}[language=JavaScript, caption=Props sono read-only]
function Welcome({ name }) {
    // ❌ ERRORE: Non puoi modificare le props
    // name = 'Nuovo nome'; // TypeError in Strict Mode

    // ✅ Le props si leggono soltanto
    return <h1>Benvenuto, {name}!</h1>;
}

function App() {
    const [userName, setUserName] = useState('Mario');

    // Per cambiare i dati, cambi lo state nel parent
    return (
        <div>
            <Welcome name={userName} />
            <button onClick={() => setUserName('Luigi')}>
                Cambia nome
            </button>
        </div>
    );
}
\end{lstlisting}

\subsection{Tipi di Props}

\textbf{1. Props Primitive}

\begin{lstlisting}[language=JavaScript, caption=Props primitive]
function UserProfile({
    name,        // string
    age,         // number
    isActive,    // boolean
    score        // number
}) {
    return (
        <div>
            <h2>{name}</h2>
            <p>Età: {age}</p>
            <p>Stato: {isActive ? 'Attivo' : 'Inattivo'}</p>
            <p>Punteggio: {score}</p>
        </div>
    );
}

// Uso
<UserProfile
    name="Mario"
    age={30}
    isActive={true}
    score={95.5}
/>
\end{lstlisting}

\textbf{2. Props Oggetti e Array}

\begin{lstlisting}[language=JavaScript, caption=Props complesse]
function ProductCard({ product, tags, seller }) {
    return (
        <div className="product-card">
            <h3>{product.name}</h3>
            <p>€{product.price}</p>
            <p>{product.description}</p>

            <div className="tags">
                {tags.map(tag => (
                    <span key={tag} className="tag">{tag}</span>
                ))}
            </div>

            <div className="seller">
                <img src={seller.avatar} alt={seller.name} />
                <span>{seller.name}</span>
            </div>
        </div>
    );
}

// Uso
function App() {
    const product = {
        id: 1,
        name: 'Laptop',
        price: 999,
        description: 'Un ottimo laptop'
    };

    const tags = ['Elettronica', 'Computer', 'Offerta'];

    const seller = {
        id: 10,
        name: 'TechStore',
        avatar: '/seller.jpg'
    };

    return (
        <ProductCard
            product={product}
            tags={tags}
            seller={seller}
        />
    );
}
\end{lstlisting}

\textbf{3. Props Funzioni (Callbacks)}

\begin{lstlisting}[language=JavaScript, caption=Callback props]
function SearchBar({ onSearch, onClear, onFilterChange }) {
    const [query, setQuery] = useState('');
    const [filter, setFilter] = useState('all');

    const handleSearch = () => {
        onSearch(query, filter);
    };

    const handleClear = () => {
        setQuery('');
        onClear();
    };

    const handleFilterChange = (newFilter) => {
        setFilter(newFilter);
        onFilterChange(newFilter);
    };

    return (
        <div className="search-bar">
            <input
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Cerca..."
            />
            <button onClick={handleSearch}>Cerca</button>
            <button onClick={handleClear}>Cancella</button>

            <select
                value={filter}
                onChange={(e) => handleFilterChange(e.target.value)}
            >
                <option value="all">Tutti</option>
                <option value="active">Attivi</option>
                <option value="archived">Archiviati</option>
            </select>
        </div>
    );
}

// Uso nel parent
function App() {
    const handleSearch = (query, filter) => {
        console.log('Ricerca:', query, 'Filtro:', filter);
        // Fetch dati...
    };

    const handleClear = () => {
        console.log('Reset ricerca');
    };

    const handleFilterChange = (filter) => {
        console.log('Filtro cambiato:', filter);
    };

    return (
        <SearchBar
            onSearch={handleSearch}
            onClear={handleClear}
            onFilterChange={handleFilterChange}
        />
    );
}
\end{lstlisting}

\textbf{4. Props come Componenti (Render Props)}

\begin{lstlisting}[language=JavaScript, caption=Componenti come props]
function Layout({ header, sidebar, footer, children }) {
    return (
        <div className="layout">
            <header className="header">{header}</header>
            <div className="main-content">
                <aside className="sidebar">{sidebar}</aside>
                <main className="content">{children}</main>
            </div>
            <footer className="footer">{footer}</footer>
        </div>
    );
}

// Uso
function App() {
    return (
        <Layout
            header={<AppHeader />}
            sidebar={<Navigation />}
            footer={<AppFooter />}
        >
            <h1>Contenuto principale</h1>
            <p>Contenuto della pagina...</p>
        </Layout>
    );
}
\end{lstlisting}

\section{Props Drilling}

Props drilling si verifica quando passi props attraverso molti livelli di componenti intermedi.

\subsection{Il Problema del Props Drilling}

\begin{lstlisting}[language=JavaScript, caption=Props drilling eccessivo]
// Livello 1: App
function App() {
    const [user, setUser] = useState({
        name: 'Mario',
        theme: 'dark',
        language: 'it'
    });

    return <Layout user={user} setUser={setUser} />;
}

// Livello 2: Layout (non usa user, solo passa)
function Layout({ user, setUser }) {
    return (
        <div>
            <Header user={user} setUser={setUser} />
            <Main user={user} setUser={setUser} />
        </div>
    );
}

// Livello 3: Header (non usa user, solo passa)
function Header({ user, setUser }) {
    return (
        <header>
            <Navigation user={user} setUser={setUser} />
        </header>
    );
}

// Livello 4: Navigation (non usa user, solo passa)
function Navigation({ user, setUser }) {
    return (
        <nav>
            <UserMenu user={user} setUser={setUser} />
        </nav>
    );
}

// Livello 5: UserMenu (FINALMENTE usa user!)
function UserMenu({ user, setUser }) {
    return (
        <div>
            <span>{user.name}</span>
            <button onClick={() => setUser({ ...user, theme: 'light' })}>
                Cambia tema
            </button>
        </div>
    );
}
\end{lstlisting}

\subsection{Soluzioni al Props Drilling}

\textbf{1. Component Composition}

\begin{lstlisting}[language=JavaScript, caption=Composizione invece di drilling]
// ✅ Passa il componente completo, non le props
function App() {
    const [user, setUser] = useState({
        name: 'Mario',
        theme: 'dark'
    });

    // Costruisci UserMenu qui, dove hai accesso a user
    const userMenu = <UserMenu user={user} setUser={setUser} />;

    return <Layout userMenu={userMenu} />;
}

function Layout({ userMenu }) {
    return (
        <div>
            <Header userMenu={userMenu} />
            <Main />
        </div>
    );
}

function Header({ userMenu }) {
    return (
        <header>
            <Navigation userMenu={userMenu} />
        </header>
    );
}

function Navigation({ userMenu }) {
    return (
        <nav>
            <Logo />
            {userMenu}  {/* Renderizza direttamente */}
        </nav>
    );
}

function UserMenu({ user, setUser }) {
    return (
        <div>
            <span>{user.name}</span>
            <button onClick={() => setUser({ ...user, theme: 'light' })}>
                Cambia tema
            </button>
        </div>
    );
}
\end{lstlisting}

\textbf{2. Context API}

\begin{lstlisting}[language=JavaScript, caption=Context per evitare drilling]
import { createContext, useContext, useState } from 'react';

// 1. Crea Context
const UserContext = createContext();

// 2. Provider nel componente root
function App() {
    const [user, setUser] = useState({
        name: 'Mario',
        theme: 'dark'
    });

    return (
        <UserContext.Provider value={{ user, setUser }}>
            <Layout />
        </UserContext.Provider>
    );
}

// 3. Componenti intermedi non hanno bisogno delle props
function Layout() {
    return (
        <div>
            <Header />
            <Main />
        </div>
    );
}

function Header() {
    return (
        <header>
            <Navigation />
        </header>
    );
}

function Navigation() {
    return (
        <nav>
            <Logo />
            <UserMenu />
        </nav>
    );
}

// 4. Consuma il context dove serve
function UserMenu() {
    const { user, setUser } = useContext(UserContext);

    return (
        <div>
            <span>{user.name}</span>
            <button onClick={() => setUser({ ...user, theme: 'light' })}>
                Cambia tema
            </button>
        </div>
    );
}
\end{lstlisting}

\textbf{3. Custom Hook per Context}

\begin{lstlisting}[language=JavaScript, caption=Custom hook per context]
// hooks/useUser.js
import { createContext, useContext, useState } from 'react';

const UserContext = createContext();

export function UserProvider({ children }) {
    const [user, setUser] = useState({
        name: 'Mario',
        theme: 'dark',
        language: 'it'
    });

    const updateUser = (updates) => {
        setUser(prev => ({ ...prev, ...updates }));
    };

    const toggleTheme = () => {
        setUser(prev => ({
            ...prev,
            theme: prev.theme === 'dark' ? 'light' : 'dark'
        }));
    };

    return (
        <UserContext.Provider value={{
            user,
            setUser,
            updateUser,
            toggleTheme
        }}>
            {children}
        </UserContext.Provider>
    );
}

export function useUser() {
    const context = useContext(UserContext);
    if (!context) {
        throw new Error('useUser must be used within UserProvider');
    }
    return context;
}

// App.jsx
import { UserProvider } from './hooks/useUser';

function App() {
    return (
        <UserProvider>
            <Layout />
        </UserProvider>
    );
}

// Qualsiasi componente
import { useUser } from './hooks/useUser';

function UserMenu() {
    const { user, toggleTheme } = useUser();

    return (
        <div>
            <span>{user.name}</span>
            <button onClick={toggleTheme}>
                Tema: {user.theme}
            </button>
        </div>
    );
}
\end{lstlisting}

\section{State Management}

Lo state è dati mutabili gestiti dal componente. Quando lo state cambia, React re-renderizza il componente.

\subsection{State Locale con useState}

\begin{lstlisting}[language=JavaScript, caption=useState base]
import { useState } from 'react';

function Counter() {
    // Dichiarazione state
    const [count, setCount] = useState(0);
    //     ^       ^             ^
    //     |       |             |
    //  valore  setter     valore iniziale

    // Aggiorna state
    const increment = () => {
        setCount(count + 1);
    };

    const decrement = () => {
        setCount(count - 1);
    };

    const reset = () => {
        setCount(0);
    };

    return (
        <div>
            <h1>Contatore: {count}</h1>
            <button onClick={decrement}>-</button>
            <button onClick={reset}>Reset</button>
            <button onClick={increment}>+</button>
        </div>
    );
}
\end{lstlisting}

\subsection{State con Oggetti}

\begin{lstlisting}[language=JavaScript, caption=State oggetto]
function UserForm() {
    const [user, setUser] = useState({
        firstName: '',
        lastName: '',
        email: '',
        age: ''
    });

    // ❌ SBAGLIATO: Muta direttamente lo state
    const handleChangeBad = (field, value) => {
        user[field] = value; // NO!
        setUser(user);       // React non rileva il cambiamento
    };

    // ✅ CORRETTO: Crea nuovo oggetto
    const handleChange = (field, value) => {
        setUser({
            ...user,           // Copia proprietà esistenti
            [field]: value     // Sovrascrivi campo specifico
        });
    };

    // ✅ Alternativa con funzione updater
    const handleChangeUpdater = (field, value) => {
        setUser(prevUser => ({
            ...prevUser,
            [field]: value
        }));
    };

    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('User data:', user);
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="text"
                value={user.firstName}
                onChange={(e) => handleChange('firstName', e.target.value)}
                placeholder="Nome"
            />
            <input
                type="text"
                value={user.lastName}
                onChange={(e) => handleChange('lastName', e.target.value)}
                placeholder="Cognome"
            />
            <input
                type="email"
                value={user.email}
                onChange={(e) => handleChange('email', e.target.value)}
                placeholder="Email"
            />
            <input
                type="number"
                value={user.age}
                onChange={(e) => handleChange('age', e.target.value)}
                placeholder="Età"
            />
            <button type="submit">Invia</button>

            {/* Preview dati */}
            <pre>{JSON.stringify(user, null, 2)}</pre>
        </form>
    );
}
\end{lstlisting}

\subsection{State con Array}

\begin{lstlisting}[language=JavaScript, caption=State array]
function TodoList() {
    const [todos, setTodos] = useState([
        { id: 1, text: 'Imparare React', completed: false },
        { id: 2, text: 'Costruire app', completed: false }
    ]);

    // Aggiungi elemento
    const addTodo = (text) => {
        const newTodo = {
            id: Date.now(),
            text,
            completed: false
        };

        // ❌ SBAGLIATO
        // todos.push(newTodo);
        // setTodos(todos);

        // ✅ CORRETTO
        setTodos([...todos, newTodo]);
        // oppure
        setTodos(prevTodos => [...prevTodos, newTodo]);
    };

    // Rimuovi elemento
    const deleteTodo = (id) => {
        // ✅ Filter crea nuovo array
        setTodos(todos.filter(todo => todo.id !== id));
    };

    // Aggiorna elemento
    const toggleTodo = (id) => {
        // ✅ Map crea nuovo array
        setTodos(todos.map(todo =>
            todo.id === id
                ? { ...todo, completed: !todo.completed }
                : todo
        ));
    };

    // Aggiorna elemento con indice
    const updateTodoAtIndex = (index, newText) => {
        setTodos(todos.map((todo, i) =>
            i === index
                ? { ...todo, text: newText }
                : todo
        ));
    };

    // Inserisci elemento a inizio
    const prependTodo = (text) => {
        const newTodo = { id: Date.now(), text, completed: false };
        setTodos([newTodo, ...todos]);
    };

    // Ordina array
    const sortTodos = () => {
        setTodos([...todos].sort((a, b) =>
            a.text.localeCompare(b.text)
        ));
    };

    // Rimuovi tutti completati
    const clearCompleted = () => {
        setTodos(todos.filter(todo => !todo.completed));
    };

    return (
        <div>
            {/* UI componenti... */}
        </div>
    );
}
\end{lstlisting}

\subsection{Multiple State Updates}

\begin{lstlisting}[language=JavaScript, caption=Aggiornamenti multipli]
function ShoppingCart() {
    const [items, setItems] = useState([]);
    const [total, setTotal] = useState(0);
    const [discount, setDiscount] = useState(0);

    // ❌ Problema: Usa state precedente
    const addItem = (item) => {
        setItems([...items, item]);
        setTotal(total + item.price); // total potrebbe essere stale
    };

    // ✅ Usa funzione updater per accesso allo state più recente
    const addItemCorrect = (item) => {
        setItems(prevItems => [...prevItems, item]);
        setTotal(prevTotal => prevTotal + item.price);
    };

    // ✅ Aggiornamenti batch automatici in React 18+
    const handleCheckout = () => {
        setItems([]);
        setTotal(0);
        setDiscount(0);
        // Tutti e tre gli aggiornamenti causano un solo re-render
    };

    // Calcola totale da items (computed value)
    const calculatedTotal = items.reduce((sum, item) => sum + item.price, 0);
    const finalTotal = calculatedTotal - discount;

    return (
        <div>
            <p>Items: {items.length}</p>
            <p>Totale: €{finalTotal}</p>
        </div>
    );
}
\end{lstlisting}

\subsection{Lifting State Up}

Quando più componenti devono condividere lo stesso state, "alza" lo state al parent comune.

\begin{lstlisting}[language=JavaScript, caption=Lifting state up]
// ❌ State duplicato in componenti separati
function TemperatureInput() {
    const [temperature, setTemperature] = useState('');
    return <input value={temperature} onChange={e => setTemperature(e.target.value)} />;
}

function App() {
    return (
        <div>
            <TemperatureInput /> {/* Celsius */}
            <TemperatureInput /> {/* Fahrenheit */}
            {/* I due input non sono sincronizzati! */}
        </div>
    );
}

// ✅ State condiviso nel parent
function TemperatureInput({ scale, temperature, onTemperatureChange }) {
    const handleChange = (e) => {
        onTemperatureChange(e.target.value);
    };

    const scaleNames = {
        c: 'Celsius',
        f: 'Fahrenheit'
    };

    return (
        <fieldset>
            <legend>Temperatura in {scaleNames[scale]}:</legend>
            <input value={temperature} onChange={handleChange} />
        </fieldset>
    );
}

function App() {
    const [temperature, setTemperature] = useState('');
    const [scale, setScale] = useState('c');

    const handleCelsiusChange = (temp) => {
        setScale('c');
        setTemperature(temp);
    };

    const handleFahrenheitChange = (temp) => {
        setScale('f');
        setTemperature(temp);
    };

    // Conversioni
    const celsius = scale === 'f'
        ? ((temperature - 32) * 5 / 9).toFixed(1)
        : temperature;

    const fahrenheit = scale === 'c'
        ? (temperature * 9 / 5 + 32).toFixed(1)
        : temperature;

    return (
        <div>
            <TemperatureInput
                scale="c"
                temperature={celsius}
                onTemperatureChange={handleCelsiusChange}
            />
            <TemperatureInput
                scale="f"
                temperature={fahrenheit}
                onTemperatureChange={handleFahrenheitChange}
            />
            <BoilingVerdict celsius={parseFloat(celsius)} />
        </div>
    );
}

function BoilingVerdict({ celsius }) {
    if (celsius >= 100) {
        return <p>L'acqua bollirebbe.</p>;
    }
    return <p>L'acqua non bollirebbe.</p>;
}
\end{lstlisting}

\section{Controlled Components}

Un controlled component è un elemento form il cui valore è controllato da React state.

\subsection{Input Controllati}

\begin{lstlisting}[language=JavaScript, caption=Controlled input]
function ControlledInput() {
    const [value, setValue] = useState('');

    // ✅ Controlled: React controlla il valore
    return (
        <div>
            <input
                type="text"
                value={value}
                onChange={(e) => setValue(e.target.value)}
            />
            <p>Valore: {value}</p>
        </div>
    );

    // ❌ Uncontrolled: DOM controlla il valore
    // return <input type="text" />;
}
\end{lstlisting}

\subsection{Form Completo Controllato}

\begin{lstlisting}[language=JavaScript, caption=Form completamente controllato]
function RegistrationForm() {
    const [formData, setFormData] = useState({
        username: '',
        email: '',
        password: '',
        confirmPassword: '',
        age: '',
        country: '',
        terms: false,
        newsletter: false,
        gender: '',
        interests: []
    });

    const [errors, setErrors] = useState({});

    // Handler generico per input text/email/password/number
    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };

    // Handler per checkbox
    const handleCheckboxChange = (e) => {
        const { name, checked } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: checked
        }));
    };

    // Handler per checkbox multipli (interests)
    const handleInterestChange = (interest) => {
        setFormData(prev => ({
            ...prev,
            interests: prev.interests.includes(interest)
                ? prev.interests.filter(i => i !== interest)
                : [...prev.interests, interest]
        }));
    };

    // Validazione
    const validate = () => {
        const newErrors = {};

        if (!formData.username) {
            newErrors.username = 'Username richiesto';
        } else if (formData.username.length < 3) {
            newErrors.username = 'Username troppo corto';
        }

        if (!formData.email) {
            newErrors.email = 'Email richiesta';
        } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
            newErrors.email = 'Email non valida';
        }

        if (!formData.password) {
            newErrors.password = 'Password richiesta';
        } else if (formData.password.length < 8) {
            newErrors.password = 'Password troppo corta (min 8 caratteri)';
        }

        if (formData.password !== formData.confirmPassword) {
            newErrors.confirmPassword = 'Le password non coincidono';
        }

        if (!formData.terms) {
            newErrors.terms = 'Devi accettare i termini';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleSubmit = (e) => {
        e.preventDefault();

        if (validate()) {
            console.log('Form valido:', formData);
            // Invia dati al server...
        } else {
            console.log('Form non valido:', errors);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            {/* Text Input */}
            <div>
                <label htmlFor="username">Username:</label>
                <input
                    id="username"
                    type="text"
                    name="username"
                    value={formData.username}
                    onChange={handleInputChange}
                />
                {errors.username && <span className="error">{errors.username}</span>}
            </div>

            {/* Email Input */}
            <div>
                <label htmlFor="email">Email:</label>
                <input
                    id="email"
                    type="email"
                    name="email"
                    value={formData.email}
                    onChange={handleInputChange}
                />
                {errors.email && <span className="error">{errors.email}</span>}
            </div>

            {/* Password Input */}
            <div>
                <label htmlFor="password">Password:</label>
                <input
                    id="password"
                    type="password"
                    name="password"
                    value={formData.password}
                    onChange={handleInputChange}
                />
                {errors.password && <span className="error">{errors.password}</span>}
            </div>

            {/* Confirm Password */}
            <div>
                <label htmlFor="confirmPassword">Conferma Password:</label>
                <input
                    id="confirmPassword"
                    type="password"
                    name="confirmPassword"
                    value={formData.confirmPassword}
                    onChange={handleInputChange}
                />
                {errors.confirmPassword && <span className="error">{errors.confirmPassword}</span>}
            </div>

            {/* Number Input */}
            <div>
                <label htmlFor="age">Età:</label>
                <input
                    id="age"
                    type="number"
                    name="age"
                    value={formData.age}
                    onChange={handleInputChange}
                    min="18"
                    max="120"
                />
            </div>

            {/* Select */}
            <div>
                <label htmlFor="country">Paese:</label>
                <select
                    id="country"
                    name="country"
                    value={formData.country}
                    onChange={handleInputChange}
                >
                    <option value="">Seleziona...</option>
                    <option value="IT">Italia</option>
                    <option value="US">USA</option>
                    <option value="UK">UK</option>
                </select>
            </div>

            {/* Radio Buttons */}
            <div>
                <label>Genere:</label>
                <label>
                    <input
                        type="radio"
                        name="gender"
                        value="male"
                        checked={formData.gender === 'male'}
                        onChange={handleInputChange}
                    />
                    Maschio
                </label>
                <label>
                    <input
                        type="radio"
                        name="gender"
                        value="female"
                        checked={formData.gender === 'female'}
                        onChange={handleInputChange}
                    />
                    Femmina
                </label>
                <label>
                    <input
                        type="radio"
                        name="gender"
                        value="other"
                        checked={formData.gender === 'other'}
                        onChange={handleInputChange}
                    />
                    Altro
                </label>
            </div>

            {/* Checkboxes Multiple */}
            <div>
                <label>Interessi:</label>
                {['Sport', 'Musica', 'Lettura', 'Viaggi'].map(interest => (
                    <label key={interest}>
                        <input
                            type="checkbox"
                            checked={formData.interests.includes(interest)}
                            onChange={() => handleInterestChange(interest)}
                        />
                        {interest}
                    </label>
                ))}
            </div>

            {/* Checkbox Singola */}
            <div>
                <label>
                    <input
                        type="checkbox"
                        name="terms"
                        checked={formData.terms}
                        onChange={handleCheckboxChange}
                    />
                    Accetto i termini e condizioni
                </label>
                {errors.terms && <span className="error">{errors.terms}</span>}
            </div>

            <div>
                <label>
                    <input
                        type="checkbox"
                        name="newsletter"
                        checked={formData.newsletter}
                        onChange={handleCheckboxChange}
                    />
                    Iscriviti alla newsletter
                </label>
            </div>

            {/* Submit */}
            <button type="submit">Registrati</button>

            {/* Debug */}
            <pre>{JSON.stringify(formData, null, 2)}</pre>
        </form>
    );
}
\end{lstlisting}

\subsection{Controlled vs Uncontrolled}

\begin{lstlisting}[language=JavaScript, caption=Controlled vs Uncontrolled]
import { useRef } from 'react';

function ComparisonExample() {
    // Controlled
    const [controlledValue, setControlledValue] = useState('');

    // Uncontrolled
    const uncontrolledRef = useRef();

    const handleControlledSubmit = (e) => {
        e.preventDefault();
        console.log('Controlled:', controlledValue);
    };

    const handleUncontrolledSubmit = (e) => {
        e.preventDefault();
        console.log('Uncontrolled:', uncontrolledRef.current.value);
    };

    return (
        <div>
            {/* Controlled Input */}
            <form onSubmit={handleControlledSubmit}>
                <h3>Controlled</h3>
                <input
                    type="text"
                    value={controlledValue}
                    onChange={(e) => setControlledValue(e.target.value)}
                />
                <button type="submit">Invia</button>
                <p>Live value: {controlledValue}</p>
            </form>

            {/* Uncontrolled Input */}
            <form onSubmit={handleUncontrolledSubmit}>
                <h3>Uncontrolled</h3>
                <input
                    type="text"
                    ref={uncontrolledRef}
                    defaultValue="Initial"
                />
                <button type="submit">Invia</button>
                <p>Value disponibile solo al submit</p>
            </form>
        </div>
    );
}

// Quando usare controlled vs uncontrolled:

// ✅ Usa CONTROLLED quando:
// - Hai bisogno di validazione in tempo reale
// - Vuoi formattare l'input mentre digiti
// - Devi disabilitare il submit in base all'input
// - Hai input dipendenti tra loro
// - Vuoi mostrare l'input in tempo reale

// ✅ Usa UNCONTROLLED quando:
// - Form molto grandi con molti campi
// - Integri con librerie non-React
// - Performance critiche
// - File uploads
// - Semplicemente leggi il valore al submit
\end{lstlisting}

\section{State Management Patterns}

\subsection{Single Source of Truth}

\begin{lstlisting}[language=JavaScript, caption=Single source of truth]
function ShoppingApp() {
    // ✅ State centralizzato
    const [cart, setCart] = useState({
        items: [],
        total: 0,
        itemCount: 0
    });

    // Computed values derivati dallo state
    const subtotal = cart.items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const tax = subtotal * 0.22;
    const total = subtotal + tax;

    const addItem = (product) => {
        setCart(prev => {
            const existingItem = prev.items.find(item => item.id === product.id);

            if (existingItem) {
                // Incrementa quantità
                return {
                    ...prev,
                    items: prev.items.map(item =>
                        item.id === product.id
                            ? { ...item, quantity: item.quantity + 1 }
                            : item
                    )
                };
            } else {
                // Aggiungi nuovo item
                return {
                    ...prev,
                    items: [...prev.items, { ...product, quantity: 1 }]
                };
            }
        });
    };

    return (
        <div>
            <ProductList onAddToCart={addItem} />
            <Cart
                items={cart.items}
                subtotal={subtotal}
                tax={tax}
                total={total}
            />
        </div>
    );
}
\end{lstlisting}

\subsection{Derived State (Computed Values)}

\begin{lstlisting}[language=JavaScript, caption=Evita state ridondante]
function UserList() {
    const [users, setUsers] = useState([...]);
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState('name');

    // ❌ SBAGLIATO: State ridondante
    // const [filteredUsers, setFilteredUsers] = useState([]);
    // const [sortedUsers, setSortedUsers] = useState([]);

    // ✅ CORRETTO: Calcola al render
    const filteredUsers = users.filter(user =>
        user.name.toLowerCase().includes(searchQuery.toLowerCase())
    );

    const sortedUsers = [...filteredUsers].sort((a, b) => {
        if (sortBy === 'name') return a.name.localeCompare(b.name);
        if (sortBy === 'age') return a.age - b.age;
        return 0;
    });

    return (
        <div>
            <input
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                placeholder="Cerca..."
            />
            <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                <option value="name">Nome</option>
                <option value="age">Età</option>
            </select>

            <ul>
                {sortedUsers.map(user => (
                    <li key={user.id}>{user.name} - {user.age}</li>
                ))}
            </ul>
        </div>
    );
}
\end{lstlisting}

\subsection{State Reducer Pattern}

\begin{lstlisting}[language=JavaScript, caption=Pattern reducer per state complesso]
import { useReducer } from 'react';

// Reducer function
function cartReducer(state, action) {
    switch (action.type) {
        case 'ADD_ITEM':
            const existingIndex = state.items.findIndex(
                item => item.id === action.payload.id
            );

            if (existingIndex >= 0) {
                const newItems = [...state.items];
                newItems[existingIndex].quantity += 1;
                return { ...state, items: newItems };
            }

            return {
                ...state,
                items: [...state.items, { ...action.payload, quantity: 1 }]
            };

        case 'REMOVE_ITEM':
            return {
                ...state,
                items: state.items.filter(item => item.id !== action.payload)
            };

        case 'UPDATE_QUANTITY':
            return {
                ...state,
                items: state.items.map(item =>
                    item.id === action.payload.id
                        ? { ...item, quantity: action.payload.quantity }
                        : item
                )
            };

        case 'CLEAR_CART':
            return { ...state, items: [] };

        default:
            return state;
    }
}

function ShoppingCart() {
    const [state, dispatch] = useReducer(cartReducer, { items: [] });

    const addItem = (product) => {
        dispatch({ type: 'ADD_ITEM', payload: product });
    };

    const removeItem = (id) => {
        dispatch({ type: 'REMOVE_ITEM', payload: id });
    };

    const updateQuantity = (id, quantity) => {
        dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
    };

    const clearCart = () => {
        dispatch({ type: 'CLEAR_CART' });
    };

    return (
        <div>
            {/* UI usando dispatch */}
        </div>
    );
}
\end{lstlisting}

\section{Best Practices}

\subsection{1. Mantieni State Minimo}

\begin{lstlisting}[language=JavaScript, caption=State minimo necessario]
// ❌ State ridondante
function BadExample() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [fullName, setFullName] = useState(''); // Ridondante!

    const handleFirstNameChange = (name) => {
        setFirstName(name);
        setFullName(`${name} ${lastName}`); // Duplicazione logica
    };
}

// ✅ Calcola fullName
function GoodExample() {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');

    // Computed value
    const fullName = `${firstName} ${lastName}`.trim();

    return <h1>{fullName}</h1>;
}
\end{lstlisting}

\subsection{2. Normalizza State Complesso}

\begin{lstlisting}[language=JavaScript, caption=Normalizzazione state]
// ❌ State denormalizzato
const [data, setData] = useState({
    posts: [
        {
            id: 1,
            title: 'Post 1',
            author: { id: 10, name: 'Mario' },
            comments: [
                { id: 100, text: 'Comment 1', author: { id: 10, name: 'Mario' } }
            ]
        }
    ]
});

// ✅ State normalizzato
const [data, setData] = useState({
    posts: {
        1: { id: 1, title: 'Post 1', authorId: 10, commentIds: [100] }
    },
    users: {
        10: { id: 10, name: 'Mario' }
    },
    comments: {
        100: { id: 100, text: 'Comment 1', authorId: 10 }
    }
});
\end{lstlisting}

\subsection{3. Usa Funzione Updater}

\begin{lstlisting}[language=JavaScript, caption=Updater function]
// ❌ Può causare problemi
const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1); // Usa lo stesso valore di count!
    // count aumenta solo di 1, non 2
};

// ✅ Usa updater function
const handleClick = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    // count aumenta di 2
};
\end{lstlisting}

\section{Conclusione}

In questo capitolo abbiamo esplorato:

\begin{itemize}
    \item Props immutabili e tipi di props
    \item Props drilling e soluzioni
    \item State management con useState
    \item Controlled components per form
    \item Patterns di state management
    \item Best practices per props e state
\end{itemize}

Nel prossimo capitolo approfondiremo gli Hooks di React!
