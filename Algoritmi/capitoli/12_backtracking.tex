\chapter{Backtracking Avanzato}
\label{cap:backtracking}

\section{Introduzione}

Il \textbf{backtracking} è una tecnica generale per trovare soluzioni a problemi di ricerca combinatoria costruendo incrementalmente candidati e abbandonando quelli che non possono portare a soluzioni valide.

\subsection{Schema Generale}

\begin{algorithm}
\caption{Backtracking Template}
\begin{algorithmic}[1]
\Procedure{Backtrack}{$solution, data$}
    \If{\Call{IsComplete}{$solution$}}
        \State \Call{ProcessSolution}{$solution$}
        \State \Return
    \EndIf
    \For{ogni $candidate$ in \Call{GetCandidates}{$solution, data$}}
        \If{\Call{IsValid}{$solution, candidate$}}
            \State \Call{Add}{$solution, candidate$}
            \State \Call{Backtrack}{$solution, data$}
            \State \Call{Remove}{$solution, candidate$} \Comment{Backtrack!}
        \EndIf
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Componenti Chiave}

\begin{enumerate}
    \item \textbf{Scelta}: selezionare un candidato da aggiungere alla soluzione parziale
    \item \textbf{Vincoli}: verificare se la scelta è valida
    \item \textbf{Obiettivo}: determinare se la soluzione è completa
    \item \textbf{Backtrack}: annullare la scelta e provare alternative
\end{enumerate}

\subsection{Ottimizzazioni}

\begin{itemize}
    \item \textbf{Pruning}: tagliare rami che sicuramente non portano a soluzioni
    \item \textbf{Constraint propagation}: dedurre vincoli da scelte precedenti
    \item \textbf{Heuristics}: ordinare le scelte per esplorare prima i rami promettenti
    \item \textbf{Memoization}: evitare di ricalcolare sottoproblemi identici
\end{itemize}

\section{N-Queens Problem}

\subsection{Definizione}

Posizionare $N$ regine su una scacchiera $N \times N$ in modo che nessuna regina minacci un'altra.

\textbf{Vincoli}: Due regine non possono essere:
\begin{itemize}
    \item Sulla stessa riga
    \item Sulla stessa colonna
    \item Sulla stessa diagonale
\end{itemize}

\subsection{Rappresentazione}

Usiamo un array \texttt{queens[i]} che indica la colonna della regina nella riga $i$.

\subsection{Verifica Validità}

Due regine in posizioni $(r_1, c_1)$ e $(r_2, c_2)$ si minacciano se:
\begin{itemize}
    \item $r_1 = r_2$ (stessa riga)
    \item $c_1 = c_2$ (stessa colonna)
    \item $|r_1 - r_2| = |c_1 - c_2|$ (stessa diagonale)
\end{itemize}

\subsection{Pseudocodice}

\begin{algorithm}
\caption{N-Queens}
\begin{algorithmic}[1]
\Procedure{SolveNQueens}{$n$}
    \State $queens \gets$ array di dimensione $n$
    \State \Call{PlaceQueens}{$queens, 0, n$}
\EndProcedure
\State
\Procedure{PlaceQueens}{$queens, row, n$}
    \If{$row = n$}
        \State \Call{PrintSolution}{$queens$}
        \State \Return
    \EndIf
    \For{$col \gets 0$ \To $n-1$}
        \If{\Call{IsSafe}{$queens, row, col$}}
            \State $queens[row] \gets col$
            \State \Call{PlaceQueens}{$queens, row+1, n$}
            \State $queens[row] \gets -1$ \Comment{Backtrack}
        \EndIf
    \EndFor
\EndProcedure
\State
\Procedure{IsSafe}{$queens, row, col$}
    \For{$i \gets 0$ \To $row-1$}
        \State $other\_col \gets queens[i]$
        \If{$other\_col = col$}
            \State \Return \False \Comment{Stessa colonna}
        \EndIf
        \If{$|row - i| = |col - other\_col|$}
            \State \Return \False \Comment{Stessa diagonale}
        \EndIf
    \EndFor
    \State \Return \True
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Analisi di Complessità}

\paragraph{Caso peggiore:} $O(N!)$ - dobbiamo esplorare tutte le permutazioni nel peggiore dei casi.

\paragraph{In pratica:} Il pruning riduce drasticamente lo spazio di ricerca. Per $N=8$, solo $\sim 2000$ nodi invece di $8! = 40320$.

\subsection{Implementazioni Python}

\begin{lstlisting}[language=Python]
def solve_n_queens(n):
    """
    Risolve il problema delle N regine.

    Args:
        n: dimensione della scacchiera

    Returns:
        lista di tutte le soluzioni

    Complessita: O(N!) worst case
    """
    solutions = []

    def is_safe(queens, row, col):
        """Verifica se posizionare regina in (row, col) e sicuro."""
        for i in range(row):
            other_col = queens[i]

            # Stessa colonna
            if other_col == col:
                return False

            # Stessa diagonale
            if abs(row - i) == abs(col - other_col):
                return False

        return True

    def backtrack(row, queens):
        """Piazza regine riga per riga."""
        if row == n:
            # Soluzione completa
            solutions.append(queens[:])
            return

        for col in range(n):
            if is_safe(queens, row, col):
                queens[row] = col
                backtrack(row + 1, queens)
                queens[row] = -1  # Backtrack

    backtrack(0, [-1] * n)
    return solutions


def print_board(queens):
    """Stampa la scacchiera con le regine."""
    n = len(queens)
    for row in range(n):
        line = []
        for col in range(n):
            if queens[row] == col:
                line.append('Q')
            else:
                line.append('.')
        print(' '.join(line))
    print()


# Versione ottimizzata con set per controlli O(1)
def solve_n_queens_optimized(n):
    """
    Versione ottimizzata con set per tracking.
    """
    solutions = []

    def backtrack(row, queens, cols, diag1, diag2):
        """
        cols: colonne occupate
        diag1: diagonali \ occupate (row - col)
        diag2: diagonali / occupate (row + col)
        """
        if row == n:
            solutions.append(queens[:])
            return

        for col in range(n):
            # Calcola identificatori diagonali
            d1 = row - col
            d2 = row + col

            # Verifica se la posizione e sicura
            if col in cols or d1 in diag1 or d2 in diag2:
                continue

            # Piazza regina
            queens[row] = col
            cols.add(col)
            diag1.add(d1)
            diag2.add(d2)

            # Ricorsione
            backtrack(row + 1, queens, cols, diag1, diag2)

            # Backtrack
            queens[row] = -1
            cols.remove(col)
            diag1.remove(d1)
            diag2.remove(d2)

    backtrack(0, [-1] * n, set(), set(), set())
    return solutions


# Test
solutions = solve_n_queens_optimized(8)
print(f"Numero di soluzioni per 8-Queens: {len(solutions)}")
# Output: 92

print("\nPrima soluzione:")
print_board(solutions[0])
\end{lstlisting}

\subsection{Variante: Count Solutions}

Se serve solo il conteggio, non serve salvare tutte le soluzioni:

\begin{lstlisting}[language=Python]
def count_n_queens(n):
    """
    Conta solo il numero di soluzioni.
    Piu efficiente in memoria.
    """
    count = [0]  # Usa lista per mutabilita

    def backtrack(row, cols, diag1, diag2):
        if row == n:
            count[0] += 1
            return

        for col in range(n):
            d1, d2 = row - col, row + col

            if col not in cols and d1 not in diag1 and d2 not in diag2:
                backtrack(row + 1,
                         cols | {col},
                         diag1 | {d1},
                         diag2 | {d2})

    backtrack(0, set(), set(), set())
    return count[0]
\end{lstlisting}

\section{Sudoku Solver}

\subsection{Definizione}

Riempire una griglia $9 \times 9$ con cifre da 1 a 9 rispettando i vincoli:
\begin{itemize}
    \item Ogni riga contiene ogni cifra esattamente una volta
    \item Ogni colonna contiene ogni cifra esattamente una volta
    \item Ogni sottgriglia $3 \times 3$ contiene ogni cifra esattamente una volta
\end{itemize}

\subsection{Strategia}

\begin{enumerate}
    \item Trova una cella vuota
    \item Prova ogni cifra da 1 a 9
    \item Se la cifra è valida, inseriscila e ricorri
    \item Se la ricorsione fallisce, backtrack e prova la prossima cifra
    \item Se nessuna cifra funziona, ritorna False
\end{enumerate}

\subsection{Pseudocodice}

\begin{algorithm}
\caption{Sudoku Solver}
\begin{algorithmic}[1]
\Procedure{SolveSudoku}{$board$}
    \State $(row, col) \gets$ \Call{FindEmptyCell}{$board$}
    \If{$(row, col) = \text{None}$}
        \State \Return \True \Comment{Risolto!}
    \EndIf
    \For{$num \gets 1$ \To $9$}
        \If{\Call{IsValid}{$board, row, col, num$}}
            \State $board[row][col] \gets num$
            \If{\Call{SolveSudoku}{$board$}}
                \State \Return \True
            \EndIf
            \State $board[row][col] \gets 0$ \Comment{Backtrack}
        \EndIf
    \EndFor
    \State \Return \False
\EndProcedure
\State
\Procedure{IsValid}{$board, row, col, num$}
    \For{$i \gets 0$ \To $8$}
        \If{$board[row][i] = num$}
            \State \Return \False \Comment{In riga}
        \EndIf
        \If{$board[i][col] = num$}
            \State \Return \False \Comment{In colonna}
        \EndIf
    \EndFor
    \State $box\_row \gets 3 \times \lfloor row/3 \rfloor$
    \State $box\_col \gets 3 \times \lfloor col/3 \rfloor$
    \For{$i \gets 0$ \To $2$}
        \For{$j \gets 0$ \To $2$}
            \If{$board[box\_row + i][box\_col + j] = num$}
                \State \Return \False \Comment{In box 3x3}
            \EndIf
        \EndFor
    \EndFor
    \State \Return \True
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Implementazione Python}

\begin{lstlisting}[language=Python]
def solve_sudoku(board):
    """
    Risolve un Sudoku 9x9.

    Args:
        board: matrice 9x9 con 0 per celle vuote

    Returns:
        True se risolto, False se impossibile

    Complessita: O(9^m) dove m = numero celle vuote
    """
    def is_valid(row, col, num):
        """Verifica se num e valido in (row, col)."""
        # Controlla riga
        if num in board[row]:
            return False

        # Controlla colonna
        if num in [board[i][col] for i in range(9)]:
            return False

        # Controlla box 3x3
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False

        return True

    def find_empty():
        """Trova prossima cella vuota."""
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    return i, j
        return None

    def backtrack():
        """Risolve con backtracking."""
        cell = find_empty()
        if cell is None:
            return True  # Risolto!

        row, col = cell

        for num in range(1, 10):
            if is_valid(row, col, num):
                board[row][col] = num

                if backtrack():
                    return True

                # Backtrack
                board[row][col] = 0

        return False

    backtrack()
    return board


# Versione ottimizzata con constraint tracking
def solve_sudoku_optimized(board):
    """
    Versione ottimizzata con tracking di possibilita.
    """
    # Track numeri disponibili per riga/col/box
    rows = [set(range(1, 10)) for _ in range(9)]
    cols = [set(range(1, 10)) for _ in range(9)]
    boxes = [set(range(1, 10)) for _ in range(9)]

    # Inizializza constraint sets
    empty_cells = []
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                empty_cells.append((i, j))
            else:
                num = board[i][j]
                rows[i].discard(num)
                cols[j].discard(num)
                box_idx = (i // 3) * 3 + (j // 3)
                boxes[box_idx].discard(num)

    def backtrack(idx):
        if idx == len(empty_cells):
            return True

        row, col = empty_cells[idx]
        box_idx = (row // 3) * 3 + (col // 3)

        # Intersezione: numeri validi
        possible = rows[row] & cols[col] & boxes[box_idx]

        for num in possible:
            # Piazza numero
            board[row][col] = num
            rows[row].discard(num)
            cols[col].discard(num)
            boxes[box_idx].discard(num)

            if backtrack(idx + 1):
                return True

            # Backtrack
            board[row][col] = 0
            rows[row].add(num)
            cols[col].add(num)
            boxes[box_idx].add(num)

        return False

    backtrack(0)
    return board


# Esempio
sudoku = [
    [5, 3, 0, 0, 7, 0, 0, 0, 0],
    [6, 0, 0, 1, 9, 5, 0, 0, 0],
    [0, 9, 8, 0, 0, 0, 0, 6, 0],
    [8, 0, 0, 0, 6, 0, 0, 0, 3],
    [4, 0, 0, 8, 0, 3, 0, 0, 1],
    [7, 0, 0, 0, 2, 0, 0, 0, 6],
    [0, 6, 0, 0, 0, 0, 2, 8, 0],
    [0, 0, 0, 4, 1, 9, 0, 0, 5],
    [0, 0, 0, 0, 8, 0, 0, 7, 9]
]

solution = solve_sudoku_optimized([row[:] for row in sudoku])
for row in solution:
    print(row)
\end{lstlisting}

\subsection{Ottimizzazione: MRV Heuristic}

\textbf{Minimum Remaining Values}: Scegli la cella con meno valori possibili.

\begin{lstlisting}[language=Python]
def solve_sudoku_mrv(board):
    """
    Sudoku solver con euristica MRV.
    Sceglie la cella con meno possibilita.
    """
    def get_candidates(row, col):
        """Ritorna numeri possibili per (row, col)."""
        if board[row][col] != 0:
            return set()

        candidates = set(range(1, 10))

        # Rimuovi numeri in riga
        candidates -= set(board[row])

        # Rimuovi numeri in colonna
        candidates -= {board[i][col] for i in range(9)}

        # Rimuovi numeri in box
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                candidates.discard(board[i][j])

        return candidates

    def find_best_cell():
        """Trova cella con minimo numero di candidati (MRV)."""
        min_candidates = 10
        best_cell = None

        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    candidates = get_candidates(i, j)
                    if len(candidates) < min_candidates:
                        min_candidates = len(candidates)
                        best_cell = (i, j, candidates)
                        if min_candidates == 0:
                            return best_cell

        return best_cell

    def backtrack():
        result = find_best_cell()
        if result is None:
            return True  # Completato

        row, col, candidates = result

        if not candidates:
            return False  # Nessuna soluzione

        for num in candidates:
            board[row][col] = num

            if backtrack():
                return True

            board[row][col] = 0

        return False

    backtrack()
    return board
\end{lstlisting}

\section{Graph Coloring}

\subsection{Definizione}

Assegnare colori ai vertici di un grafo in modo che vertici adiacenti abbiano colori diversi, usando il minimo numero di colori.

\subsection{Problema Decisionale}

Dato un grafo $G$ e un intero $k$, è possibile colorare $G$ con al massimo $k$ colori?

\subsection{Pseudocodice}

\begin{algorithm}
\caption{Graph Coloring}
\begin{algorithmic}[1]
\Procedure{GraphColoring}{$graph, k$}
    \State $colors \gets$ array di dimensione $|V|$ inizializzato a $-1$
    \State \Return \Call{ColorVertex}{$graph, colors, 0, k$}
\EndProcedure
\State
\Procedure{ColorVertex}{$graph, colors, v, k$}
    \If{$v = |V|$}
        \State \Return \True \Comment{Tutti i vertici colorati}
    \EndIf
    \For{$c \gets 0$ \To $k-1$}
        \If{\Call{IsSafeColor}{$graph, colors, v, c$}}
            \State $colors[v] \gets c$
            \If{\Call{ColorVertex}{$graph, colors, v+1, k$}}
                \State \Return \True
            \EndIf
            \State $colors[v] \gets -1$ \Comment{Backtrack}
        \EndIf
    \EndFor
    \State \Return \False
\EndProcedure
\State
\Procedure{IsSafeColor}{$graph, colors, v, c$}
    \For{ogni vicino $u$ di $v$}
        \If{$colors[u] = c$}
            \State \Return \False
        \EndIf
    \EndFor
    \State \Return \True
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Implementazioni Python}

\begin{lstlisting}[language=Python]
def graph_coloring(graph, k):
    """
    Colora grafo con al massimo k colori.

    Args:
        graph: dict {vertex: [neighbors]}
        k: numero massimo di colori

    Returns:
        dict {vertex: color} se possibile, None altrimenti

    Complessita: O(k^n) worst case
    """
    n = len(graph)
    colors = {}

    def is_safe(vertex, color):
        """Verifica se color e valido per vertex."""
        for neighbor in graph.get(vertex, []):
            if colors.get(neighbor) == color:
                return False
        return True

    def backtrack(vertices):
        """Colora vertici ricorsivamente."""
        if not vertices:
            return True  # Tutti colorati

        vertex = vertices[0]
        remaining = vertices[1:]

        for color in range(k):
            if is_safe(vertex, color):
                colors[vertex] = color

                if backtrack(remaining):
                    return True

                del colors[vertex]  # Backtrack

        return False

    vertices = list(graph.keys())
    if backtrack(vertices):
        return colors
    return None


# Esempio: Grafo con 4 vertici
graph = {
    0: [1, 2, 3],
    1: [0, 2],
    2: [0, 1, 3],
    3: [0, 2]
}

coloring = graph_coloring(graph, 3)
print(f"Colorazione: {coloring}")
# Output: {0: 0, 1: 1, 2: 2, 3: 1}


def chromatic_number(graph):
    """
    Trova il numero cromatico (minimo numero di colori).
    """
    n = len(graph)

    # Prova da 1 a n colori
    for k in range(1, n + 1):
        if graph_coloring(graph, k):
            return k

    return n


# Versione con ordinamento dei vertici (euristica)
def graph_coloring_optimized(graph, k):
    """
    Versione con euristica: colora prima vertici con piu vicini.
    """
    colors = {}

    # Ordina vertici per grado decrescente
    vertices = sorted(graph.keys(),
                     key=lambda v: len(graph.get(v, [])),
                     reverse=True)

    def is_safe(vertex, color):
        for neighbor in graph.get(vertex, []):
            if colors.get(neighbor) == color:
                return False
        return True

    def backtrack(idx):
        if idx == len(vertices):
            return True

        vertex = vertices[idx]

        for color in range(k):
            if is_safe(vertex, color):
                colors[vertex] = color

                if backtrack(idx + 1):
                    return True

                del colors[vertex]

        return False

    if backtrack(0):
        return colors
    return None
\end{lstlisting}

\subsection{Greedy Approximation}

Un approccio greedy (non ottimo ma veloce):

\begin{lstlisting}[language=Python]
def greedy_coloring(graph):
    """
    Colorazione greedy (non ottimale).

    Complessita: O(V + E)
    Garanzia: usa al massimo Delta + 1 colori
    (Delta = grado massimo)
    """
    colors = {}

    # Ordina vertici per grado decrescente (euristica)
    vertices = sorted(graph.keys(),
                     key=lambda v: len(graph.get(v, [])),
                     reverse=True)

    for vertex in vertices:
        # Trova colori usati dai vicini
        neighbor_colors = {colors.get(n) for n in graph.get(vertex, [])
                          if n in colors}

        # Usa il primo colore disponibile
        color = 0
        while color in neighbor_colors:
            color += 1

        colors[vertex] = color

    return colors


# Test
coloring = greedy_coloring(graph)
print(f"Greedy coloring: {coloring}")
print(f"Numero colori usati: {max(coloring.values()) + 1}")
\end{lstlisting}

\section{Altri Problemi Classici}

\subsection{Hamiltonian Path}

Trovare un cammino che visita ogni vertice esattamente una volta:

\begin{lstlisting}[language=Python]
def hamiltonian_path(graph, start):
    """
    Trova un cammino hamiltoniano partendo da start.

    Complessita: O(n!)
    """
    n = len(graph)
    path = [start]
    visited = {start}

    def backtrack():
        if len(path) == n:
            return True

        current = path[-1]

        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                path.append(neighbor)
                visited.add(neighbor)

                if backtrack():
                    return True

                path.pop()
                visited.remove(neighbor)

        return False

    if backtrack():
        return path
    return None
\end{lstlisting}

\subsection{Word Search}

Trovare una parola in una griglia di lettere:

\begin{lstlisting}[language=Python]
def word_search(board, word):
    """
    Cerca word nella board con backtracking.

    Complessita: O(m * n * 4^L) dove L = len(word)
    """
    rows, cols = len(board), len(board[0])

    def backtrack(row, col, idx):
        # Parola completa trovata
        if idx == len(word):
            return True

        # Fuori limiti o lettera sbagliata
        if (row < 0 or row >= rows or col < 0 or col >= cols or
            board[row][col] != word[idx]):
            return False

        # Marca come visitata temporaneamente
        temp = board[row][col]
        board[row][col] = '#'

        # Esplora 4 direzioni
        found = (backtrack(row + 1, col, idx + 1) or
                backtrack(row - 1, col, idx + 1) or
                backtrack(row, col + 1, idx + 1) or
                backtrack(row, col - 1, idx + 1))

        # Ripristina
        board[row][col] = temp

        return found

    # Prova da ogni cella
    for i in range(rows):
        for j in range(cols):
            if backtrack(i, j, 0):
                return True

    return False
\end{lstlisting}

\subsection{Partition Equal Subset Sum}

Partizionare un array in due sottoinsiemi con somma uguale:

\begin{lstlisting}[language=Python]
def can_partition(nums):
    """
    Verifica se l'array puo essere partizionato in due
    sottoinsiemi con somma uguale.

    Backtracking (alternativa a DP).
    """
    total = sum(nums)

    if total % 2 != 0:
        return False

    target = total // 2

    def backtrack(idx, current_sum):
        if current_sum == target:
            return True

        if idx >= len(nums) or current_sum > target:
            return False

        # Include nums[idx]
        if backtrack(idx + 1, current_sum + nums[idx]):
            return True

        # Esclude nums[idx]
        if backtrack(idx + 1, current_sum):
            return True

        return False

    return backtrack(0, 0)
\end{lstlisting}

\section{Tecniche di Ottimizzazione}

\subsection{Branch and Bound}

Mantiene il miglior risultato trovato finora e taglia rami che non possono migliorarlo:

\begin{lstlisting}[language=Python]
def branch_and_bound_example():
    """
    Esempio di Branch and Bound per minimizzazione.
    """
    best_solution = None
    best_cost = float('inf')

    def backtrack(partial_solution, current_cost, bound):
        nonlocal best_solution, best_cost

        # Pruning: se il bound e peggiore del best, taglia
        if bound >= best_cost:
            return

        if is_complete(partial_solution):
            if current_cost < best_cost:
                best_cost = current_cost
                best_solution = partial_solution[:]
            return

        for choice in get_choices(partial_solution):
            new_cost = current_cost + cost(choice)
            new_bound = compute_bound(partial_solution + [choice])

            backtrack(partial_solution + [choice],
                     new_cost,
                     new_bound)
\end{lstlisting}

\subsection{Constraint Propagation}

Deduce vincoli da scelte precedenti:

\begin{lstlisting}[language=Python]
def constraint_propagation_example():
    """
    Esempio di constraint propagation.
    """
    # Mantieni domini di valori possibili
    domains = {var: set(possible_values)
              for var in variables}

    def propagate_constraints(var, value):
        """Riduce domini dopo assegnazione."""
        # Rimuovi value dal dominio di var
        domains[var] = {value}

        # Propaga vincoli ai vicini
        for neighbor in get_neighbors(var):
            if value in domains[neighbor]:
                domains[neighbor].remove(value)

                # Se dominio vuoto, fallimento
                if not domains[neighbor]:
                    return False

        return True
\end{lstlisting}

\section{Esercizi}

\begin{enumerate}
    \item Implementare e analizzare:
    \begin{enumerate}
        \item Knight's Tour (cammino del cavallo)
        \item Crossword Puzzle Solver
        \item Latin Square
    \end{enumerate}

    \item Ottimizzazioni:
    \begin{enumerate}
        \item Implementare N-Queens con bitwise operations
        \item Confrontare MRV vs altre euristiche per Sudoku
        \item Analizzare pruning effectiveness
    \end{enumerate}

    \item Problemi avanzati:
    \begin{enumerate}
        \item Generazione di labirinti con backtracking
        \item Satisfiability (SAT) solver semplificato
        \item Constraint Satisfaction Problem (CSP) generico
    \end{enumerate}

    \item Analisi empirica:
    \begin{enumerate}
        \item Misurare speedup delle ottimizzazioni
        \item Confrontare backtracking vs DP su problemi comuni
        \item Profiling di algoritmi backtracking
    \end{enumerate}
\end{enumerate}
