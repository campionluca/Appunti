\chapter{Ricorsione}
\label{cap:ricorsione}

\section{Introduzione}

La ricorsione è una tecnica di programmazione dove una funzione richiama se stessa per risolvere istanze più piccole dello stesso problema.

\subsection{Definizione}

Una funzione $f$ è \textbf{ricorsiva} se nella sua definizione compare una chiamata a $f$ stessa:

\begin{lstlisting}[language=Python]
def f(x):
    # ...
    result = f(y)  # Chiamata ricorsiva
    # ...
    return result
\end{lstlisting}

\subsection{Componenti Fondamentali}

Ogni funzione ricorsiva deve avere:

\begin{enumerate}
    \item \textbf{Caso base} (o terminale): condizione che termina la ricorsione
    \item \textbf{Caso ricorsivo}: scomposizione del problema in sottoproblemi più semplici
    \item \textbf{Progresso}: ogni chiamata ricorsiva deve avvicinare al caso base
\end{enumerate}

\subsection{Principio di Induzione}

La correttezza della ricorsione si basa sull'induzione matematica:
\begin{itemize}
    \item \textbf{Base}: il caso base è corretto
    \item \textbf{Passo}: se l'algoritmo è corretto per istanze più piccole, è corretto per l'istanza corrente
\end{itemize}

\section{Ricorsione Lineare}

\subsection{Fattoriale}

\subsubsection{Definizione Matematica}
\[
n! = \begin{cases}
1 & \text{se } n = 0 \\
n \cdot (n-1)! & \text{se } n > 0
\end{cases}
\]

\subsubsection{Pseudocodice}

\begin{algorithm}
\caption{Fattoriale Ricorsivo}
\begin{algorithmic}[1]
\Procedure{Factorial}{$n$}
    \If{$n = 0$}
        \State \Return $1$ \Comment{Caso base}
    \Else
        \State \Return $n \cdot$ \Call{Factorial}{$n-1$} \Comment{Caso ricorsivo}
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Analisi}

\paragraph{Ricorrenza:}
\[ T(n) = T(n-1) + O(1) = O(n) \]

\paragraph{Complessità Spaziale:} $O(n)$ stack ricorsivo

\subsubsection{Implementazione Python}

\begin{lstlisting}[language=Python]
def factorial(n):
    """
    Calcola il fattoriale di n ricorsivamente.

    Args:
        n: intero non negativo

    Returns:
        n!

    Complessita: O(n) tempo, O(n) spazio (stack)
    """
    if n < 0:
        raise ValueError("n deve essere non negativo")

    # Caso base
    if n == 0 or n == 1:
        return 1

    # Caso ricorsivo
    return n * factorial(n - 1)


def factorial_iterative(n):
    """
    Versione iterativa (piu efficiente).

    Complessita: O(n) tempo, O(1) spazio
    """
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
\end{lstlisting}

\subsection{Successione di Fibonacci}

\subsubsection{Definizione}
\[
F(n) = \begin{cases}
0 & \text{se } n = 0 \\
1 & \text{se } n = 1 \\
F(n-1) + F(n-2) & \text{se } n > 1
\end{cases}
\]

\subsubsection{Pseudocodice}

\begin{algorithm}
\caption{Fibonacci Ricorsivo}
\begin{algorithmic}[1]
\Procedure{Fibonacci}{$n$}
    \If{$n \leq 1$}
        \State \Return $n$
    \Else
        \State \Return \Call{Fibonacci}{$n-1$} + \Call{Fibonacci}{$n-2$}
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Analisi - Versione Naive}

\paragraph{Ricorrenza:}
\[ T(n) = T(n-1) + T(n-2) + O(1) \]

Risolvendo (simile a $F(n)$):
\[ T(n) = O(\phi^n) \text{ dove } \phi = \frac{1+\sqrt{5}}{2} \approx 1.618 \]

\paragraph{Problema:} crescita esponenziale! Fibonacci(40) richiede $\sim 10^8$ chiamate.

\subsubsection{Implementazioni Python}

\begin{lstlisting}[language=Python]
def fibonacci_naive(n):
    """
    Fibonacci ricorsivo naive - INEFFICIENTE!

    Complessita: O(2^n) tempo, O(n) spazio
    """
    if n <= 1:
        return n
    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)


def fibonacci_memoized(n, memo=None):
    """
    Fibonacci con memoization (Dynamic Programming).

    Complessita: O(n) tempo, O(n) spazio
    """
    if memo is None:
        memo = {}

    if n in memo:
        return memo[n]

    if n <= 1:
        return n

    memo[n] = fibonacci_memoized(n - 1, memo) + \
              fibonacci_memoized(n - 2, memo)
    return memo[n]


def fibonacci_iterative(n):
    """
    Versione iterativa - piu efficiente.

    Complessita: O(n) tempo, O(1) spazio
    """
    if n <= 1:
        return n

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b

    return b


# Usando decoratore per memoization automatica
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci_cached(n):
    """
    Fibonacci con cache automatica (Python 3.9+).

    Complessita: O(n) tempo, O(n) spazio
    """
    if n <= 1:
        return n
    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)
\end{lstlisting}

\section{Ricorsione con Alberi}

\subsection{Somma degli Elementi}

Data una lista (possibilmente annidata), sommare tutti i numeri:

\begin{lstlisting}[language=Python]
def sum_nested(lst):
    """
    Somma ricorsiva di lista annidata.

    Args:
        lst: lista che puo contenere numeri o altre liste

    Returns:
        somma di tutti i numeri

    Esempio:
        sum_nested([1, [2, 3], [[4], 5]]) -> 15
    """
    total = 0

    for element in lst:
        if isinstance(element, list):
            # Caso ricorsivo: lista annidata
            total += sum_nested(element)
        else:
            # Caso base: numero
            total += element

    return total
\end{lstlisting}

\subsection{Ricorsione su Alberi Binari}

\begin{lstlisting}[language=Python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def tree_height(root):
    """
    Calcola l'altezza di un albero binario.

    Complessita: O(n) tempo, O(h) spazio (h = altezza)
    """
    # Caso base: albero vuoto
    if root is None:
        return 0

    # Caso ricorsivo: 1 + max delle altezze dei sottoalberi
    left_height = tree_height(root.left)
    right_height = tree_height(root.right)

    return 1 + max(left_height, right_height)


def tree_sum(root):
    """
    Somma di tutti i nodi dell'albero.
    """
    if root is None:
        return 0
    return root.val + tree_sum(root.left) + tree_sum(root.right)


def tree_count_nodes(root):
    """
    Conta i nodi dell'albero.
    """
    if root is None:
        return 0
    return 1 + tree_count_nodes(root.left) + \
           tree_count_nodes(root.right)


def tree_max(root):
    """
    Trova il valore massimo nell'albero.
    """
    if root is None:
        return float('-inf')

    left_max = tree_max(root.left)
    right_max = tree_max(root.right)

    return max(root.val, left_max, right_max)


def tree_contains(root, target):
    """
    Verifica se target e nell'albero.
    """
    if root is None:
        return False

    if root.val == target:
        return True

    return tree_contains(root.left, target) or \
           tree_contains(root.right, target)
\end{lstlisting}

\section{Tail Recursion}

\subsection{Definizione}

Una funzione è \textbf{tail-recursive} se la chiamata ricorsiva è l'ultima operazione eseguita (il risultato viene ritornato direttamente senza ulteriori computazioni).

\subsection{Fattoriale Tail-Recursive}

\begin{algorithm}
\caption{Fattoriale Tail-Recursive}
\begin{algorithmic}[1]
\Procedure{FactorialTail}{$n, acc$}
    \If{$n = 0$}
        \State \Return $acc$
    \Else
        \State \Return \Call{FactorialTail}{$n-1, n \cdot acc$}
    \EndIf
\EndProcedure
\State
\Procedure{Factorial}{$n$}
    \State \Return \Call{FactorialTail}{$n, 1$}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Ottimizzazione: Tail Call Elimination}

Compilatori/interpreti che supportano \textbf{tail call optimization} (TCO) possono convertire tail recursion in loop, eliminando l'overhead dello stack:

\begin{itemize}
    \item Complessità spaziale: da $O(n)$ a $O(1)$
    \item Nessun rischio di stack overflow
    \item Prestazioni simili a versione iterativa
\end{itemize}

\textbf{Nota:} Python non implementa TCO per scelta di design.

\subsection{Implementazioni Python}

\begin{lstlisting}[language=Python]
def factorial_tail(n, acc=1):
    """
    Fattoriale tail-recursive.

    Nota: Python non ottimizza tail recursion,
    ma e utile per capire il concetto.
    """
    if n == 0:
        return acc
    return factorial_tail(n - 1, n * acc)


def fibonacci_tail(n, a=0, b=1):
    """
    Fibonacci tail-recursive.
    """
    if n == 0:
        return a
    if n == 1:
        return b
    return fibonacci_tail(n - 1, b, a + b)


def sum_list_tail(lst, acc=0):
    """
    Somma lista con tail recursion.
    """
    if not lst:
        return acc
    return sum_list_tail(lst[1:], acc + lst[0])


# Conversione tail recursion -> iterazione (manuale)
def factorial_from_tail(n):
    """
    Conversione manuale di tail recursion in loop.
    """
    acc = 1
    while n > 0:
        acc = n * acc
        n = n - 1
    return acc
\end{lstlisting}

\subsection{Pattern: Accumulatore}

Le funzioni tail-recursive usano spesso un \textbf{accumulatore} per mantenere lo stato:

\begin{lstlisting}[language=Python]
def reverse_list_tail(lst, acc=None):
    """
    Inversione lista con tail recursion.
    """
    if acc is None:
        acc = []

    if not lst:
        return acc

    return reverse_list_tail(lst[1:], [lst[0]] + acc)


def gcd_tail(a, b):
    """
    MCD (algoritmo di Euclide) tail-recursive.
    """
    if b == 0:
        return a
    return gcd_tail(b, a % b)
\end{lstlisting}

\section{Divide et Impera}

\subsection{Paradigma}

Il paradigma \textbf{divide et impera} (divide and conquer) consiste in:

\begin{enumerate}
    \item \textbf{Divide}: scomponi il problema in sottoproblemi più piccoli
    \item \textbf{Impera}: risolvi ricorsivamente i sottoproblemi
    \item \textbf{Combina}: combina le soluzioni dei sottoproblemi
\end{enumerate}

\subsection{Merge Sort (Richiamo)}

Già visto nel capitolo~\ref{cap:sorting}:

\begin{lstlisting}[language=Python]
def merge_sort(arr):
    """Divide et impera classico."""
    # Caso base
    if len(arr) <= 1:
        return arr

    # Divide
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])   # Impera
    right = merge_sort(arr[mid:])  # Impera

    # Combina
    return merge(left, right)
\end{lstlisting}

\subsection{Ricerca Binaria Ricorsiva}

\begin{lstlisting}[language=Python]
def binary_search_recursive(arr, key, left=0, right=None):
    """
    Ricerca binaria con divide et impera.
    """
    if right is None:
        right = len(arr) - 1

    # Caso base: elemento non trovato
    if left > right:
        return -1

    # Divide
    mid = left + (right - left) // 2

    # Caso base: elemento trovato
    if arr[mid] == key:
        return mid

    # Impera su una meta
    if arr[mid] < key:
        return binary_search_recursive(arr, key, mid + 1, right)
    else:
        return binary_search_recursive(arr, key, left, mid - 1)
\end{lstlisting}

\subsection{Maximum Subarray Problem}

Trovare il sotto-array con somma massima usando divide et impera:

\begin{lstlisting}[language=Python]
def max_subarray_divide_conquer(arr, low=0, high=None):
    """
    Trova il sotto-array con somma massima.

    Complessita: O(n log n)
    """
    if high is None:
        high = len(arr) - 1

    # Caso base: un solo elemento
    if low == high:
        return arr[low]

    # Divide
    mid = (low + high) // 2

    # Impera: max nelle tre regioni
    left_max = max_subarray_divide_conquer(arr, low, mid)
    right_max = max_subarray_divide_conquer(arr, mid + 1, high)
    cross_max = max_crossing_subarray(arr, low, mid, high)

    # Combina
    return max(left_max, right_max, cross_max)


def max_crossing_subarray(arr, low, mid, high):
    """
    Trova il max subarray che attraversa mid.
    """
    # Max a sinistra di mid
    left_sum = float('-inf')
    total = 0
    for i in range(mid, low - 1, -1):
        total += arr[i]
        left_sum = max(left_sum, total)

    # Max a destra di mid
    right_sum = float('-inf')
    total = 0
    for i in range(mid + 1, high + 1):
        total += arr[i]
        right_sum = max(right_sum, total)

    return left_sum + right_sum
\end{lstlisting}

\section{Backtracking - Introduzione}

Il \textbf{backtracking} è una tecnica di ricerca esaustiva che costruisce incrementalmente soluzioni candidateabbandonando quelle che non possono portare a soluzioni valide.

\subsection{Schema Generale}

\begin{algorithm}
\caption{Backtracking Schema}
\begin{algorithmic}[1]
\Procedure{Backtrack}{$solution, candidates$}
    \If{\Call{IsSolution}{$solution$}}
        \State \Call{ProcessSolution}{$solution$}
        \State \Return
    \EndIf
    \For{$candidate$ \In $candidates$}
        \If{\Call{IsValid}{$solution, candidate$}}
            \State \Call{AddToSolution}{$solution, candidate$}
            \State \Call{Backtrack}{$solution, remaining\_candidates$}
            \State \Call{RemoveFromSolution}{$solution, candidate$} \Comment{Backtrack!}
        \EndIf
    \EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Generazione di Permutazioni}

\begin{lstlisting}[language=Python]
def permutations(arr):
    """
    Genera tutte le permutazioni di arr usando backtracking.

    Complessita: O(n! * n) tempo
    """
    result = []

    def backtrack(current, remaining):
        # Caso base: permutazione completa
        if not remaining:
            result.append(current[:])  # Copia
            return

        # Prova ogni elemento rimanente
        for i in range(len(remaining)):
            # Scegli
            current.append(remaining[i])
            # Esplora
            backtrack(current, remaining[:i] + remaining[i+1:])
            # Annulla (backtrack)
            current.pop()

    backtrack([], arr)
    return result


def permutations_efficient(arr):
    """
    Permutazioni con scambi in-place (piu efficiente).
    """
    result = []

    def backtrack(start):
        if start == len(arr):
            result.append(arr[:])
            return

        for i in range(start, len(arr)):
            # Scambia
            arr[start], arr[i] = arr[i], arr[start]
            # Ricorsione
            backtrack(start + 1)
            # Backtrack (ripristina)
            arr[start], arr[i] = arr[i], arr[start]

    backtrack(0)
    return result
\end{lstlisting}

\subsection{Generazione di Sottoinsiemi}

\begin{lstlisting}[language=Python]
def subsets(arr):
    """
    Genera tutti i sottoinsiemi di arr.

    Complessita: O(2^n * n) tempo
    """
    result = []

    def backtrack(start, current):
        # Ogni stato e una soluzione valida
        result.append(current[:])

        # Prova ad aggiungere elementi successivi
        for i in range(start, len(arr)):
            current.append(arr[i])
            backtrack(i + 1, current)
            current.pop()

    backtrack(0, [])
    return result


def subsets_iterative(arr):
    """
    Versione iterativa usando bit manipulation.
    """
    n = len(arr)
    result = []

    # 2^n sottoinsiemi possibili
    for mask in range(1 << n):
        subset = []
        for i in range(n):
            # Controlla se l'i-esimo bit e settato
            if mask & (1 << i):
                subset.append(arr[i])
        result.append(subset)

    return result
\end{lstlisting}

\subsection{Combinazioni}

Generare tutte le combinazioni di $k$ elementi da $n$:

\begin{lstlisting}[language=Python]
def combinations(arr, k):
    """
    Genera tutte le combinazioni di k elementi.

    Complessita: O(C(n,k) * k) dove C(n,k) = n!/(k!(n-k)!)
    """
    result = []

    def backtrack(start, current):
        # Caso base: combinazione completa
        if len(current) == k:
            result.append(current[:])
            return

        # Quanti elementi servono ancora
        needed = k - len(current)

        # Prova ogni elemento da start in poi
        for i in range(start, len(arr)):
            # Pruning: controlla se ci sono abbastanza elementi rimanenti
            remaining = len(arr) - i
            if remaining < needed:
                break

            current.append(arr[i])
            backtrack(i + 1, current)
            current.pop()

    backtrack(0, [])
    return result
\end{lstlisting}

\section{Ricorsione Multipla}

\subsection{Numero di Cammini in Griglia}

Trovare il numero di cammini da $(0,0)$ a $(m,n)$ muovendosi solo a destra o in basso:

\begin{lstlisting}[language=Python]
def count_paths(m, n):
    """
    Conta i cammini in griglia m x n.

    Soluzione ricorsiva naive: O(2^(m+n))
    """
    # Caso base: bordo della griglia
    if m == 0 or n == 0:
        return 1

    # Ricorsione multipla
    return count_paths(m - 1, n) + count_paths(m, n - 1)


def count_paths_memoized(m, n, memo=None):
    """
    Con memoization: O(m * n)
    """
    if memo is None:
        memo = {}

    if (m, n) in memo:
        return memo[(m, n)]

    if m == 0 or n == 0:
        return 1

    memo[(m, n)] = count_paths_memoized(m - 1, n, memo) + \
                   count_paths_memoized(m, n - 1, memo)

    return memo[(m, n)]


def count_paths_formula(m, n):
    """
    Soluzione matematica: C(m+n, m) = (m+n)! / (m! * n!)

    Complessita: O(m + n)
    """
    from math import comb
    return comb(m + n, m)
\end{lstlisting}

\subsection{Torre di Hanoi}

Spostare $n$ dischi da palo A a palo C usando palo B come ausiliario:

\begin{lstlisting}[language=Python]
def hanoi(n, source='A', target='C', auxiliary='B'):
    """
    Risolve le Torri di Hanoi.

    Complessita: O(2^n) mosse
    """
    if n == 1:
        print(f"Sposta disco 1 da {source} a {target}")
        return 1

    moves = 0

    # Sposta n-1 dischi da source ad auxiliary
    moves += hanoi(n - 1, source, auxiliary, target)

    # Sposta disco n da source a target
    print(f"Sposta disco {n} da {source} a {target}")
    moves += 1

    # Sposta n-1 dischi da auxiliary a target
    moves += hanoi(n - 1, auxiliary, target, source)

    return moves


def hanoi_iterative(n, source='A', target='C', auxiliary='B'):
    """
    Versione iterativa (meno intuitiva).
    """
    # Numero totale di mosse: 2^n - 1
    total_moves = (1 << n) - 1

    # Se n e pari, scambia target e auxiliary
    if n % 2 == 0:
        target, auxiliary = auxiliary, target

    poles = {source: list(range(n, 0, -1)),
             auxiliary: [],
             target: []}

    for move in range(1, total_moves + 1):
        if move % 3 == 1:
            move_disk(poles, source, target)
        elif move % 3 == 2:
            move_disk(poles, source, auxiliary)
        else:
            move_disk(poles, auxiliary, target)

    return total_moves


def move_disk(poles, from_pole, to_pole):
    """Helper per muovere un disco."""
    if not poles[from_pole]:
        from_pole, to_pole = to_pole, from_pole

    if not poles[to_pole] or \
       poles[from_pole][-1] < poles[to_pole][-1]:
        disk = poles[from_pole].pop()
        poles[to_pole].append(disk)
        print(f"Sposta disco {disk} da {from_pole} a {to_pole}")
\end{lstlisting}

\section{Tecniche di Ottimizzazione}

\subsection{Memoization}

Salvare i risultati di chiamate già computate:

\begin{lstlisting}[language=Python]
# Pattern generale per memoization
def memoized_function(n, memo=None):
    if memo is None:
        memo = {}

    if n in memo:
        return memo[n]

    # Calcola risultato
    result = compute(n)

    memo[n] = result
    return result


# Usando decoratore Python
from functools import lru_cache

@lru_cache(maxsize=None)
def cached_function(n):
    # La cache e automatica
    return compute(n)
\end{lstlisting}

\subsection{Pruning}

Tagliare rami dell'albero di ricorsione che non possono portare a soluzioni:

\begin{lstlisting}[language=Python]
def subset_sum(arr, target):
    """
    Trova un sottoinsieme con somma = target.
    Con pruning per efficienza.
    """
    def backtrack(index, current_sum):
        # Soluzione trovata
        if current_sum == target:
            return True

        # Pruning: somma troppo grande
        if current_sum > target:
            return False

        # Pruning: nessun elemento rimanente
        if index >= len(arr):
            return False

        # Include arr[index]
        if backtrack(index + 1, current_sum + arr[index]):
            return True

        # Esclude arr[index]
        if backtrack(index + 1, current_sum):
            return True

        return False

    return backtrack(0, 0)
\end{lstlisting}

\section{Limiti della Ricorsione}

\subsection{Stack Overflow}

Python ha un limite di ricorsione (default $\sim$1000):

\begin{lstlisting}[language=Python]
import sys

# Visualizza limite corrente
print(sys.getrecursionlimit())  # Tipicamente 1000

# Aumenta limite (con cautela!)
sys.setrecursionlimit(10000)

# Meglio: converti in iterazione
def safe_deep_recursion(n):
    """Usa iterazione per evitare stack overflow."""
    stack = [n]
    result = 0

    while stack:
        current = stack.pop()
        if current == 0:
            result += 1
        else:
            stack.append(current - 1)

    return result
\end{lstlisting}

\subsection{Quando Evitare la Ricorsione}

Esistono situazioni in cui l'approccio iterativo è preferibile a quello ricorsivo. Quando la profondità della ricorsione può diventare molto grande (superiore a 1000 livelli), il rischio di stack overflow rende l'iterazione una scelta più sicura. Nel caso di ricorsione tail-recursive, dove l'ultima operazione della funzione è la chiamata ricorsiva stessa, è opportuno convertire la soluzione in un loop iterativo, ottenendo gli stessi risultati con maggiore efficienza. L'iterazione dovrebbe essere preferita anche quando la struttura ricorsiva non aggiunge chiarezza alla soluzione: in questi casi, il costo computazionale della ricorsione non è giustificato da un miglioramento della leggibilità del codice. Infine, quando le prestazioni sono un fattore critico, l'overhead delle chiamate ricorsive (creazione di stack frame, salvataggio di contesto) può rendere l'approccio iterativo significativamente più veloce.

\subsection{Quando Preferire la Ricorsione}

La ricorsione è la scelta naturale in diverse situazioni specifiche. Quando il problema ha una struttura intrinsecamente ricorsiva, come accade con alberi e grafi, la soluzione ricorsiva riflette direttamente la natura del problema, risultando elegante e intuitiva. Anche quando la soluzione iterativa equivalente sarebbe eccessivamente complessa, con gestione manuale di stack e stato, la ricorsione offre un'alternativa molto più comprensibile. Il backtracking è un altro contesto in cui la ricorsione eccelle: la capacità di esplorare diverse possibilità e tornare indietro automaticamente grazie allo stack delle chiamate rende la ricorsione quasi indispensabile per questo tipo di algoritmi. Infine, quando la chiarezza e la manutenibilità del codice sono prioritarie rispetto alle prestazioni pure, la ricorsione permette di esprimere la soluzione in modo più diretto e comprensibile, facilitando la comprensione della logica algoritmica.

\section{Esercizi}

\begin{enumerate}
    \item Implementare ricorsivamente:
    \begin{enumerate}
        \item Calcolo di $x^n$
        \item Inversione di una stringa
        \item Verifica se una stringa è palindroma
        \item Somma delle cifre di un numero
    \end{enumerate}

    \item Convertire in tail-recursive:
    \begin{enumerate}
        \item Somma di lista
        \item Lunghezza di lista
        \item Conteggio occorrenze in lista
    \end{enumerate}

    \item Analizzare la complessità di:
    \begin{enumerate}
        \item $T(n) = T(n-1) + T(n-2) + O(1)$
        \item $T(n) = 2T(n/2) + O(n)$
        \item $T(n) = T(n/3) + T(2n/3) + O(n)$
    \end{enumerate}

    \item Implementare con backtracking:
    \begin{enumerate}
        \item Generazione di tutte le parentesi bilanciate di lunghezza $2n$
        \item Generazione di tutti i numeri binari di $n$ bit
        \item Partizione di un insieme in due sottoinsiemi con somma uguale
    \end{enumerate}

    \item Ottimizzare con memoization:
    \begin{enumerate}
        \item Coefficiente binomiale $C(n, k)$
        \item Problema del resto (coin change)
        \item Conteggio modi per salire $n$ scalini (1 o 2 per volta)
    \end{enumerate}

    \item Implementare iterativamente (senza ricorsione):
    \begin{enumerate}
        \item Traversal di albero in-order
        \item Quick Sort
        \item Torri di Hanoi
    \end{enumerate}

    \item Dimostrare per induzione la correttezza di:
    \begin{enumerate}
        \item Algoritmo di Euclide per MCD
        \item Ricerca binaria
        \item Merge Sort
    \end{enumerate}

    \item Analizzare spazio e tempo per:
    \begin{enumerate}
        \item Fibonacci ricorsivo vs iterativo vs con memoization
        \item Permutazioni con backtracking vs generazione diretta
        \item Maximum subarray con divide et impera vs Kadane
    \end{enumerate}
\end{enumerate}
