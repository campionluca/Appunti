\chapter{Stream e Buffer}
\label{cap:stream_buffer}

\section*{Obiettivi di apprendimento}
Al termine di questo capitolo sarai in grado di:
\begin{itemize}
    \item Comprendere il concetto di stream in Java
    \item Utilizzare FileInputStream e FileOutputStream per operazioni su file binari
    \item Lavorare con BufferedReader e BufferedWriter per file di testo
    \item Gestire correttamente le risorse con try-with-resources
    \item Applicare le best practices nella gestione di file
\end{itemize}

\section{Introduzione agli stream}

In Java, uno \textbf{stream} (flusso) è una sequenza di dati che può essere letta o scritta. Gli stream forniscono un modo uniforme per lavorare con diverse sorgenti e destinazioni di dati: file, connessioni di rete, array in memoria, ecc.

Esistono due tipi principali di stream in Java, ciascuno adatto a esigenze diverse. Gli \textbf{stream di byte} (byte streams) lavorano direttamente con dati binari, elaborando un byte alla volta. Questi stream sono rappresentati da classi che terminano con \texttt{InputStream} oppure \texttt{OutputStream}, secondo che si tratti di lettura o scrittura. Gli \textbf{stream di caratteri} (character streams) sono invece specializzati per lavorare con dati testuali. La loro caratteristica principale è che gestiscono automaticamente la codifica dei caratteri, convertendo tra i byte grezzi e i caratteri Unicode del linguaggio Java. Le classi che implementano gli stream di caratteri terminano con \texttt{Reader} per la lettura e \texttt{Writer} per la scrittura.

\begin{nota}
Gli stream di byte sono più versatili e possono gestire qualsiasi tipo di file, ma per file di testo è preferibile usare stream di caratteri che gestiscono correttamente encoding come UTF-8.
\end{nota}

\subsection{Esempio 1: Concetto di stream}

Immagina uno stream come un tubo attraverso cui scorrono i dati. Per leggere da un file, apri uno stream di input che porta i dati dal file al tuo programma. Per scrivere, apri uno stream di output che porta i dati dal programma al file.

\begin{lstlisting}
import java.io.FileInputStream;
import java.io.IOException;

public class StreamBasico {
    public static void main(String[] args) {
        // Apriamo uno stream per leggere dal file
        try {
            FileInputStream fis = new FileInputStream("dati.txt");

            // Leggiamo un byte alla volta
            int byteData = fis.read();

            System.out.println("Primo byte letto: " + byteData);

            // Chiudiamo lo stream
            fis.close();
        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio introduce il concetto fondamentale di stream come canale di comunicazione con file esterni. Il metodo \texttt{fis.read()} dell'oggetto \texttt{FileInputStream} restituisce un singolo byte letto dal file, rappresentato come intero (range 0-255). Quando non ci sono più dati da leggere, il metodo \texttt{fis.read()} restituisce -1.

\textbf{Perché questo approccio?} L'utilizzo di stream permette di astrarre il meccanismo di lettura: che si tratti di file su disco, dati dalla rete o altre sorgenti, l'interfaccia rimane uniforme. Tuttavia, leggere un byte alla volta è estremamente inefficiente per file di grandi dimensioni.

\textbf{Quando usare FileInputStream?} Questo pattern è adatto per file binari di piccole dimensioni o quando si necessita di controllo a basso livello sui byte. Per file di testo, è preferibile usare stream di caratteri (Reader/Writer).

\textbf{Nota sulla gestione delle risorse:} Questo esempio mostra una chiusura esplicita dello stream con il metodo \texttt{fis.close()}. Nelle sezioni successive vedremo il pattern try-with-resources che automatizza questo processo critico.

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=2.5cm,
    block/.style={
        rectangle,
        draw=blue!60,
        fill=blue!10,
        very thick,
        minimum width=3cm,
        minimum height=1cm,
        align=center,
        font=\small\bfseries
    },
    arrow/.style={
        ->,
        >=stealth,
        very thick,
        blue!60
    }
]

% Blocchi del flusso
\node[block] (file) {File su\\Disco};
\node[block, right of=file, fill=green!10, draw=green!60] (stream) {Stream\\(FileInputStream)};
\node[block, right of=stream, fill=orange!10, draw=orange!60] (buffer) {Buffer\\(BufferedReader)};
\node[block, right of=buffer, fill=purple!10, draw=purple!60] (app) {Applicazione\\Java};

% Frecce
\draw[arrow] (file) -- (stream) node[midway, above, font=\footnotesize] {byte};
\draw[arrow] (stream) -- (buffer) node[midway, above, font=\footnotesize] {caratteri};
\draw[arrow] (buffer) -- (app) node[midway, above, font=\footnotesize] {br.readLine()};

% Frecce di ritorno (output)
\draw[arrow] (app) -- +(0,-1.5) -| (buffer) node[near start, right, font=\footnotesize] {bw.write()};
\draw[arrow] (buffer) -- +(0,-2.2) -| (stream);
\draw[arrow] (stream) -- +(0,-2.9) -| (file);

\end{tikzpicture}
\caption{Flusso di dati tra file, stream, buffer e applicazione. I dati viaggiano dal disco all'applicazione attraverso stream e buffer, ottimizzando le performance}
\label{fig:flusso_stream}
\end{figure}

\section{Input e Output Stream}

La gerarchia delle classi per gestire gli stream in Java è organizzata attorno a quattro classi astratte principali:

\begin{itemize}
    \item \texttt{InputStream}: classe base per leggere byte
    \item \texttt{OutputStream}: classe base per scrivere byte
    \item \texttt{Reader}: classe base per leggere caratteri
    \item \texttt{Writer}: classe base per scrivere caratteri
\end{itemize}

Da queste classi derivano implementazioni concrete come \texttt{FileInputStream}, \texttt{FileOutputStream}, \texttt{FileReader}, \texttt{FileWriter}, ecc.

\subsection{Esempio 2: Lettura byte per byte}

\begin{lstlisting}
import java.io.FileInputStream;
import java.io.IOException;

public class LeggiFile {
    public static void main(String[] args) {
        FileInputStream fis = null;

        try {
            fis = new FileInputStream("input.dat");
            int byteData;

            // fis.read() restituisce -1 quando raggiunge la fine del file
            while ((byteData = fis.read()) != -1) {
                System.out.print((char) byteData);
            }
        } catch (IOException e) {
            System.out.println("Errore nella lettura: " + e.getMessage());
        } finally {
            // Importante: chiudere sempre lo stream
            try {
                if (fis != null) {
                    fis.close();
                }
            } catch (IOException e) {
                System.out.println("Errore nella chiusura: " + e.getMessage());
            }
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio dimostra il pattern classico di lettura completa di un file utilizzando un ciclo while che continua finché il metodo \texttt{fis.read()} non restituisce -1 (indicatore di fine file, EOF - End Of File). Il cast \texttt{(char)} converte ogni byte in carattere per la visualizzazione.

\textbf{Perché il blocco finally?} La gestione della chiusura nel blocco \texttt{finally} garantisce che lo stream venga liberato anche in caso di eccezioni durante la lettura. Il controllo \texttt{if (fis != null)} previene \texttt{NullPointerException} se l'apertura dello stream fallisce.

\textbf{Pattern try-finally:} Questa tecnica, pur essendo corretta, è verbosa e soggetta a errori. Il programmatore deve ricordarsi di gestire due possibili eccezioni: una durante l'operazione di I/O e una durante la chiusura. Questo pattern è stato semplificato in Java 7 con try-with-resources.

\textbf{Limitazioni:} Leggere byte per byte è molto inefficiente. Ogni chiamata al metodo \texttt{fis.read()} comporta un accesso al disco. Per un file di 1 MB servirebbero circa 1.000.000 di operazioni di I/O, rendendo il processo estremamente lento.

\begin{errore}
Dimenticare di chiudere uno stream può causare memory leak e file bloccati. Gli stream tengono aperte risorse di sistema che devono essere liberate esplicitamente.
\end{errore}

\section{FileInputStream e FileOutputStream}

\texttt{FileInputStream} e \texttt{FileOutputStream} sono le classi più semplici per lavorare con file. Operano a livello di byte e sono adatte per file binari (immagini, audio, video) ma anche per file di testo.

\subsection{Metodi principali di FileInputStream}

\begin{itemize}
    \item \texttt{stream.read()}: legge un singolo byte e lo restituisce come int (0-255), oppure -1 se fine file
    \item \texttt{stream.read(byte[] b)}: legge byte e li memorizza nell'array, restituisce il numero di byte letti
    \item \texttt{stream.close()}: chiude lo stream e rilascia le risorse
    \item \texttt{stream.available()}: restituisce una stima dei byte disponibili per la lettura
\end{itemize}

\subsection{Metodi principali di FileOutputStream}

\begin{itemize}
    \item \texttt{stream.write(int b)}: scrive un singolo byte
    \item \texttt{stream.write(byte[] b)}: scrive un array di byte
    \item \texttt{stream.flush()}: forza la scrittura immediata dei dati bufferizzati
    \item \texttt{stream.close()}: chiude lo stream
\end{itemize}

\subsection{Esempio 3: Copia di un file}

\begin{lstlisting}
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopiaFile {
    public static void main(String[] args) {
        FileInputStream sorgente = null;
        FileOutputStream destinazione = null;

        try {
            sorgente = new FileInputStream("originale.jpg");
            destinazione = new FileOutputStream("copia.jpg");

            // Array buffer per lettura/scrittura più efficiente
            byte[] buffer = new byte[1024]; // 1 KB alla volta
            int byteLetti;

            // Leggi e scrivi in blocchi
            while ((byteLetti = sorgente.read(buffer)) != -1) {
                destinazione.write(buffer, 0, byteLetti);
            }

            System.out.println("File copiato con successo!");

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        } finally {
            try {
                if (sorgente != null) sorgente.close();
                if (destinazione != null) destinazione.close();
            } catch (IOException e) {
                System.out.println("Errore chiusura: " + e.getMessage());
            }
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio implementa una funzionalità di copia file utilizzando un buffer intermedio per ottimizzare le performance. La tecnica del buffering manuale riduce drasticamente gli accessi al disco rispetto alla lettura byte-per-byte.

\textbf{Come funziona il buffer?} L'array \texttt{byte[] buffer = new byte[1024]} crea uno spazio in memoria di 1 KB. Il metodo \texttt{sorgente.read(buffer)} legge fino a 1024 byte dal file sorgente e li memorizza nell'array, restituendo il numero effettivo di byte letti. Questo approccio riduce 1024 chiamate di sistema a una singola operazione.

\textbf{Perché destinazione.write(buffer, 0, byteLetti)?} Nell'ultima iterazione, il file potrebbe non riempire completamente il buffer. Il parametro \texttt{byteLetti} indica quanti byte sono stati effettivamente letti, evitando di scrivere dati spazzatura oltre la fine del file reale.

\textbf{Scelta della dimensione del buffer:} 1 KB è un buon compromesso tra uso di memoria e performance. Buffer più grandi (4-8 KB) possono migliorare ulteriormente la velocità, ma oltre certi limiti i benefici diventano marginali. Per file molto grandi, buffer di 8-16 KB sono ottimali.

\textbf{Applicabilità:} Questo pattern funziona con qualsiasi tipo di file (binario o testo) perché opera a livello di byte grezzo, preservando perfettamente la struttura del file originale.

\begin{nota}
Usare un buffer (array di byte) invece di leggere un byte alla volta migliora drasticamente le performance, riducendo il numero di accessi al disco.
\end{nota}

\subsection{Esempio 4: Scrittura su file}

\begin{lstlisting}
import java.io.FileOutputStream;
import java.io.IOException;

public class ScriviFile {
    public static void main(String[] args) {
        try {
            FileOutputStream fos = new FileOutputStream("output.txt");

            String testo = "Ciao mondo da Java!";
            byte[] dati = testo.getBytes(); // Converte String in byte[]

            fos.write(dati);
            fos.close();

            System.out.println("Scrittura completata!");

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio mostra come scrivere dati testuali su file utilizzando stream di byte. Il metodo \texttt{testo.getBytes()} dell'oggetto \texttt{String} converte una stringa Java in un array di byte utilizzando l'encoding di default della piattaforma (tipicamente UTF-8 su sistemi moderni).

\textbf{Conversione String-Byte:} Le stringhe in Java sono sequenze di caratteri Unicode (16 bit ciascuno), mentre i file memorizzano byte (8 bit). La conversione tramite il metodo \texttt{testo.getBytes()} applica un encoding per rappresentare i caratteri come sequenze di byte. Per controllare esplicitamente l'encoding, si può usare il metodo \texttt{testo.getBytes("UTF-8")}.

\textbf{Quando usare FileOutputStream per testo?} Questo approccio è adatto per scritture semplici e veloci, ma presenta limitazioni: non gestisce automaticamente le newline in modo portabile tra sistemi operativi e non offre buffering integrato. Per operazioni testuali complesse, \texttt{BufferedWriter} è preferibile.

\textbf{Modalità di scrittura:} Di default, \texttt{FileOutputStream} crea un nuovo file o sovrascrive quello esistente. La modalità "append" (aggiunta in coda) preserva il contenuto esistente, utile per file di log o quando si vogliono aggiungere dati progressivamente.

\begin{attenzione}
Per default, \texttt{FileOutputStream} sovrascrive il file esistente. Per aggiungere dati in coda, usa il costruttore con secondo parametro true: \\
\texttt{new FileOutputStream("file.txt", true)}
\end{attenzione}

\section{BufferedReader e BufferedWriter}

Per lavorare con file di testo, le classi \texttt{BufferedReader} e \texttt{BufferedWriter} sono più efficienti e comode. Il buffering interno riduce gli accessi al disco e fornisce metodi utili come \texttt{br.readLine()} (dove \texttt{br} è un oggetto \texttt{BufferedReader}) per leggere righe intere.

\subsection{Vantaggi del buffering}

Un buffer è una zona di memoria temporanea che accumula dati prima di leggerli/scriverli effettivamente. Invece di accedere al disco per ogni singolo carattere, si legge/scrive in blocchi, riducendo drasticamente i tempi di I/O.

\subsection{Esempio 5: Lettura di file di testo riga per riga}

\begin{lstlisting}
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeggiTestoRighe {
    public static void main(String[] args) {
        BufferedReader br = null;

        try {
            // FileReader legge caratteri, BufferedReader aggiunge buffering
            br = new BufferedReader(new FileReader("testo.txt"));

            String riga;
            int numeroRiga = 1;

            // br.readLine() legge una riga intera e restituisce null a fine file
            while ((riga = br.readLine()) != null) {
                System.out.println(numeroRiga + ": " + riga);
                numeroRiga++;
            }

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        } finally {
            try {
                if (br != null) br.close();
            } catch (IOException e) {
                System.out.println("Errore chiusura: " + e.getMessage());
            }
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio mostra l'approccio moderno e raccomandato per leggere file di testo in Java. La combinazione \texttt{FileReader} + \texttt{BufferedReader} crea una pipeline efficiente: \texttt{FileReader} gestisce la conversione byte-caratteri, mentre \texttt{BufferedReader} aggiunge buffering e il metodo \texttt{br.readLine()}.

\textbf{Perché il decorator pattern?} Java usa il pattern Decorator per comporre funzionalità. \texttt{BufferedReader} "decora" \texttt{FileReader} aggiungendo buffering. Questo design modulare permette di combinare diverse capacità: si potrebbe aggiungere ulteriore compressione, cifratura, ecc., semplicemente impilando più decorator.

\textbf{Il metodo br.readLine():} Questo metodo dell'oggetto \texttt{BufferedReader} legge caratteri fino al prossimo separatore di riga (\texttt{\textbackslash n}, \texttt{\textbackslash r\textbackslash n}, o \texttt{\textbackslash r}) e restituisce la stringa senza il separatore. Quando raggiunge la fine del file, il metodo \texttt{br.readLine()} restituisce \texttt{null} (non stringa vuota).

\textbf{Vantaggi del buffering automatico:} Internamente, \texttt{BufferedReader} legge blocchi di caratteri (default 8192 caratteri) e li memorizza. Le chiamate successive a \texttt{br.readLine()} attingono da questo buffer interno, riducendo drasticamente le chiamate di sistema.

\textbf{Gestione encoding:} \texttt{FileReader} usa l'encoding di default del sistema. Per specificare un encoding (es. UTF-8), usa invece: \\
\texttt{new BufferedReader(new InputStreamReader(new FileInputStream("file.txt"), "UTF-8"))}

\subsection{Esempio 6: Scrittura su file di testo con BufferedWriter}

\begin{lstlisting}
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class ScriviTestoBuffer {
    public static void main(String[] args) {
        try {
            BufferedWriter bw = new BufferedWriter(
                new FileWriter("output.txt")
            );

            // Scriviamo diverse righe
            bw.write("Prima riga di testo");
            bw.newLine(); // Aggiunge il separatore di riga corretto per l'OS
            bw.write("Seconda riga di testo");
            bw.newLine();
            bw.write("Terza riga");

            bw.close(); // Chiude e fa flush automatico

            System.out.println("File scritto con successo!");

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio illustra la scrittura su file di testo utilizzando il buffering per ottimizzare le performance. Come per la lettura, la combinazione \texttt{FileWriter} + \texttt{BufferedWriter} crea una pipeline: \texttt{FileWriter} gestisce la conversione caratteri-byte, mentre \texttt{BufferedWriter} aggiunge buffering.

\textbf{Il metodo bw.newLine():} Questo metodo dell'oggetto \texttt{BufferedWriter} è fondamentale per la portabilità del codice. Scrive il separatore di riga appropriato per il sistema operativo corrente: \texttt{\textbackslash r\textbackslash n} su Windows, \texttt{\textbackslash n} su Unix/Linux/macOS. Hardcodare \texttt{"\textbackslash n"} creerebbe file non conformi su Windows.

\textbf{Buffering in scrittura:} I dati non vengono scritti immediatamente su disco ma accumulati in un buffer interno (default 8192 caratteri). La scrittura fisica avviene quando: (1) il buffer si riempie, (2) si chiama il metodo \texttt{bw.flush()}, (3) si chiude lo stream. Questo riduce drasticamente le operazioni di I/O.

\textbf{Importanza di bw.close():} La chiusura dello stream è critica perché: (1) forza il flush dei dati bufferizzati, (2) libera le risorse di sistema, (3) rende disponibile il file ad altri processi. Senza il metodo \texttt{bw.close()}, gli ultimi dati potrebbero non essere scritti su disco.

\textbf{Alternative moderne:} Da Java 11 è disponibile anche \texttt{Files.writeString(Path, String)} per scritture semplici one-liner.

\begin{nota}
Il metodo \texttt{bw.newLine()} dell'oggetto \texttt{BufferedWriter} è preferibile a scrivere manualmente \texttt{"\textbackslash n"} perché usa il separatore di riga corretto per il sistema operativo (Windows usa \texttt{"\textbackslash r\textbackslash n"}, Unix/Linux usa \texttt{"\textbackslash n"}).
\end{nota}

\section{File di Testo vs File di Oggetti (Serializzazione)}

Finora abbiamo lavorato principalmente con file di testo, dove i dati sono memorizzati in formato leggibile. Esiste però un'alternativa potente per salvare dati strutturati: la \textbf{serializzazione degli oggetti}. Questa sezione esplora le differenze tra questi due approcci e quando usare ciascuno.

\subsection{File di Testo}

I \textbf{file di testo} memorizzano dati in formato leggibile da esseri umani, utilizzando encoding come UTF-8, ASCII, ISO-8859-1, ecc. Ogni carattere è rappresentato da uno o più byte secondo lo schema di codifica scelto.

\subsubsection{Caratteristiche dei file di testo}

I file di testo possiedono diverse caratteristiche distintive che li rendono particolari per determinati usi. In primo luogo, offrono \textbf{leggibilità umana}: possono essere aperti e modificati direttamente con qualsiasi editor di testo standard senza necessità di tool specializzati. Forniscono anche \textbf{portabilità}, funzionando su qualsiasi piattaforma (Windows, macOS, Linux) indipendentemente dal linguaggio di programmazione utilizzato per crearli. I file di testo garantiscono \textbf{interoperabilità} eccellente: sono facilissimi da processare con script shell, tool Unix, foglio di calcolo come Excel, e molti altri strumenti di terze parti. Questo facilita enormemente lo \textbf{debugging semplice}, poiché è possibile ispezionare direttamente il contenuto del file per capire cosa è stato salvato. Un aspetto tecnico importante è la \textbf{gestione dei separatori di riga}: i file di testo devono gestire diverse convenzioni per le newline (\texttt{\textbackslash n} su Unix/Linux, \texttt{\textbackslash r\textbackslash n} su Windows). Infine, è necessario occuparsi dell'\textbf{encoding}: il programmatore deve specificare la codifica caratteri da usare (UTF-8, ASCII, ISO-8859-1, ecc.) per garantire che i caratteri non-ASCII siano salvati e letti correttamente.

\subsubsection{Quando usare file di testo}

I file di testo sono la scelta ideale per numerosi scenari applicativi. Sono perfetti per \textbf{file di configurazione} come properties, ini, yaml, json, xml, dove è necessario leggere e modificare parametri di configurazione in modo facile e accessibile. Sono la soluzione naturale per \textbf{log applicativi}, permettendo di tracciare gli eventi durante l'esecuzione del programma e facilitando il debugging tramite ispezionamento diretto dei file di log. Per \textbf{dati tabulari}, i file di testo in formato CSV o TSV sono la scelta standard per esportare dati verso Excel o database, garantendo massima compatibilità. Sono appropriati per \textbf{documentazione}, come file markdown e plain text, che devono essere leggibili da esseri umani. Per \textbf{scambio dati tra linguaggi diversi}, JSON e XML sono formati di testo standard che permetto a programmi scritti in linguaggi diversi di comunicare. Infine, per \textbf{archiviazione long-term}, i file di testo garantiscono che i dati rimangono accessibili per anni senza rischi di incompatibilità, grazie alla loro natura universale e al supporto diffuso.

\subsubsection{Vantaggi e svantaggi}

\begin{table}[h]
\centering
\begin{tabular}{|p{6cm}|p{6cm}|}
\hline
\textbf{Vantaggi} & \textbf{Svantaggi} \\
\hline
Leggibili e modificabili manualmente & Occupano più spazio su disco \\
\hline
Indipendenti dal linguaggio & Parsing necessario per ricostruire oggetti \\
\hline
Facili da debuggare & Performance inferiori per strutture complesse \\
\hline
Stabili nel tempo & Perdita di tipo (tutto diventa stringa) \\
\hline
Tool diffusi per elaborazione & Difficoltà con strutture annidate profonde \\
\hline
\end{tabular}
\end{table}

\subsection{File di Oggetti - Serializzazione}

La \textbf{serializzazione} è il processo di conversione di un oggetto Java in una sequenza di byte che può essere salvata su file o trasmessa in rete. Il processo inverso si chiama \textbf{deserializzazione} e ricostruisce l'oggetto originale dallo stream di byte.

\subsubsection{Cos'è la serializzazione}

La serializzazione è un meccanismo potente che offre diversi vantaggi nella persistenza dei dati. Innanzitutto, permette di salvare lo \textbf{stato completo} di un oggetto, includendo i valori di tutti i campi, in modo che l'oggetto possa essere perfettamente ricostruito in seguito. Preserva la \textbf{struttura dei dati}, mantenendo il tipo dell'oggetto e le relazioni tra diversi oggetti, cosa fondamentale per strutture dati complesse. La serializzazione gestisce automaticamente \textbf{grafi di oggetti}, permettendo di salvare interi alberi o reti di oggetti che referenziano gli uni gli altri. Un aspetto particolare è che mantiene l'\textbf{identità degli oggetti}: se due riferimenti A e B puntano al medesimo oggetto C nel momento della serializzazione, dopo la deserializzazione questa relazione di condivisione viene preservata, anziché creare due copie indipendenti dell'oggetto.

\subsubsection{L'interfaccia Serializable}

Per rendere una classe serializzabile, è sufficiente implementare l'interfaccia marker \texttt{java.io.Serializable}:

\begin{lstlisting}
import java.io.Serializable;

public class Studente implements Serializable {
    private String nome;
    private String cognome;
    private int matricola;
    private double media;

    // Costruttori, getter, setter, toString...
}
\end{lstlisting}

\texttt{Serializable} è un'interfaccia \textbf{marker} (senza metodi) che indica alla JVM che la classe può essere serializzata. Non implementarla causa \texttt{NotSerializableException} a runtime.

\subsubsection{Come funziona la serializzazione}

Durante il processo di serializzazione, Java esegue una serie di passaggi ben definiti. Innanzitutto, scrive i \textbf{metadata} della classe, cioè informazioni critiche come il nome della classe, la versione, e la struttura dei campi. Successivamente, scrive i \textbf{valori di tutti i campi} non marcati come transient, preservando lo stato completo dell'istanza. Se un campo contiene a sua volta un oggetto, Java lo \textbf{serializza ricorsivamente}, garantendo che interi grafi di oggetti vengano salvati completamente. Un aspetto sofisticato è la \textbf{gestione dei riferimenti circolari}: Java memorizza ogni oggetto una sola volta nel file, anche se è referenziato da più posizioni, evitando loop infiniti e duplicazioni. Il risultato è uno \textbf{stream binario compatto} ottimizzato per la memorizzazione.

Durante la deserializzazione, il processo è inverso ma simmetrico. Java legge i metadata dalla classe e verifica la compatibilità con la versione della classe nel progetto corrente. In seguito, alloca memoria per l'oggetto, e questo è un aspetto importante: non chiama il costruttore, ma direttamente popola i campi con i valori deserializzati salvati precedentemente. Infine, Java ricostruisce i \textbf{riferimenti tra oggetti}, ripristinando la stessa struttura di connessione che esisteva al momento della serializzazione.

\subsubsection{ObjectOutputStream e ObjectInputStream}

Java fornisce due classi specializzate per la serializzazione:

\begin{itemize}
    \item \texttt{ObjectOutputStream}: scrive oggetti su uno stream
    \item \texttt{ObjectInputStream}: legge oggetti da uno stream
\end{itemize}

Metodi principali di \texttt{ObjectOutputStream} e \texttt{ObjectInputStream}:

\begin{lstlisting}
// Scrittura
ObjectOutputStream oos = new ObjectOutputStream(
    new FileOutputStream("studenti.dat")
);
oos.writeObject(oggetto);  // Serializza e scrive l'oggetto
oos.close();

// Lettura
ObjectInputStream ois = new ObjectInputStream(
    new FileInputStream("studenti.dat")
);
Studente s = (Studente) ois.readObject();  // Legge e deserializza
ois.close();
\end{lstlisting}

\begin{figure}[h]
\centering
\begin{tikzpicture}[
    node distance=3cm,
    block/.style={
        rectangle,
        draw=blue!60,
        fill=blue!10,
        very thick,
        minimum width=2.5cm,
        minimum height=1cm,
        align=center,
        font=\small
    },
    arrow/.style={
        ->,
        >=stealth,
        very thick
    }
]

% Parte superiore - Scrittura (Serializzazione)
\node[block, fill=green!10, draw=green!60] (obj1) {Oggetto\\Studente};
\node[block, right of=obj1, fill=orange!10, draw=orange!60] (oos) {Object\\Output\\Stream};
\node[block, right of=oos, fill=red!10, draw=red!60] (file1) {File\\studenti.dat\\(binario)};

\draw[arrow, green!60, very thick] (obj1) -- (oos) node[midway, above, font=\footnotesize] {oos.writeObject()};
\draw[arrow, orange!60, very thick] (oos) -- (file1) node[midway, above, font=\footnotesize] {byte stream};

% Etichetta per la direzione
\node[above of=oos, node distance=1.5cm, font=\small\bfseries] {Serializzazione (Scrittura)};

% Parte inferiore - Lettura (Deserializzazione)
\node[block, fill=red!10, draw=red!60, below of=file1, node distance=3cm] (file2) {File\\studenti.dat\\(binario)};
\node[block, left of=file2, fill=purple!10, draw=purple!60] (ois) {Object\\Input\\Stream};
\node[block, left of=ois, fill=green!10, draw=green!60] (obj2) {Oggetto\\Studente};

\draw[arrow, red!60, very thick] (file2) -- (ois) node[midway, above, font=\footnotesize] {byte stream};
\draw[arrow, purple!60, very thick] (ois) -- (obj2) node[midway, above, font=\footnotesize] {ois.readObject()};

% Etichetta per la direzione
\node[below of=ois, node distance=1.5cm, font=\small\bfseries] {Deserializzazione (Lettura)};

\end{tikzpicture}
\caption{Processo di serializzazione e deserializzazione: gli oggetti vengono convertiti in stream di byte per essere salvati su file, e poi ricostruiti leggendo il file}
\label{fig:serializzazione}
\end{figure}

\subsection{Esempio completo: Serializzazione di oggetti Studente}

Vediamo ora un esempio completo che dimostra scrittura e lettura di oggetti su file.

\subsubsection{Classe Studente serializzabile}

\begin{lstlisting}
import java.io.Serializable;

public class Studente implements Serializable {
    // Serial Version UID per compatibilita
    private static final long serialVersionUID = 1L;

    private String nome;
    private String cognome;
    private int matricola;
    private double media;

    public Studente(String nome, String cognome, int matricola, double media) {
        this.nome = nome;
        this.cognome = cognome;
        this.matricola = matricola;
        this.media = media;
    }

    // Getter
    public String getNome() { return nome; }
    public String getCognome() { return cognome; }
    public int getMatricola() { return matricola; }
    public double getMedia() { return media; }

    @Override
    public String toString() {
        return String.format("Studente[%s %s, mat: %d, media: %.2f]",
            nome, cognome, matricola, media);
    }
}
\end{lstlisting}

\subsubsection{Scrittura di array di oggetti su file}

\begin{lstlisting}
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;

public class ScriviStudenti {
    public static void main(String[] args) {
        // Creiamo un array di studenti
        Studente[] studenti = {
            new Studente("Mario", "Rossi", 12345, 27.5),
            new Studente("Laura", "Bianchi", 12346, 29.0),
            new Studente("Giuseppe", "Verdi", 12347, 25.8),
            new Studente("Anna", "Neri", 12348, 30.0)
        };

        // Scriviamo l'array su file usando try-with-resources
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("studenti.dat"))) {

            // Scriviamo l'intero array come singolo oggetto
            oos.writeObject(studenti);

            System.out.println("Array di " + studenti.length +
                             " studenti salvato con successo!");

        } catch (IOException e) {
            System.out.println("Errore durante la scrittura: " +
                             e.getMessage());
        }
    }
}
\end{lstlisting}

\subsubsection{Lettura di oggetti da file}

\begin{lstlisting}
import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

public class LeggiStudenti {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("studenti.dat"))) {

            // Leggiamo l'array e facciamo il cast
            Studente[] studenti = (Studente[]) ois.readObject();

            System.out.println("Studenti caricati: " + studenti.length);
            System.out.println();

            // Stampiamo ogni studente
            for (Studente s : studenti) {
                System.out.println(s);
            }

        } catch (IOException e) {
            System.out.println("Errore I/O: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Classe Studente non trovata: " +
                             e.getMessage());
        }
    }
}
\end{lstlisting}

\subsubsection{Scrittura sequenziale di oggetti singoli}

Un approccio alternativo è scrivere gli oggetti uno alla volta. Questo richiede una gestione particolare della fine del file:

\begin{lstlisting}
import java.io.*;

public class ScriviStudentiSequenziali {
    public static void main(String[] args) {
        Studente[] studenti = {
            new Studente("Mario", "Rossi", 12345, 27.5),
            new Studente("Laura", "Bianchi", 12346, 29.0),
            new Studente("Giuseppe", "Verdi", 12347, 25.8)
        };

        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("studenti_seq.dat"))) {

            // Scriviamo prima il numero di oggetti
            oos.writeInt(studenti.length);

            // Poi scriviamo ogni oggetto
            for (Studente s : studenti) {
                oos.writeObject(s);
            }

            System.out.println(studenti.length + " studenti salvati!");

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsubsection{Lettura con gestione di EOFException}

Quando leggiamo oggetti scritti sequenzialmente, dobbiamo gestire la \texttt{EOFException} che indica la fine del file:

\begin{lstlisting}
import java.io.*;

public class LeggiStudentiSequenziali {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("studenti_seq.dat"))) {

            // Leggiamo prima il numero di oggetti
            int numStudenti = ois.readInt();

            System.out.println("Lettura di " + numStudenti + " studenti:");
            System.out.println();

            // Leggiamo esattamente quel numero di oggetti
            for (int i = 0; i < numStudenti; i++) {
                Studente s = (Studente) ois.readObject();
                System.out.println((i + 1) + ". " + s);
            }

        } catch (EOFException e) {
            // Fine file raggiunta (se non usiamo il contatore)
            System.out.println("Fine lettura oggetti");
        } catch (IOException e) {
            System.out.println("Errore I/O: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Classe non trovata: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsubsection{Approccio alternativo: lettura fino a EOFException}

Se non conosciamo in anticipo il numero di oggetti:

\begin{lstlisting}
import java.io.*;
import java.util.ArrayList;

public class LeggiStudentiDinamico {
    public static void main(String[] args) {
        ArrayList<Studente> studenti = new ArrayList<>();

        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("studenti.dat"))) {

            // Continua a leggere finche non raggiunge EOF
            while (true) {
                try {
                    Studente s = (Studente) ois.readObject();
                    studenti.add(s);
                } catch (EOFException e) {
                    // Fine del file - esco dal loop
                    break;
                }
            }

            System.out.println("Letti " + studenti.size() + " studenti:");
            for (Studente s : studenti) {
                System.out.println(s);
            }

        } catch (IOException e) {
            System.out.println("Errore I/O: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Classe non trovata: " + e.getMessage());
        }
    }
}
\end{lstlisting}

\subsection{Tabella comparativa: File Testo vs File Oggetti}

\begin{table}[h]
\centering
\small
\begin{tabular}{|p{3.5cm}|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{Criterio} & \textbf{File di Testo} & \textbf{File di Oggetti (Serializzati)} \\
\hline
\textbf{Leggibilità umana} & Leggibili con editor di testo & Binari, non leggibili direttamente \\
\hline
\textbf{Performance} & Più lenti (parsing, conversioni) & Più veloci (formato binario diretto) \\
\hline
\textbf{Dimensione file} & Maggiore (rappresentazione testuale) & Minore (formato binario compatto) \\
\hline
\textbf{Portabilità} & Massima (funziona ovunque) & Limitata a Java (versione compatibile) \\
\hline
\textbf{Interoperabilità} & Eccellente (qualsiasi linguaggio) & Solo Java (o linguaggi JVM) \\
\hline
\textbf{Uso tipico} & Config, log, CSV, export dati & Cache, sessioni, stato applicazione \\
\hline
\textbf{Complessità codice} & Richiede parsing manuale & Automatico (readObject/writeObject) \\
\hline
\textbf{Preservazione tipo} & No (tutto diventa stringa) & Sì (tipo esatto dell'oggetto) \\
\hline
\textbf{Grafi di oggetti} & Difficile (relazioni complesse) & Automatico (riferimenti preservati) \\
\hline
\textbf{Debugging} & Facile (ispezione visiva) & Difficile (tool specifici necessari) \\
\hline
\textbf{Evoluzione classe} & Flessibile (nuovi campi OK) & Richiede gestione serialVersionUID \\
\hline
\textbf{Sicurezza} & Relativamente sicuro & Rischi deserializzazione (exploit) \\
\hline
\end{tabular}
\caption{Confronto dettagliato tra file di testo e file di oggetti serializzati}
\end{table}

\subsection{La keyword transient}

A volte non tutti i campi di un oggetto devono essere salvati. La keyword \texttt{transient} permette di escludere specifici campi dalla serializzazione.

\begin{nota}
\textbf{La keyword transient}

Campi marcati come \texttt{transient} vengono ignorati durante la serializzazione. Dopo la deserializzazione, avranno il valore di default del loro tipo (0 per numeri, null per oggetti, false per boolean).

\textbf{Quando usare transient:} Dovresti marcare un campo come transient quando contiene dati \textbf{derivati/calcolabili}, come l'età di una persona calcolata dalla data di nascita, dato che può essere ricalcolato facilmente al momento della deserializzazione. Usa transient per \textbf{cache} temporanee, che sono facilmente ricostruibili dopo il caricamento dell'oggetto. È cruciale per informazioni \textbf{sensibili} come password e token di autenticazione, che non dovrebbero mai essere persisted su disco. Infine, usa transient per \textbf{riferimenti a risorse non serializzabili} come thread, connessioni a database, o stream, che non possono essere serializzati e causerebbero eccezioni.

\textbf{Esempio:}
\begin{lstlisting}
public class Utente implements Serializable {
    private String username;
    private transient String password;  // Non salvata
    private transient int contatoreLogin;  // Azzera a 0
    private String email;

    // Dopo deserializzazione: username e email OK,
    // password = null, contatoreLogin = 0
}
\end{lstlisting}
\end{nota}

\subsection{VersionUID e compatibilità}

\begin{attenzione}
\textbf{Serial Version UID e problemi di compatibilità}

Ogni classe serializzabile dovrebbe dichiarare esplicitamente un \texttt{serialVersionUID}:

\begin{lstlisting}
private static final long serialVersionUID = 1L;
\end{lstlisting}

\textbf{Perché è importante:} Per comprendere l'importanza del serialVersionUID, è necessario capire come Java gestisce la compatibilità tra versioni. Java genera automaticamente un UID basato sulla struttura della classe, calcolandolo dalle firme dei metodi e dai nomi dei campi. Se modifichi la classe durante lo sviluppo, ad esempio aggiungendo un nuovo campo o cambiando il tipo di un campo esistente, l'UID generato automaticamente cambia. Quando la JVM tenta di deserializzare un oggetto serializzato con una versione precedente della classe, gli UID non corrispondono e genera un'eccezione \texttt{InvalidClassException}. Dichiarare esplicitamente il serialVersionUID ti permette di controllare manualmente la compatibilità tra versioni: puoi aggiornare solo il campo quando decidi consapevolmente di introdurre un cambiamento incompatibile, anziché romperlo per ogni modifica.

\textbf{Gestione evoluzione classe:} Non tutte le modifiche a una classe serializzata sono uguali dal punto di vista della compatibilità con versioni precedenti. Modifiche \textbf{compatibili} includono l'aggiungere nuovi campi alla classe: i dati deserializzati avranno il valore di default per i nuovi campi. Un'altra modifica compatibile è rendere transient uno o più campi esistenti. Al contrario, modifiche \textbf{incompatibili} includono il cambio del tipo di un campo esistente, che rende impossibile mappare i dati serializzati al nuovo tipo, oppure la rimozione di campi non-transient, dato che i dati serializzati contengono ancora quei campi che la nuova classe non si aspetta.

\textbf{Best practice:} Quando modifichi una classe serializzata, incrementa il serialVersionUID solo se vuoi forzare incompatibilità. Altrimenti mantieni lo stesso valore per permettere deserializzazione (con limitazioni).

\textbf{Rischi sicurezza:} La deserializzazione può essere sfruttata per attacchi. Non deserializzare mai dati da fonti non fidate senza validazione. Considera alternative come JSON per scambi esterni.
\end{attenzione}

\section{Gestione delle risorse con try-with-resources}

A partire da Java 7, la sintassi \textbf{try-with-resources} semplifica notevolmente la gestione degli stream, chiudendoli automaticamente anche in caso di eccezioni.

\subsection{Sintassi try-with-resources}

\begin{lstlisting}
try (Risorsa r = new Risorsa()) {
    // Usa la risorsa
} catch (Exception e) {
    // Gestisci l'eccezione
}
// La risorsa viene chiusa automaticamente qui
\end{lstlisting}

La risorsa deve implementare l'interfaccia \texttt{AutoCloseable} (che include \texttt{Closeable}). Tutti gli stream Java implementano questa interfaccia.

\subsection{Esempio 7: Refactoring con try-with-resources}

\begin{lstlisting}
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class TryWithResourcesEsempio {
    public static void main(String[] args) {
        // Nessun finally necessario, chiusura automatica!
        try (BufferedReader br = new BufferedReader(
                new FileReader("dati.txt"))) {

            String riga;
            while ((riga = br.readLine()) != null) {
                System.out.println(riga);
            }

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
        // br viene chiuso automaticamente anche se si verifica un'eccezione
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio mostra il pattern try-with-resources, introdotto in Java 7, che rivoluziona la gestione delle risorse eliminando la necessità di blocchi finally verbosi. Lo stream viene dichiarato direttamente nella clausola try e viene chiuso automaticamente.

\textbf{Meccanismo automatico di chiusura:} Quando il blocco try termina (normalmente o per eccezione), Java chiama automaticamente il metodo \texttt{risorsa.close()} su tutte le risorse dichiarate nella clausola try-with-resources. Questo accade \textit{prima} dell'esecuzione del blocco catch, garantendo che le risorse siano liberate anche se si verifica un'eccezione.

\textbf{Gestione delle eccezioni durante la chiusura:} Se sia il codice nel try che il metodo \texttt{risorsa.close()} lanciano eccezioni, quella del codice principale viene propagata mentre quella di \texttt{risorsa.close()} viene soppressa (ma rimane accessibile tramite il metodo \texttt{exception.getSuppressed()}).

\textbf{Vantaggi rispetto al finally:} Il codice è più conciso (40-50\% in meno), meno soggetto a errori (impossibile dimenticare la chiusura), più sicuro (gestione corretta di eccezioni multiple), e più leggibile (focus sulla logica principale).

\textbf{Requisito AutoCloseable:} Solo oggetti che implementano \texttt{AutoCloseable} (o la sua sottointerfaccia \texttt{Closeable}) possono essere usati. Fortunatamente, tutti gli stream Java implementano questa interfaccia.

\subsection{Esempio 8: Risorse multiple}

\begin{lstlisting}
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopiaConTWR {
    public static void main(String[] args) {
        // Dichiarazione di più risorse separate da punto e virgola
        try (BufferedReader input = new BufferedReader(
                new FileReader("input.txt"));
             BufferedWriter output = new BufferedWriter(
                new FileWriter("output.txt"))) {

            String riga;
            while ((riga = input.readLine()) != null) {
                output.write(riga);
                output.newLine();
            }

            System.out.println("Copia completata!");

        } catch (IOException e) {
            System.out.println("Errore: " + e.getMessage());
        }
        // Entrambe le risorse vengono chiuse automaticamente
        // nell'ordine inverso rispetto alla dichiarazione
    }
}
\end{lstlisting}

\subsection{Analisi del codice}

Questo esempio dimostra l'uso di try-with-resources con risorse multiple, separando le dichiarazioni con punto e virgola. Entrambi gli stream (input e output) vengono gestiti automaticamente, semplificando notevolmente la gestione rispetto al pattern try-finally tradizionale.

\textbf{Ordine di chiusura:} Le risorse vengono chiuse in ordine \textit{inverso} rispetto alla dichiarazione. In questo caso, \texttt{output} viene chiuso prima di \texttt{input}. Questo è importante quando ci sono dipendenze tra risorse: la risorsa dichiarata per prima può essere usata per inizializzare quella successiva.

\textbf{Pattern decorator nella dichiarazione:} L'esempio mostra come comporre stream (pattern Decorator) direttamente nella clausola try: \texttt{new BufferedReader(new FileReader(...))}. Entrambi gli oggetti creati (BufferedReader e FileReader) vengono chiusi, ma è sufficiente dichiarare solo il più esterno.

\textbf{Garanzia di consistenza:} Il flush automatico durante la chiusura dell'oggetto \texttt{BufferedWriter} (tramite il metodo \texttt{output.close()}) garantisce che tutti i dati bufferizzati vengano scritti su disco prima che il programma termini, anche in caso di eccezioni.

\textbf{Confronto con finally:} Senza try-with-resources, questo codice richiederebbe due variabili null-initialized, due blocchi try-catch annidati nel finally, quattro controlli null, e gestione separata di eccezioni multiple. Il risultato sarebbe di circa 30-40 righe invece di 15.

\textbf{Best practice moderna:} Questo è il pattern standard per operazioni su file in Java moderno. Usare try-finally manualmente è considerato obsoleto (tranne per compatibilità con Java 6 o precedenti).

\begin{attenzione}
Try-with-resources è disponibile solo da Java 7 in poi. Se lavori con versioni precedenti, devi gestire la chiusura manualmente nel blocco finally.
\end{attenzione}

\section*{Riepilogo}

In questo capitolo abbiamo imparato:

\begin{itemize}
    \item Gli \textbf{stream} sono il meccanismo principale per gestire I/O in Java
    \item Esistono stream di \textbf{byte} (per file binari) e di \textbf{caratteri} (per file di testo)
    \item \textbf{FileInputStream/FileOutputStream} operano a livello di byte
    \item \textbf{BufferedReader/BufferedWriter} sono ottimizzati per file di testo e forniscono metodi comodi come \texttt{br.readLine()} (dove \texttt{br} è un oggetto \texttt{BufferedReader})
    \item Il \textbf{buffering} migliora drasticamente le performance
    \item \textbf{Try-with-resources} garantisce la chiusura automatica degli stream
    \item È fondamentale chiudere sempre gli stream per liberare le risorse di sistema
\end{itemize}

\begin{nota}
\textbf{Best Practices:}
\begin{itemize}
    \item Usa sempre try-with-resources quando possibile
    \item Preferisci BufferedReader/BufferedWriter per file di testo
    \item Usa buffer di dimensione adeguata (1024-8192 byte) per operazioni su file binari
    \item Gestisci sempre le eccezioni IOException
    \item Verifica che i file esistano prima di leggerli
\end{itemize}
\end{nota}

\begin{errore}
\textbf{Errori comuni da evitare:}
\begin{itemize}
    \item Dimenticare di chiudere gli stream
    \item Non gestire le eccezioni IOException
    \item Leggere byte per byte senza usare buffer (molto lento)
    \item Confondere stream di byte con stream di caratteri
    \item Non verificare se il metodo \texttt{stream.read()} ha restituito -1 (fine file)
\end{itemize}
\end{errore}

\section*{Riferimenti per approfondimenti}

\begin{itemize}
    \item Oracle Java Tutorial - I/O Streams: \url{https://docs.oracle.com/javase/tutorial/essential/io/streams.html}
    \item Java API Documentation - Package java.io
    \item Effective Java (Joshua Bloch) - Capitolo sulla gestione delle risorse
\end{itemize}
