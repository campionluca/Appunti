% Appendice B — Esercizi e Soluzioni
\chapter{Esercizi e Soluzioni}

\section{Introduzione}
Questa appendice contiene esercizi pratici organizzati per difficoltà crescente, completi di soluzioni dettagliate. Gli esercizi coprono tutti gli argomenti del corso e sono progettati per consolidare le competenze acquisite.

\section{Esercizi Base: File System e Comandi}

\subsection{Esercizio 1: Navigazione e Operazioni Base}
\textbf{Obiettivo}: Pratica con comandi base di navigazione e manipolazione file.

\textbf{Task}:
\begin{enumerate}
\item Creare directory \texttt{/tmp/lab} con sottodirectory \texttt{docs}, \texttt{scripts}, \texttt{backup}
\item Creare 5 file vuoti in \texttt{docs}: \texttt{file1.txt} ... \texttt{file5.txt}
\item Copiare tutti i .txt in \texttt{backup}
\item Rinominare \texttt{file1.txt} in \texttt{main.txt}
\item Eliminare \texttt{file5.txt}
\item Listare ricorsivamente tutta la struttura
\end{enumerate}

\textbf{Soluzione}:
\begin{lstlisting}
# 1. Creare directory
mkdir -p /tmp/lab/{docs,scripts,backup}

# 2. Creare file
cd /tmp/lab/docs
touch file{1..5}.txt
# Alternativa:
# for i in {1..5}; do touch "file$i.txt"; done

# 3. Copiare file
cp *.txt ../backup/
# Alternativa:
# cp file*.txt /tmp/lab/backup/

# 4. Rinominare
mv file1.txt main.txt

# 5. Eliminare
rm file5.txt

# 6. Listare ricorsivamente
cd /tmp/lab
ls -R
# Alternativa con tree (se installato):
# tree /tmp/lab
\end{lstlisting}

\subsection{Esercizio 2: Ricerca File}
\textbf{Obiettivo}: Usare \texttt{find} per ricerche avanzate.

\textbf{Task}:
\begin{enumerate}
\item Trovare tutti i file .log in /var/log modificati negli ultimi 7 giorni
\item Trovare file più grandi di 100MB in /home
\item Trovare directory vuote in /tmp
\item Trovare file con permessi 777 (pericolosi per sicurezza)
\item Eliminare tutti i file .tmp più vecchi di 30 giorni
\end{enumerate}

\textbf{Soluzione}:
\begin{lstlisting}
# 1. File .log recenti
find /var/log -name "*.log" -mtime -7

# 2. File grandi
find /home -type f -size +100M

# 3. Directory vuote
find /tmp -type d -empty

# 4. File 777 (potenzialmente insicuri)
find / -type f -perm 777 2>/dev/null

# 5. Eliminare .tmp vecchi
find /tmp -name "*.tmp" -type f -mtime +30 -delete
# Safer con conferma:
# find /tmp -name "*.tmp" -type f -mtime +30 -ok rm {} \;
\end{lstlisting}

\subsection{Esercizio 3: Permessi}
\textbf{Obiettivo}: Gestire permessi file e directory.

\textbf{Task}:
\begin{enumerate}
\item Creare script \texttt{backup.sh} con permessi esecuzione solo per owner
\item Creare directory \texttt{shared} accessibile a tutti ma solo owner può eliminare file
\item Creare file \texttt{config.conf} leggibile e scrivibile solo da owner
\item Trovare tutti i file SUID nel sistema
\end{enumerate}

\textbf{Soluzione}:
\begin{lstlisting}
# 1. Script eseguibile solo da owner
touch backup.sh
chmod 700 backup.sh
# Verifica:
ls -l backup.sh  # rwx------

# 2. Directory condivisa con sticky bit
mkdir shared
chmod 1777 shared
# Verifica:
ls -ld shared    # drwxrwxrwt

# 3. File config privato
touch config.conf
chmod 600 config.conf
# Verifica:
ls -l config.conf  # rw-------

# 4. Trovare file SUID
sudo find / -perm -4000 -type f -ls 2>/dev/null
# Output tipico include: /usr/bin/passwd, /usr/bin/sudo, etc.
\end{lstlisting}

\section{Esercizi Intermedi: Text Processing}

\subsection{Esercizio 4: Log Analysis}
\textbf{Obiettivo}: Analizzare log web server.

Dato file \texttt{access.log} con formato Apache:
\begin{lstlisting}
192.168.1.1 - - [15/Jan/2025:10:30:45] "GET /index.html HTTP/1.1" 200 1234
192.168.1.2 - - [15/Jan/2025:10:31:12] "GET /about.html HTTP/1.1" 200 5678
192.168.1.1 - - [15/Jan/2025:10:32:01] "GET /api/data HTTP/1.1" 404 0
\end{lstlisting}

\textbf{Task}:
\begin{enumerate}
\item Contare quante richieste per ogni IP
\item Elencare tutti gli status code con conteggi
\item Trovare le 10 pagine più richieste
\item Calcolare traffico totale (somma byte)
\end{enumerate}

\textbf{Soluzione}:
\begin{lstlisting}
# 1. Richieste per IP
awk '{print $1}' access.log | sort | uniq -c | sort -rn
# Output:
# 2 192.168.1.1
# 1 192.168.1.2

# 2. Status code con conteggi
awk '{print $9}' access.log | sort | uniq -c | sort -rn
# Output:
# 2 200
# 1 404

# 3. Top 10 pagine richieste
awk '{print $7}' access.log | sort | uniq -c | sort -rn | head -10
# $7 è il campo URL

# 4. Traffico totale
awk '{sum += $10} END {print "Total bytes:", sum}' access.log
# $10 è il campo byte

# Bonus: Richieste per status code 404
awk '$9 == 404 {print $7}' access.log

# Richieste per ora
awk -F'[: \\[]' '{print $3":"$4}' access.log | sort | uniq -c
\end{lstlisting}

\subsection{Esercizio 5: CSV Processing}
\textbf{Obiettivo}: Elaborare file CSV con dati.

Dato file \texttt{sales.csv}:
\begin{lstlisting}
Date,Product,Quantity,Price
2025-01-01,Laptop,2,1000
2025-01-01,Mouse,5,25
2025-01-02,Laptop,1,1000
2025-01-02,Keyboard,3,75
\end{lstlisting}

\textbf{Task}:
\begin{enumerate}
\item Calcolare revenue totale (Quantity × Price)
\item Trovare prodotto con vendite maggiori
\item Calcolare revenue per data
\item Estrarre solo vendite di Laptop
\end{enumerate}

\textbf{Soluzione}:
\begin{lstlisting}
# 1. Revenue totale
awk -F',' 'NR>1 {total += $3*$4} END {print "Total:", total}' sales.csv
# Output: Total: 3300

# 2. Prodotto con vendite maggiori
awk -F',' 'NR>1 {sales[$2] += $3*$4}
           END {for (p in sales) print p, sales[p]}' sales.csv | \
    sort -k2 -rn | head -1
# Output: Laptop 3000

# 3. Revenue per data
awk -F',' 'NR>1 {revenue[$1] += $3*$4}
           END {for (d in revenue) print d, revenue[d]}' sales.csv | sort
# Output:
# 2025-01-01 2125
# 2025-01-02 1225

# 4. Solo vendite Laptop
awk -F',' '$2 == "Laptop"' sales.csv
# Alternativa con grep:
grep "Laptop" sales.csv

# Bonus: Media prezzo per prodotto
awk -F',' 'NR>1 {sum[$2] += $4; count[$2]++}
           END {for (p in sum) print p, sum[p]/count[p]}' sales.csv
\end{lstlisting}

\section{Esercizi Avanzati: Scripting}

\subsection{Esercizio 6: Backup Script}
\textbf{Obiettivo}: Creare script backup automatico.

\textbf{Requisiti}:
\begin{itemize}
\item Backup di /home/user/documents
\item Formato: documents\_YYYYMMDD.tar.gz
\item Salva in /backup/
\item Mantieni solo ultimi 7 backup
\item Log operazioni in /var/log/backup.log
\item Exit code appropriato
\end{itemize}

\textbf{Soluzione}:
\begin{lstlisting}
#!/bin/bash
# backup_docs.sh - Automated document backup

set -euo pipefail

# Configuration
SOURCE="/home/user/documents"
BACKUP_DIR="/backup"
LOG_FILE="/var/log/backup.log"
DATE=$(date +%Y%m%d)
BACKUP_FILE="documents_${DATE}.tar.gz"
RETENTION=7

# Logging
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Error handler
error_exit() {
    log "ERROR: $1"
    exit "${2:-1}"
}

# Main
main() {
    log "Starting backup of $SOURCE"

    # Validate source
    if [ ! -d "$SOURCE" ]; then
        error_exit "Source directory not found: $SOURCE" 1
    fi

    # Create backup directory
    mkdir -p "$BACKUP_DIR" || error_exit "Cannot create backup dir" 1

    # Perform backup
    log "Creating backup: $BACKUP_FILE"
    if tar -czf "$BACKUP_DIR/$BACKUP_FILE" -C "$(dirname "$SOURCE")" \
            "$(basename "$SOURCE")" 2>> "$LOG_FILE"; then
        log "Backup created successfully"

        # Verify backup
        if tar -tzf "$BACKUP_DIR/$BACKUP_FILE" > /dev/null 2>&1; then
            size=$(du -sh "$BACKUP_DIR/$BACKUP_FILE" | awk '{print $1}')
            log "Backup verified OK (size: $size)"
        else
            error_exit "Backup verification failed" 1
        fi
    else
        error_exit "Backup creation failed" 1
    fi

    # Cleanup old backups
    log "Cleaning up old backups (retention: $RETENTION days)"
    find "$BACKUP_DIR" -name "documents_*.tar.gz" -mtime +$RETENTION -delete

    log "Backup completed successfully"
    exit 0
}

main "$@"
\end{lstlisting}

\textbf{Test}:
\begin{lstlisting}
# Test script
chmod +x backup_docs.sh
sudo ./backup_docs.sh

# Verifica backup creato
ls -lh /backup/

# Verifica log
tail /var/log/backup.log

# Aggiungi a cron per esecuzione automatica
# crontab -e
# 0 2 * * * /usr/local/bin/backup_docs.sh
\end{lstlisting}

\subsection{Esercizio 7: System Monitor}
\textbf{Obiettivo}: Script monitoring con alerting.

\textbf{Requisiti}:
\begin{itemize}
\item Monitora: CPU, memoria, disco
\item Threshold: CPU>80\%, MEM>85\%, DISK>90\%
\item Invia alert se superato threshold
\item Log metrics in JSON
\item Esegui ogni 5 minuti via cron
\end{itemize}

\textbf{Soluzione}:
\begin{lstlisting}
#!/bin/bash
# system_monitor.sh - System resource monitoring

set -euo pipefail

# Configuration
METRICS_FILE="/var/lib/monitor/metrics.json"
LOG_FILE="/var/log/system_monitor.log"
ALERT_EMAIL="admin@example.com"

# Thresholds
CPU_THRESHOLD=80
MEM_THRESHOLD=85
DISK_THRESHOLD=90

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Get metrics
get_cpu_usage() {
    top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1
}

get_mem_usage() {
    free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}'
}

get_disk_usage() {
    df -h / | awk 'NR==2 {print $5}' | sed 's/%//'
}

# Check thresholds
check_threshold() {
    local metric=$1
    local value=$2
    local threshold=$3

    if [ "$value" -gt "$threshold" ]; then
        log "ALERT: $metric at ${value}% (threshold: ${threshold}%)"
        echo -e "${RED}✗${NC} $metric: ${value}% > ${threshold}%"
        return 1
    else
        echo -e "${GREEN}✓${NC} $metric: ${value}%"
        return 0
    fi
}

# Send alert
send_alert() {
    local message=$1

    log "Sending alert email"
    echo "$message" | mail -s "System Alert: $(hostname)" "$ALERT_EMAIL"
}

# Save metrics as JSON
save_metrics() {
    local cpu=$1
    local mem=$2
    local disk=$3

    mkdir -p "$(dirname "$METRICS_FILE")"

    # Create JSON
    cat > "$METRICS_FILE" << EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "hostname": "$(hostname)",
  "metrics": {
    "cpu_percent": $cpu,
    "memory_percent": $mem,
    "disk_percent": $disk
  }
}
EOF
}

# Main
main() {
    log "Starting system check"

    # Collect metrics
    CPU=$(get_cpu_usage)
    MEM=$(get_mem_usage)
    DISK=$(get_disk_usage)

    log "Metrics - CPU: ${CPU}%, MEM: ${MEM}%, DISK: ${DISK}%"

    # Check thresholds
    alerts=()
    check_threshold "CPU" "$CPU" "$CPU_THRESHOLD" || alerts+=("CPU: ${CPU}%")
    check_threshold "Memory" "$MEM" "$MEM_THRESHOLD" || alerts+=("Memory: ${MEM}%")
    check_threshold "Disk" "$DISK" "$DISK_THRESHOLD" || alerts+=("Disk: ${DISK}%")

    # Save metrics
    save_metrics "$CPU" "$MEM" "$DISK"

    # Send alert if needed
    if [ ${#alerts[@]} -gt 0 ]; then
        alert_msg="System resources exceeded thresholds:\n\n"
        for alert in "${alerts[@]}"; do
            alert_msg+="- $alert\n"
        done
        send_alert "$alert_msg"
        exit 1
    fi

    log "All checks passed"
    exit 0
}

main "$@"
\end{lstlisting}

\textbf{Setup}:
\begin{lstlisting}
# Installa e configura
sudo mkdir -p /var/lib/monitor
sudo chmod +x system_monitor.sh
sudo cp system_monitor.sh /usr/local/bin/

# Aggiungi a cron
sudo crontab -e
# */5 * * * * /usr/local/bin/system_monitor.sh

# Test manuale
sudo /usr/local/bin/system_monitor.sh

# Verifica metrics
cat /var/lib/monitor/metrics.json | jq .
\end{lstlisting}

\subsection{Esercizio 8: User Management Script}
\textbf{Obiettivo}: Script automazione creazione utenti.

\textbf{Requisiti}:
\begin{itemize}
\item Legge lista utenti da CSV (username,fullname,groups)
\item Crea utenti con home directory
\item Aggiunge a gruppi specificati
\item Genera password casuale
\item Invia credenziali via email
\item Log tutte le operazioni
\end{itemize}

\textbf{File users.csv}:
\begin{lstlisting}
username,fullname,groups
alice,Alice Smith,developers,sudo
bob,Bob Jones,developers
charlie,Charlie Brown,admins
\end{lstlisting}

\textbf{Soluzione}:
\begin{lstlisting}
#!/bin/bash
# create_users.sh - Bulk user creation from CSV

set -euo pipefail

# Configuration
CSV_FILE="${1:-users.csv}"
LOG_FILE="/var/log/user_creation.log"
PASSWORD_LENGTH=16

log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

error_exit() {
    log "ERROR: $1"
    exit 1
}

# Generate random password
generate_password() {
    tr -dc 'A-Za-z0-9!@#$%^&*' < /dev/urandom | head -c "$PASSWORD_LENGTH"
}

# Create user
create_user() {
    local username=$1
    local fullname=$2
    local groups=$3

    log "Processing user: $username"

    # Check if user exists
    if id "$username" &>/dev/null; then
        log "User $username already exists, skipping"
        return 0
    fi

    # Create user
    log "Creating user $username ($fullname)"
    if ! useradd -m -c "$fullname" -s /bin/bash "$username"; then
        log "ERROR: Failed to create user $username"
        return 1
    fi

    # Generate and set password
    local password
    password=$(generate_password)
    echo "$username:$password" | chpasswd

    # Add to groups
    if [ -n "$groups" ]; then
        log "Adding $username to groups: $groups"
        IFS=',' read -ra group_array <<< "$groups"
        for group in "${group_array[@]}"; do
            group=$(echo "$group" | xargs)  # trim whitespace
            if ! usermod -aG "$group" "$username"; then
                log "WARNING: Failed to add $username to group $group"
            fi
        done
    fi

    # Set password expiry (force change on first login)
    passwd -e "$username"

    # Send credentials email
    send_credentials "$username" "$fullname" "$password"

    log "User $username created successfully"
}

# Send credentials via email
send_credentials() {
    local username=$1
    local fullname=$2
    local password=$3
    local email="${username}@example.com"

    local message
    message=$(cat << EOF
Hello $fullname,

Your account has been created.

Username: $username
Password: $password

Please change your password on first login.

To login:
ssh $username@$(hostname)

Regards,
System Administration
EOF
)

    echo "$message" | mail -s "Account Created: $username" "$email"
    log "Credentials sent to $email"
}

# Process CSV file
process_csv() {
    local csv=$1

    if [ ! -f "$csv" ]; then
        error_exit "CSV file not found: $csv"
    fi

    log "Processing CSV file: $csv"

    # Read CSV (skip header)
    local line_num=0
    while IFS=',' read -r username fullname groups; do
        ((line_num++))

        # Skip header
        if [ $line_num -eq 1 ]; then
            continue
        fi

        # Trim whitespace
        username=$(echo "$username" | xargs)
        fullname=$(echo "$fullname" | xargs)
        groups=$(echo "$groups" | xargs)

        # Validate
        if [ -z "$username" ] || [ -z "$fullname" ]; then
            log "WARNING: Invalid line $line_num, skipping"
            continue
        fi

        create_user "$username" "$fullname" "$groups"

    done < "$csv"

    log "CSV processing completed"
}

# Main
main() {
    # Check if running as root
    if [ "$(id -u)" -ne 0 ]; then
        error_exit "Must run as root"
    fi

    log "=== Starting user creation ==="

    process_csv "$CSV_FILE"

    log "=== User creation completed ==="
}

main "$@"
\end{lstlisting}

\textbf{Usage}:
\begin{lstlisting}
# Preparare CSV
cat > users.csv << EOF
username,fullname,groups
alice,Alice Smith,developers,sudo
bob,Bob Jones,developers
charlie,Charlie Brown,admins
EOF

# Eseguire script
sudo chmod +x create_users.sh
sudo ./create_users.sh users.csv

# Verificare utenti creati
tail -3 /etc/passwd
grep alice /etc/group

# Verificare log
tail /var/log/user_creation.log
\end{lstlisting}

\section{Esercizi Network e SSH}

\subsection{Esercizio 9: Network Diagnostics}
\textbf{Obiettivo}: Script diagnostica problemi rete.

\textbf{Task}: Creare script che:
\begin{itemize}
\item Verifica interfaccia di rete up
\item Test connettività gateway
\item Test DNS resolution
\item Test connettività internet
\item Report completo con troubleshooting hints
\end{itemize}

\textbf{Soluzione}:
\begin{lstlisting}
#!/bin/bash
# network_diagnostics.sh - Network troubleshooting

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

ok() { echo -e "${GREEN}✓${NC} $*"; }
fail() { echo -e "${RED}✗${NC} $*"; }
warn() { echo -e "${YELLOW}!${NC} $*"; }

echo "=== Network Diagnostics ==="
echo ""

# 1. Check interface
echo "[1] Checking network interface..."
INTERFACE=$(ip route | grep default | awk '{print $5}' | head -1)

if [ -n "$INTERFACE" ]; then
    if ip link show "$INTERFACE" | grep -q "state UP"; then
        ok "Interface $INTERFACE is UP"
        IP=$(ip addr show "$INTERFACE" | grep "inet " | awk '{print $2}')
        echo "   IP: $IP"
    else
        fail "Interface $INTERFACE is DOWN"
        echo "   Try: sudo ip link set $INTERFACE up"
        exit 1
    fi
else
    fail "No default interface found"
    exit 1
fi

# 2. Check gateway
echo ""
echo "[2] Checking gateway connectivity..."
GATEWAY=$(ip route | grep default | awk '{print $3}' | head -1)

if [ -n "$GATEWAY" ]; then
    echo "   Gateway: $GATEWAY"
    if ping -c 2 -W 2 "$GATEWAY" > /dev/null 2>&1; then
        ok "Gateway $GATEWAY is reachable"
    else
        fail "Cannot reach gateway $GATEWAY"
        echo "   Check: ip route, physical connection"
        exit 1
    fi
else
    fail "No default gateway configured"
    echo "   Try: sudo ip route add default via GATEWAY_IP"
    exit 1
fi

# 3. Check DNS
echo ""
echo "[3] Checking DNS resolution..."
if nslookup google.com > /dev/null 2>&1; then
    ok "DNS resolution working"
    DNS=$(cat /etc/resolv.conf | grep nameserver | head -1 | awk '{print $2}')
    echo "   DNS server: $DNS"
else
    fail "DNS resolution failed"
    echo "   Check: /etc/resolv.conf"
    echo "   Try adding: nameserver 8.8.8.8"
    exit 1
fi

# 4. Check internet connectivity
echo ""
echo "[4] Checking internet connectivity..."
if ping -c 2 -W 3 8.8.8.8 > /dev/null 2>&1; then
    ok "Internet connectivity OK (ping 8.8.8.8)"
else
    fail "No internet connectivity"
    echo "   Possible issues: firewall, routing, ISP"
    exit 1
fi

# 5. Check HTTP/HTTPS
echo ""
echo "[5] Checking HTTP/HTTPS connectivity..."
if curl -s --connect-timeout 5 http://google.com > /dev/null; then
    ok "HTTP connectivity OK"
else
    warn "HTTP connectivity issues"
fi

if curl -s --connect-timeout 5 https://google.com > /dev/null; then
    ok "HTTPS connectivity OK"
else
    warn "HTTPS connectivity issues"
fi

# Summary
echo ""
echo "=== Summary ==="
ok "All network checks passed!"
echo ""
echo "Network Information:"
echo "  Interface: $INTERFACE"
echo "  IP: $IP"
echo "  Gateway: $GATEWAY"
echo "  DNS: $DNS"
\end{lstlisting}

\subsection{Esercizio 10: SSH Key Management}
\textbf{Obiettivo}: Script setup SSH keys su server multipli.

\textbf{Requisiti}:
\begin{itemize}
\item Genera chiave Ed25519 se non esiste
\item Copia chiave su lista server
\item Testa connessione senza password
\item Report successi/fallimenti
\end{itemize}

\textbf{Soluzione}:
\begin{lstlisting}
#!/bin/bash
# setup_ssh_keys.sh - Setup SSH keys on multiple servers

set -euo pipefail

# Configuration
KEY_FILE="$HOME/.ssh/id_ed25519"
SERVERS_FILE="${1:-servers.txt}"

log_ok() { echo "[OK] $*"; }
log_fail() { echo "[FAIL] $*"; }
log_info() { echo "[INFO] $*"; }

# Generate SSH key if not exists
generate_key() {
    if [ -f "$KEY_FILE" ]; then
        log_info "SSH key already exists: $KEY_FILE"
        return 0
    fi

    log_info "Generating new Ed25519 SSH key..."
    ssh-keygen -t ed25519 -f "$KEY_FILE" -N "" -C "$(whoami)@$(hostname)"

    if [ -f "$KEY_FILE" ]; then
        log_ok "SSH key generated: $KEY_FILE"
    else
        log_fail "Failed to generate SSH key"
        return 1
    fi
}

# Copy key to server
copy_key_to_server() {
    local server=$1

    log_info "Copying key to $server..."

    if ssh-copy-id -i "$KEY_FILE" "$server" 2>/dev/null; then
        log_ok "Key copied to $server"
        return 0
    else
        log_fail "Failed to copy key to $server"
        return 1
    fi
}

# Test SSH connection
test_connection() {
    local server=$1

    log_info "Testing connection to $server..."

    if ssh -o BatchMode=yes -o ConnectTimeout=5 "$server" "echo 'SSH OK'" \
            >/dev/null 2>&1; then
        log_ok "SSH connection successful: $server"
        return 0
    else
        log_fail "SSH connection failed: $server"
        return 1
    fi
}

# Process servers file
process_servers() {
    local file=$1

    if [ ! -f "$file" ]; then
        log_fail "Servers file not found: $file"
        return 1
    fi

    local success=0
    local failed=0

    while IFS= read -r server; do
        # Skip empty lines and comments
        [[ -z "$server" || "$server" =~ ^# ]] && continue

        echo ""
        echo "=== Processing: $server ==="

        if copy_key_to_server "$server"; then
            if test_connection "$server"; then
                ((success++))
            else
                ((failed++))
            fi
        else
            ((failed++))
        fi

    done < "$file"

    echo ""
    echo "=== Summary ==="
    echo "Success: $success"
    echo "Failed: $failed"

    return 0
}

# Main
main() {
    echo "=== SSH Key Setup ==="
    echo ""

    # Generate key
    generate_key || exit 1

    echo ""
    echo "Public key:"
    cat "${KEY_FILE}.pub"
    echo ""

    # Process servers
    process_servers "$SERVERS_FILE"
}

# Usage
if [ $# -lt 1 ]; then
    cat << EOF
Usage: $0 <servers_file>

servers_file format (one server per line):
  user@hostname
  user@192.168.1.100
  user@server.example.com:2222

Example:
  echo "user@server1.com" > servers.txt
  echo "admin@192.168.1.100" >> servers.txt
  $0 servers.txt
EOF
    exit 1
fi

main "$@"
\end{lstlisting}

\textbf{Usage}:
\begin{lstlisting}
# Creare file server list
cat > servers.txt << EOF
user@web1.example.com
user@web2.example.com
admin@db.example.com
EOF

# Eseguire script
chmod +x setup_ssh_keys.sh
./setup_ssh_keys.sh servers.txt

# Testare connessioni
ssh user@web1.example.com "hostname"
\end{lstlisting}

\section{Riepilogo}
Questi esercizi coprono:
\begin{itemize}
\item File system operations e permessi
\item Text processing e log analysis
\item Bash scripting avanzato con error handling
\item System administration e automation
\item Network diagnostics e troubleshooting
\item SSH key management
\end{itemize}

Ogni soluzione include best practices:
\begin{itemize}
\item Strict mode (\texttt{set -euo pipefail})
\item Proper error handling
\item Logging dettagliato
\item Input validation
\item Exit codes appropriati
\item Commenti e documentation
\end{itemize}

\section{Esercizi Aggiuntivi (Challenges)}

\subsection{Challenge 1: Log Aggregator}
Creare script che raccoglie log da server multipli via SSH, aggrega e analizza.

\subsection{Challenge 2: Deployment Pipeline}
Implementare pipeline completo: build → test → deploy → rollback se fallisce.

\subsection{Challenge 3: Monitoring Dashboard}
Generare report HTML con metriche sistema, grafici, alert history.

\subsection{Challenge 4: Automated Backup Rotation}
Sistema backup completo con daily/weekly/monthly rotation e verifica integrità.

\subsection{Challenge 5: Security Audit Script}
Script che verifica configurazione sicurezza: SSH hardening, firewall, updates, SUID files, etc.
