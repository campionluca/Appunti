{
  "course_name": "Java - Programmazione Orientata agli Oggetti",
  "version": "2.0 - Enhanced with OOP Theory",
  "last_updated": "2025-11-14",
  "total_descriptors": 18,
  "focus_areas": [
    "OOP Principles",
    "Design Patterns",
    "Best Practices",
    "Comparison with C"
  ],
  "coverage": {
    "chapters_analyzed": 10,
    "main_chapters": [
      "00_classi_oggetti_ereditarieta",
      "01_stream_buffer",
      "02_interfacce_classi_astratte",
      "03_eccezioni",
      "04_arraylist",
      "05_interfacce_grafiche",
      "06_model_view_controller",
      "07_lambda_expressions"
    ],
    "pages_covered": "280-300 estimated",
    "oop_focus": true,
    "design_patterns_covered": [
      "MVC",
      "Observer",
      "Singleton",
      "Factory"
    ]
  },
  "concept_descriptors": [
    {
      "concept_id": "JAVA-OOP-001",
      "topic": "Classi e Oggetti - Fondamenti OOP",
      "category": "Object-Oriented Programming",
      "difficulty_level": "beginner",
      "explanation": "Una CLASSE è un modello (blueprint) che definisce attributi e metodi. Un OGGETTO è un'istanza concreta creata con 'new'. L'incapsulamento protegge i dati con modificatori di accesso (private, public, protected). La parola 'this' riferisce l'istanza corrente.",
      "code_example": "// Classe modello per Studente\npublic class Studente {\n    private String matricola;\n    private String nome;\n    private double media;\n\n    public Studente(String matricola, String nome, double media) {\n        this.matricola = matricola;\n        this.nome = nome;\n        this.media = media;\n    }\n\n    public double getMedia() { return media; }\n    public void setMedia(double m) {\n        if (m >= 0.0 && m <= 10.0) this.media = m;\n    }\n}",
      "common_mistakes": [
        "Non usare 'this'",
        "Attributi public",
        "No validazione setter"
      ],
      "best_practices": [
        "Attributi private",
        "PascalCase classi",
        "Validazione input"
      ],
      "learning_objectives": [
        "Differenza classe-oggetto",
        "Usare this",
        "Getter/setter"
      ],
      "related_concepts": [
        "JAVA-INHERITANCE-001",
        "JAVA-STATIC-001"
      ]
    },
    {
      "concept_id": "JAVA-STATIC-001",
      "topic": "Membri Statici - Metodi e Attributi di Classe",
      "category": "Object-Oriented Programming",
      "difficulty_level": "intermediate",
      "explanation": "Elementi STATICI appartengono alla CLASSE, non all'istanza. Condivisi da tutti gli oggetti. Utili per utility methods (Math.pow) e costanti (PI). Metodi static non possono accedere membri di istanza.",
      "code_example": "public class Studente {\n    private static int contatore = 0;\n    public static final double MEDIA_MIN = 6.0;\n\n    private int id;\n\n    public Studente() {\n        contatore++;\n        this.id = contatore;\n    }\n\n    public static int getTotale() {\n        return contatore;\n    }\n}\n\n// Uso: Studente.getTotale() senza creare oggetto",
      "common_mistakes": [
        "Accedere 'this' da static",
        "Confondere static/instance"
      ],
      "best_practices": [
        "Costanti: static final",
        "Utility: metodi static"
      ],
      "learning_objectives": [
        "Differenza static/instance",
        "Contatori statici"
      ],
      "related_concepts": [
        "JAVA-OOP-001",
        "JAVA-FINAL-001"
      ]
    },
    {
      "concept_id": "JAVA-INHERITANCE-001",
      "topic": "Ereditarietà - Extends e Super",
      "category": "Inheritance and Polymorphism",
      "difficulty_level": "intermediate",
      "explanation": "L'EREDITARIETÀ permette a una sottoclasse di acquisire membri da superclasse con 'extends'. Relazione 'is-a'. 'super()' chiama costruttore superclasse (prima istruzione). 'super.metodo()' accede versione superclasse. Java: ereditarietà singola.",
      "code_example": "public class Veicolo {\n    protected String targa;\n\n    public Veicolo(String targa) {\n        this.targa = targa;\n    }\n\n    public void mostraInfo() {\n        System.out.println(\"Targa: \" + targa);\n    }\n}\n\npublic class Auto extends Veicolo {\n    private int posti;\n\n    public Auto(String targa, int posti) {\n        super(targa);  // Chiama costruttore Veicolo\n        this.posti = posti;\n    }\n\n    @Override\n    public void mostraInfo() {\n        super.mostraInfo();  // Chiama versione Veicolo\n        System.out.println(\"Posti: \" + posti);\n    }\n}",
      "common_mistakes": [
        "Dimenticare super()",
        "super() non prima",
        "Override senza @Override"
      ],
      "best_practices": [
        "Usare @Override",
        "super() sempre prima",
        "protected per ereditarietà"
      ],
      "learning_objectives": [
        "Usare extends",
        "super()",
        "Override metodi"
      ],
      "related_concepts": [
        "JAVA-OOP-001",
        "JAVA-POLYMORPHISM-001"
      ]
    },
    {
      "concept_id": "JAVA-POLYMORPHISM-001",
      "topic": "Polimorfismo e Binding Dinamico",
      "category": "Inheritance and Polymorphism",
      "difficulty_level": "intermediate",
      "explanation": "Il POLIMORFISMO permette a riferimento superclasse di puntare a oggetti sottoclasse. BINDING DINAMICO: JVM sceglie metodo a runtime in base al tipo reale. 'instanceof' verifica tipo runtime. Downcasting: conversione superclasse->sottoclasse.",
      "code_example": "// Array polimorfo\nVeicolo[] parco = new Veicolo[3];\nparco[0] = new Auto(\"AB123\", 5);\nparco[1] = new Moto(\"EF456\", 600);\nparco[2] = new Auto(\"IJ789\", 4);\n\n// Binding dinamico: chiama versione corretta\nfor (Veicolo v : parco) {\n    v.mostraInfo();  // Auto o Moto in base al tipo reale\n}\n\n// instanceof e downcasting\nif (parco[0] instanceof Auto) {\n    Auto auto = (Auto) parco[0];\n    System.out.println(auto.getPosti());\n}",
      "common_mistakes": [
        "Cast senza instanceof",
        "Confondere tipo riferimento/oggetto"
      ],
      "best_practices": [
        "instanceof prima di cast",
        "Sfruttare polimorfismo vs if-instanceof"
      ],
      "learning_objectives": [
        "Binding dinamico",
        "instanceof",
        "Downcasting sicuro"
      ],
      "related_concepts": [
        "JAVA-INHERITANCE-001",
        "JAVA-INTERFACE-001"
      ]
    },
    {
      "concept_id": "JAVA-PACKAGE-001",
      "topic": "Package e Organizzazione Codice",
      "category": "Code Organization",
      "difficulty_level": "beginner",
      "explanation": "I PACKAGE raggruppano classi correlate. Sintassi 'package it.scuola.modelli;' prima istruzione. 'import' per usare classi altri package. Directory rispecchia gerarchia package. Previene conflitti nomi.",
      "code_example": "// File: Studente.java\npackage it.scuola.gestionale.modelli;\n\npublic class Studente {\n    // Implementazione\n}\n\n// File: MainApp.java\npackage it.scuola.gestionale.app;\n\nimport it.scuola.gestionale.modelli.Studente;\n\npublic class MainApp {\n    public static void main(String[] args) {\n        Studente s = new Studente();\n    }\n}\n\n// Struttura directory:\n// src/it/scuola/gestionale/modelli/Studente.java\n// src/it/scuola/gestionale/app/MainApp.java",
      "common_mistakes": [
        "package non prima",
        "Directory != package",
        "import package vs classi"
      ],
      "best_practices": [
        "Dominio inverso: it.azienda.progetto",
        "Package per area funzionale"
      ],
      "learning_objectives": [
        "Dichiarare package",
        "Import",
        "Organizzare directory"
      ],
      "related_concepts": [
        "JAVA-ACCESS-001",
        "JAVA-CLASSPATH-001"
      ]
    },
    {
      "concept_id": "JAVA-INTERFACE-001",
      "topic": "Interfacce - Contratti e Astrazione",
      "category": "Abstraction and Interfaces",
      "difficulty_level": "intermediate",
      "explanation": "Un'INTERFACCIA definisce un contratto (metodi astratti) senza implementazione. Classi implementano interfacce con 'implements'. Una classe può implementare multiple interfacce (vs ereditarietà singola). Polimorfismo tramite interfacce.",
      "code_example": "// Interfaccia: contratto\npublic interface Stampabile {\n    void stampa();  // Metodo astratto (no implementazione)\n    default void stampaDettagli() {  // Default method (Java 8+)\n        System.out.println(\"Dettagli generici\");\n    }\n}\n\n// Implementazione\npublic class Documento implements Stampabile {\n    private String titolo;\n\n    @Override\n    public void stampa() {\n        System.out.println(\"Stampo: \" + titolo);\n    }\n}\n\n// Polimorfismo via interfaccia\nStampabile s = new Documento();\ns.stampa();  // Binding dinamico",
      "common_mistakes": [
        "implements vs extends",
        "Dimenticare @Override"
      ],
      "best_practices": [
        "Interfacce per API contracts",
        "Naming: aggettivi (-able)"
      ],
      "learning_objectives": [
        "Dichiarare interfacce",
        "implements",
        "Polimorfismo interfacce"
      ],
      "related_concepts": [
        "JAVA-ABSTRACT-001",
        "JAVA-POLYMORPHISM-001"
      ]
    },
    {
      "concept_id": "JAVA-ABSTRACT-001",
      "topic": "Classi Astratte vs Interfacce",
      "category": "Abstraction and Interfaces",
      "difficulty_level": "intermediate",
      "explanation": "CLASSE ASTRATTA: non istanziabile, può avere metodi astratti e concreti, attributi, costruttori. INTERFACCIA: solo contratti (metodi astratti). Classe astratta per 'is-a' con codice comune, interfaccia per 'can-do' (capabilities).",
      "code_example": "// Classe astratta: codice comune + metodi astratti\npublic abstract class Figura {\n    protected String colore;  // Attributo concreto\n\n    public Figura(String colore) {  // Costruttore\n        this.colore = colore;\n    }\n\n    public abstract double calcolaArea();  // Astratto\n\n    public void mostraColore() {  // Concreto\n        System.out.println(\"Colore: \" + colore);\n    }\n}\n\npublic class Cerchio extends Figura {\n    private double raggio;\n\n    public Cerchio(String colore, double r) {\n        super(colore);\n        this.raggio = r;\n    }\n\n    @Override\n    public double calcolaArea() {\n        return Math.PI * raggio * raggio;\n    }\n}\n\n// Figura f = new Figura(); // ERRORE: classe astratta!\nFigura c = new Cerchio(\"Rosso\", 5.0);  // OK",
      "common_mistakes": [
        "Istanziare classe astratta",
        "Confondere abstract/interface"
      ],
      "best_practices": [
        "Abstract per codice comune",
        "Interface per contratti multipli"
      ],
      "learning_objectives": [
        "Dichiarare classe astratta",
        "Metodi astratti",
        "abstract vs interface"
      ],
      "related_concepts": [
        "JAVA-INTERFACE-001",
        "JAVA-INHERITANCE-001"
      ]
    },
    {
      "concept_id": "JAVA-EXCEPTION-001",
      "topic": "Gestione Eccezioni - Try-Catch-Finally",
      "category": "Error Handling",
      "difficulty_level": "intermediate",
      "explanation": "Le ECCEZIONI gestiscono errori runtime. Try-catch cattura eccezioni. Finally esegue sempre (cleanup). Checked (obbligano try-catch o throws) vs Unchecked (RuntimeException). Throw per lanciare, throws per dichiarare.",
      "code_example": "public class GestoreFile {\n    public void leggiFile(String path) {\n        try {\n            FileReader fr = new FileReader(path);\n            BufferedReader br = new BufferedReader(fr);\n            String linea = br.readLine();\n            System.out.println(linea);\n            br.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"File non trovato: \" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(\"Errore I/O: \" + e.getMessage());\n        } finally {\n            System.out.println(\"Operazione completata\");\n        }\n    }\n\n    // Try-with-resources (Java 7+)\n    public void leggiFileModerno(String path) throws IOException {\n        try (BufferedReader br = new BufferedReader(new FileReader(path))) {\n            System.out.println(br.readLine());\n        }  // Auto-close br\n    }\n}",
      "common_mistakes": [
        "Catch generico Exception",
        "Finally per return",
        "Ignorare eccezioni"
      ],
      "best_practices": [
        "Catch specifici",
        "Try-with-resources",
        "Log eccezioni"
      ],
      "learning_objectives": [
        "try-catch-finally",
        "Checked vs unchecked",
        "Try-with-resources"
      ],
      "related_concepts": [
        "JAVA-STREAM-001",
        "JAVA-CUSTOM-EXCEPTION-001"
      ]
    },
    {
      "concept_id": "JAVA-STREAM-001",
      "topic": "Stream e Buffer - File I/O",
      "category": "File Input/Output",
      "difficulty_level": "intermediate",
      "explanation": "STREAM: flussi di dati byte (InputStream/OutputStream) o caratteri (Reader/Writer). BUFFER: memorizzazione temporanea per efficienza (BufferedReader/Writer). Try-with-resources per auto-close.",
      "code_example": "import java.io.*;\n\npublic class FileManager {\n    // Lettura file con buffer\n    public void leggiFile(String path) throws IOException {\n        try (BufferedReader br = new BufferedReader(\n                new FileReader(path))) {\n            String linea;\n            while ((linea = br.readLine()) != null) {\n                System.out.println(linea);\n            }\n        }\n    }\n\n    // Scrittura file\n    public void scriviFile(String path, String contenuto)\n            throws IOException {\n        try (BufferedWriter bw = new BufferedWriter(\n                new FileWriter(path))) {\n            bw.write(contenuto);\n            bw.newLine();\n        }\n    }\n}",
      "common_mistakes": [
        "Non chiudere stream",
        "FileReader senza Buffer"
      ],
      "best_practices": [
        "Try-with-resources",
        "Buffer per performance"
      ],
      "learning_objectives": [
        "FileReader/Writer",
        "BufferedReader/Writer",
        "Try-with-resources"
      ],
      "related_concepts": [
        "JAVA-EXCEPTION-001",
        "JAVA-SERIALIZATION-001"
      ]
    },
    {
      "concept_id": "JAVA-ARRAYLIST-001",
      "topic": "ArrayList e Generics - Collezioni Dinamiche",
      "category": "Collections and Generics",
      "difficulty_level": "beginner",
      "explanation": "ARRAYLIST: collezione dinamica ridimensionabile. GENERICS <T> per type safety. Metodi: add, remove, get, set, size. Autoboxing/unboxing per primitivi (int -> Integer).",
      "code_example": "import java.util.ArrayList;\n\npublic class GestioneStudenti {\n    public static void main(String[] args) {\n        // Generics: type safety\n        ArrayList<String> nomi = new ArrayList<>();\n\n        // Metodi base\n        nomi.add(\"Mario\");\n        nomi.add(\"Anna\");\n        nomi.add(1, \"Luca\");  // Inserisce in posizione\n\n        System.out.println(nomi.get(0));  // Mario\n        System.out.println(nomi.size());  // 3\n\n        nomi.remove(\"Anna\");\n        nomi.set(0, \"Giuseppe\");\n\n        // Iterazione\n        for (String nome : nomi) {\n            System.out.println(nome);\n        }\n\n        // ArrayList di oggetti\n        ArrayList<Studente> classe = new ArrayList<>();\n        classe.add(new Studente(\"A001\", \"Mario\", 7.5));\n    }\n}",
      "common_mistakes": [
        "Raw type senza generics",
        "IndexOutOfBounds",
        "ConcurrentModification"
      ],
      "best_practices": [
        "Sempre specificare <T>",
        "Capacità iniziale se nota"
      ],
      "learning_objectives": [
        "Dichiarare ArrayList<T>",
        "add/remove/get",
        "Iterare collezioni"
      ],
      "related_concepts": [
        "JAVA-GENERICS-001",
        "JAVA-ITERATOR-001"
      ]
    },
    {
      "concept_id": "JAVA-GUI-001",
      "topic": "Interfacce Grafiche - Swing Components",
      "category": "Graphical User Interface",
      "difficulty_level": "intermediate",
      "explanation": "SWING: framework GUI Java. JFrame (finestra), JPanel (contenitore), JButton (pulsante), JLabel (etichetta). Layout Manager (BorderLayout, FlowLayout) per posizionamento componenti.",
      "code_example": "import javax.swing.*;\nimport java.awt.*;\n\npublic class FinestraBase extends JFrame {\n    private JLabel etichetta;\n    private JButton pulsante;\n\n    public FinestraBase() {\n        setTitle(\"Applicazione Swing\");\n        setSize(400, 300);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n\n        // Layout\n        setLayout(new BorderLayout());\n\n        // Componenti\n        etichetta = new JLabel(\"Benvenuto!\", SwingConstants.CENTER);\n        pulsante = new JButton(\"Clicca\");\n\n        // Aggiunta\n        add(etichetta, BorderLayout.CENTER);\n        add(pulsante, BorderLayout.SOUTH);\n\n        setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new FinestraBase();\n    }\n}",
      "common_mistakes": [
        "Dimenticare setVisible(true)",
        "Layout default errato"
      ],
      "best_practices": [
        "BorderLayout per organizzazione",
        "setLocationRelativeTo(null) per centrare"
      ],
      "learning_objectives": [
        "Creare JFrame",
        "Aggiungere componenti",
        "Layout Manager"
      ],
      "related_concepts": [
        "JAVA-EVENT-001",
        "JAVA-LAYOUT-001"
      ]
    },
    {
      "concept_id": "JAVA-EVENT-001",
      "topic": "Gestione Eventi - ActionListener",
      "category": "Event-Driven Programming",
      "difficulty_level": "intermediate",
      "explanation": "EVENTI: azioni utente (click, tastiera). LISTENER: interfacce per gestire eventi (ActionListener, MouseListener). Pattern Observer: componente notifica listener registrati.",
      "code_example": "import javax.swing.*;\nimport java.awt.event.*;\n\npublic class Contatore extends JFrame {\n    private JLabel lblContatore;\n    private JButton btnIncrementa;\n    private int contatore = 0;\n\n    public Contatore() {\n        setTitle(\"Contatore\");\n        setSize(300, 150);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setLayout(new BorderLayout());\n\n        lblContatore = new JLabel(\"Click: 0\", SwingConstants.CENTER);\n        btnIncrementa = new JButton(\"Incrementa\");\n\n        // ActionListener - classe anonima\n        btnIncrementa.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                contatore++;\n                lblContatore.setText(\"Click: \" + contatore);\n            }\n        });\n\n        add(lblContatore, BorderLayout.CENTER);\n        add(btnIncrementa, BorderLayout.SOUTH);\n\n        setVisible(true);\n    }\n}",
      "common_mistakes": [
        "Listener non registrato",
        "NullPointer su componenti"
      ],
      "best_practices": [
        "Lambda per listener semplici",
        "Inner class per complessi"
      ],
      "learning_objectives": [
        "ActionListener",
        "addActionListener",
        "Pattern Observer"
      ],
      "related_concepts": [
        "JAVA-GUI-001",
        "JAVA-LAMBDA-001"
      ]
    },
    {
      "concept_id": "JAVA-MVC-001",
      "topic": "Pattern MVC - Separazione Responsabilità",
      "category": "Design Patterns",
      "difficulty_level": "advanced",
      "explanation": "MVC separa applicazione in: MODEL (dati + logica business, indipendente da GUI), VIEW (interfaccia grafica), CONTROLLER (coordina Model-View, gestisce eventi). Vantaggi: testabilità, manutenibilità, riusabilità.",
      "code_example": "// MODEL: solo dati e logica\npublic class TodoModel {\n    private List<String> tasks = new ArrayList<>();\n\n    public boolean addTask(String task) {\n        if (task == null || task.trim().isEmpty()) return false;\n        tasks.add(task.trim());\n        return true;\n    }\n\n    public List<String> getAllTasks() {\n        return new ArrayList<>(tasks);\n    }\n}\n\n// VIEW: solo GUI\npublic class TodoView extends JFrame {\n    private JTextArea txtArea;\n    private JButton btnAdd;\n\n    public String getInput() {\n        return txtInput.getText();\n    }\n\n    public void displayTasks(List<String> tasks) {\n        txtArea.setText(String.join(\"\\n\", tasks));\n    }\n\n    public JButton getBtnAdd() { return btnAdd; }\n}\n\n// CONTROLLER: coordina Model e View\npublic class TodoController {\n    private TodoModel model;\n    private TodoView view;\n\n    public TodoController(TodoModel model, TodoView view) {\n        this.model = model;\n        this.view = view;\n\n        view.getBtnAdd().addActionListener(e -> {\n            String task = view.getInput();\n            if (model.addTask(task)) {\n                view.displayTasks(model.getAllTasks());\n            }\n        });\n    }\n}",
      "common_mistakes": [
        "Logica business in View",
        "View accede Model direttamente"
      ],
      "best_practices": [
        "Model completamente indipendente",
        "Controller coordina tutto"
      ],
      "learning_objectives": [
        "Separare Model/View/Controller",
        "Testare Model senza GUI"
      ],
      "related_concepts": [
        "JAVA-GUI-001",
        "JAVA-OBSERVER-001"
      ]
    },
    {
      "concept_id": "JAVA-LAMBDA-001",
      "topic": "Lambda Expressions - Programmazione Funzionale",
      "category": "Functional Programming",
      "difficulty_level": "advanced",
      "explanation": "LAMBDA: funzione anonima sintattica. Sintassi: (parametri) -> espressione. Funzionano con interfacce funzionali (1 solo metodo astratto). Sostituiscono classi anonime verbose.",
      "code_example": "import java.util.*;\n\npublic class EsempioLambda {\n    public static void main(String[] args) {\n        List<String> nomi = Arrays.asList(\"Mario\", \"Anna\", \"Luca\");\n\n        // Classe anonima (verbosa)\n        Collections.sort(nomi, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                return s1.length() - s2.length();\n            }\n        });\n\n        // Lambda (concisa)\n        Collections.sort(nomi, (s1, s2) -> s1.length() - s2.length());\n\n        // ActionListener con lambda\n        button.addActionListener(e ->\n            System.out.println(\"Cliccato!\"));\n\n        // Predicate con lambda\n        List<Integer> numeri = Arrays.asList(1, 2, 3, 4, 5);\n        numeri.removeIf(n -> n % 2 == 0);  // Rimuove pari\n    }\n}",
      "common_mistakes": [
        "Lambda su interfacce multi-metodo",
        "Sintassi errata"
      ],
      "best_practices": [
        "Usare per Comparator, ActionListener, Predicate"
      ],
      "learning_objectives": [
        "Sintassi lambda",
        "Interfacce funzionali",
        "Sostituire classi anonime"
      ],
      "related_concepts": [
        "JAVA-EVENT-001",
        "JAVA-STREAM-API-001"
      ]
    },
    {
      "concept_id": "JAVA-COMPARATOR-001",
      "topic": "Comparator - Ordinamento Personalizzato",
      "category": "Collections and Sorting",
      "difficulty_level": "intermediate",
      "explanation": "COMPARATOR: interfaccia per definire ordinamento personalizzato. Metodo compare(T o1, T o2): <0 (o1<o2), 0 (uguali), >0 (o1>o2). Collections.sort() accetta Comparator. Lambda per creare comparatori concisi.",
      "code_example": "import java.util.*;\n\nclass Studente {\n    String nome;\n    double media;\n\n    public Studente(String nome, double media) {\n        this.nome = nome;\n        this.media = media;\n    }\n}\n\npublic class OrdinamentoStudenti {\n    public static void main(String[] args) {\n        List<Studente> classe = new ArrayList<>();\n        classe.add(new Studente(\"Mario\", 7.5));\n        classe.add(new Studente(\"Anna\", 8.2));\n        classe.add(new Studente(\"Luca\", 6.8));\n\n        // Ordinamento per media (decrescente) con lambda\n        classe.sort((s1, s2) ->\n            Double.compare(s2.media, s1.media));\n\n        // Ordinamento multiplo\n        classe.sort(Comparator.comparing(s -> s.nome)\n                              .thenComparing(s -> s.media));\n\n        classe.forEach(s ->\n            System.out.println(s.nome + \": \" + s.media));\n    }\n}",
      "common_mistakes": [
        "Ordine parametri sbagliato",
        "compare() senza Double.compare"
      ],
      "best_practices": [
        "Lambda per comparatori semplici",
        "Comparator.comparing() per chaining"
      ],
      "learning_objectives": [
        "Implementare Comparator",
        "Collections.sort()",
        "Ordinamenti multipli"
      ],
      "related_concepts": [
        "JAVA-ARRAYLIST-001",
        "JAVA-LAMBDA-001"
      ]
    },
    {
      "concept_id": "JAVA-ITERATOR-001",
      "topic": "Iterator - Iterazione Sicura",
      "category": "Collections and Iteration",
      "difficulty_level": "intermediate",
      "explanation": "ITERATOR: oggetto per iterare collezioni con rimozione sicura. Metodi: hasNext(), next(), remove(). Rimuove ConcurrentModificationException (vs for-each). Pattern Iterator per accesso sequenziale.",
      "code_example": "import java.util.*;\n\npublic class EsempioIterator {\n    public static void main(String[] args) {\n        ArrayList<String> nomi = new ArrayList<>();\n        nomi.add(\"Mario\");\n        nomi.add(\"Anna\");\n        nomi.add(\"Luca\");\n\n        // Iterator per rimozione durante iterazione\n        Iterator<String> it = nomi.iterator();\n        while (it.hasNext()) {\n            String nome = it.next();\n            if (nome.equals(\"Anna\")) {\n                it.remove();  // Sicuro con Iterator\n            }\n        }\n\n        // For-each non può rimuovere\n        // for (String nome : nomi) {\n        //     nomi.remove(nome); // ConcurrentModificationException!\n        // }\n\n        System.out.println(nomi);  // [Mario, Luca]\n    }\n}",
      "common_mistakes": [
        "remove() senza next()",
        "ConcurrentModification in for-each"
      ],
      "best_practices": [
        "Iterator per rimozione",
        "For-each per sola lettura"
      ],
      "learning_objectives": [
        "Usare Iterator",
        "hasNext/next/remove",
        "Rimozione sicura"
      ],
      "related_concepts": [
        "JAVA-ARRAYLIST-001",
        "JAVA-FOREACH-001"
      ]
    },
    {
      "concept_id": "JAVA-GENERICS-001",
      "topic": "Generics - Parametri di Tipo",
      "category": "Type Safety and Reusability",
      "difficulty_level": "advanced",
      "explanation": "GENERICS: parametrizzazione tipi con <T>. Type safety a compile-time (vs cast runtime). Classi generiche riutilizzabili. Type erasure: info tipo rimossa a runtime. Bounded types: <T extends SuperClass>.",
      "code_example": "// Classe generica\npublic class Box<T> {\n    private T contenuto;\n\n    public void set(T contenuto) {\n        this.contenuto = contenuto;\n    }\n\n    public T get() {\n        return contenuto;\n    }\n}\n\n// Bounded type parameter\npublic class NumericBox<T extends Number> {\n    private T valore;\n\n    public double getDouble() {\n        return valore.doubleValue();  // Number ha doubleValue()\n    }\n}\n\n// Utilizzo\npublic class TestGenerics {\n    public static void main(String[] args) {\n        // Type safety: compile-time check\n        Box<String> boxString = new Box<>();\n        boxString.set(\"Ciao\");\n        String s = boxString.get();  // No cast needed!\n\n        Box<Integer> boxInt = new Box<>();\n        boxInt.set(42);\n        // boxInt.set(\"test\"); // ERRORE COMPILAZIONE!\n\n        NumericBox<Double> nb = new NumericBox<>();\n        // NumericBox<String> err; // ERRORE: String non extends Number\n    }\n}",
      "common_mistakes": [
        "Raw types senza <>",
        "Type erasure confusion",
        "Generics con primitivi"
      ],
      "best_practices": [
        "Sempre specificare tipo generico",
        "Bounded types per vincoli"
      ],
      "learning_objectives": [
        "Classi generiche <T>",
        "Bounded types",
        "Type safety"
      ],
      "related_concepts": [
        "JAVA-ARRAYLIST-001",
        "JAVA-COLLECTIONS-001"
      ]
    },
    {
      "concept_id": "JAVA-FINAL-001",
      "topic": "Modificatore Final - Immutabilità",
      "category": "Language Features",
      "difficulty_level": "beginner",
      "explanation": "FINAL: rende immutabile. Variabile final: valore non modificabile dopo inizializzazione. Metodo final: non può essere overridden. Classe final: non può essere estesa (String, Math). Costanti: static final.",
      "code_example": "public class EsempioFinal {\n    // Costante di classe: static final\n    public static final double PI = 3.14159;\n    public static final String APP_NAME = \"MyApp\";\n\n    // Attributo final: inizializzato in costruttore\n    private final int id;\n    private final String nome;\n\n    public EsempioFinal(int id, String nome) {\n        this.id = id;    // Inizializzazione una sola volta\n        this.nome = nome;\n    }\n\n    // Metodo final: non può essere overridden\n    public final void metodoSicuro() {\n        System.out.println(\"Implementazione fissa\");\n    }\n}\n\n// Classe final: non può essere estesa\npublic final class ClasseImmutabile {\n    private final int valore;\n\n    public ClasseImmutabile(int valore) {\n        this.valore = valore;\n    }\n\n    public int getValore() { return valore; }\n    // public void setValore(int v) {} // NO setter per immutabilità\n}\n\n// Variabili locali final\npublic void metodo() {\n    final int MAX = 100;\n    // MAX = 200; // ERRORE COMPILAZIONE!\n}",
      "common_mistakes": [
        "final su riferimenti (oggetto mutabile)",
        "Dimenticare inizializzazione final"
      ],
      "best_practices": [
        "Costanti: static final MAIUSCOLO",
        "Classi immutabili: final + no setter"
      ],
      "learning_objectives": [
        "final per variabili/metodi/classi",
        "Immutabilità",
        "Costanti"
      ],
      "related_concepts": [
        "JAVA-STATIC-001",
        "JAVA-IMMUTABLE-001"
      ]
    }
  ],
  "theoretical_explanations": {
    "oop_principles": {
      "explanation": "La Programmazione Orientata agli Oggetti (OOP) è un paradigma di programmazione che organizza il software in oggetti che contengono dati (attributi) e codice (metodi). Java è un linguaggio fortemente orientato agli oggetti dove quasi tutto è un oggetto (eccetto tipi primitivi).",
      "pillars": [
        {
          "name": "Astrazione",
          "description": "Capacità di concentrarsi sugli aspetti essenziali ignorando dettagli irrilevanti",
          "java_implementation": "Classi astratte (abstract class) e interfacce (interface)"
        },
        {
          "name": "Incapsulamento",
          "description": "Meccanismo che lega dati e metodi e nasconde dettagli implementativi",
          "java_implementation": "Attributi private con metodi public getter/setter"
        },
        {
          "name": "Ereditarietà",
          "description": "Permette a una classe di acquisire proprietà di un'altra classe",
          "java_implementation": "Parola chiave 'extends' per ereditarietà singola"
        },
        {
          "name": "Polimorfismo",
          "description": "Capacità di oggetti di classi diverse di rispondere allo stesso messaggio",
          "java_implementation": "Override di metodi + binding dinamico"
        }
      ]
    }
  }
}