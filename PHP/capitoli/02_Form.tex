\chapter{Form HTML e Gestione Input}\label{cap:form_input}

\begin{tcolorbox}[title=Mappa del capitolo]
Form HTML, Metodi HTTP, Validazione client/server, Sanitizzazione, Sicurezza (XSS, SQL Injection), Pattern PRG, Upload file, AJAX, Esempi completi, Esercizi progressivi.
\end{tcolorbox}

\section{Obiettivi di apprendimento}
\begin{itemize}
  \item Comprendere la struttura e il funzionamento dei form HTML
  \item Distinguere tra GET e POST e usarli appropriatamente
  \item Implementare validazione robusta lato client e server
  \item Proteggere da vulnerabilità comuni (XSS, SQL Injection, CSRF)
  \item Applicare il pattern Post/Redirect/Get per UX migliore
  \item Gestire upload file in modo sicuro
  \item Implementare form con AJAX per submit asincrono
\end{itemize}

\section{Introduzione ai Form HTML}

I \textbf{form} sono il principale meccanismo di interazione tra utente e server nelle applicazioni web. Permettono di raccogliere input utente (credenziali, dati personali, file, ecc.) e inviarli al server per l'elaborazione.

\subsection{Anatomia di un Form}

Un form HTML è definito dal tag \texttt{<form>} con attributi che controllano il comportamento:

\begin{lstlisting}[language=HTML]
<form action="/processa.php" method="POST" enctype="multipart/form-data">
    <!-- Campi input -->
    <input type="text" name="username" required>
    <input type="email" name="email" required>
    <button type="submit">Invia</button>
</form>
\end{lstlisting}

\textbf{Attributi principali}:
\begin{description}
    \item[action] URL destinazione dove inviare i dati (default: stessa pagina)
    \item[method] Metodo HTTP: GET, POST (default: GET)
    \item[enctype] Codifica dati: \texttt{application/x-www-form-urlencoded} (default), \texttt{multipart/form-data} (per file), \texttt{text/plain}
    \item[autocomplete] on/off per autofill browser
    \item[novalidate] Disabilita validazione HTML5 (sconsigliato)
\end{description}

\section{Metodi HTTP: GET vs POST}

\subsection{GET Method}

Invia dati tramite query string nell'URL:

\begin{lstlisting}[language=HTML]
<form action="/search.php" method="GET">
    <input type="text" name="q" placeholder="Cerca...">
    <button type="submit">Cerca</button>
</form>
\end{lstlisting}

URL risultante: \texttt{/search.php?q=php+tutorial}

\textbf{Caratteristiche GET}:
\begin{itemize}
    \item Dati visibili nell'URL (bookmarkable)
    \item Limitato a ~2000 caratteri (varia per browser)
    \item Dati in cache del browser e cronologia
    \item Idempotente (richieste multiple non cambiano stato server)
    \item \textbf{Mai usare per dati sensibili} (password, dati personali)
\end{itemize}

\textbf{Casi d'uso GET}:
\begin{itemize}
    \item Ricerche e filtri
    \item Paginazione
    \item Condivisione link con parametri
    \item API di lettura (read-only)
\end{itemize}

\subsection{POST Method}

Invia dati nel corpo della richiesta HTTP:

\begin{lstlisting}[language=HTML]
<form action="/login.php" method="POST">
    <input type="text" name="username" required>
    <input type="password" name="password" required>
    <button type="submit">Login</button>
</form>
\end{lstlisting}

\textbf{Caratteristiche POST}:
\begin{itemize}
    \item Dati non visibili nell'URL
    \item Nessun limite dimensione (configurabile server)
    \item Non in cache del browser
    \item Non idempotente (può modificare stato server)
    \item Richiede conferma su ricarica (F5)
\end{itemize}

\textbf{Casi d'uso POST}:
\begin{itemize}
    \item Login e registrazione
    \item Modifica/eliminazione dati
    \item Upload file
    \item Transazioni e-commerce
    \item Qualsiasi operazione che modifica stato server
\end{itemize}

\begin{attenzione}
\textbf{Sicurezza}: POST non è crittografia! I dati sono comunque visibili in network inspector. Usa \textbf{HTTPS} per proteggere dati sensibili in transito.
\end{attenzione}

\section{Tipi di Input HTML5}

HTML5 introduce numerosi tipi di input con validazione nativa:

\subsection{Input Testuali}

\begin{lstlisting}[language=HTML]
<!-- Testo generico -->
<input type="text" name="nome" maxlength="50" required>

<!-- Email (validazione pattern) -->
<input type="email" name="email" required
       placeholder="utente@esempio.it">

<!-- Password (nasconde caratteri) -->
<input type="password" name="password"
       minlength="8" required>

<!-- URL (validazione formato) -->
<input type="url" name="sito"
       placeholder="https://esempio.it">

<!-- Telefono (no validazione automatica) -->
<input type="tel" name="telefono"
       pattern="[0-9]{10}" placeholder="0123456789">

<!-- Ricerca (può avere icona X per cancellare) -->
<input type="search" name="q">
\end{lstlisting}

\subsection{Input Numerici}

\begin{lstlisting}[language=HTML]
<!-- Numero (con stepper) -->
<input type="number" name="eta"
       min="18" max="120" step="1" value="25">

<!-- Range (slider) -->
<input type="range" name="volume"
       min="0" max="100" step="5" value="50">

<!-- Mostra valore corrente con JavaScript -->
<output id="volumeValue">50</output>
\end{lstlisting}

\subsection{Input Data e Ora}

\begin{lstlisting}[language=HTML]
<!-- Data (YYYY-MM-DD) -->
<input type="date" name="nascita"
       min="1900-01-01" max="2010-12-31">

<!-- Mese (YYYY-MM) -->
<input type="month" name="mese">

<!-- Settimana (YYYY-Wnn) -->
<input type="week" name="settimana">

<!-- Ora (HH:MM) -->
<input type="time" name="ora"
       min="09:00" max="18:00" step="1800">

<!-- Data e ora locale -->
<input type="datetime-local" name="appuntamento">
\end{lstlisting}

\subsection{Input Scelta}

\begin{lstlisting}[language=HTML]
<!-- Checkbox (multiple scelte) -->
<input type="checkbox" name="interessi[]" value="php"> PHP
<input type="checkbox" name="interessi[]" value="js"> JavaScript
<input type="checkbox" name="interessi[]" value="python"> Python

<!-- Radio (scelta singola) -->
<input type="radio" name="genere" value="m" required> Maschile
<input type="radio" name="genere" value="f" required> Femminile

<!-- Select dropdown -->
<select name="paese" required>
    <option value="">-- Seleziona --</option>
    <option value="IT">Italia</option>
    <option value="US">USA</option>
    <option value="UK">UK</option>
</select>

<!-- Select multiplo -->
<select name="lingue[]" multiple size="4">
    <option value="it">Italiano</option>
    <option value="en">Inglese</option>
    <option value="fr">Francese</option>
    <option value="de">Tedesco</option>
</select>
\end{lstlisting}

\subsection{Input Speciali}

\begin{lstlisting}[language=HTML]
<!-- File upload -->
<input type="file" name="documento"
       accept=".pdf,.doc,.docx" required>

<!-- File multipli -->
<input type="file" name="foto[]"
       accept="image/*" multiple>

<!-- Colore (color picker) -->
<input type="color" name="sfondo" value="#ff0000">

<!-- Nascosto (hidden) -->
<input type="hidden" name="user_id" value="123">

<!-- Textarea (testo multilinea) -->
<textarea name="messaggio" rows="5" cols="40"
          maxlength="500" required></textarea>
\end{lstlisting}

\section{Validazione Lato Client (HTML5)}

\subsection{Attributi di Validazione}

\begin{lstlisting}[language=HTML]
<!-- Required: campo obbligatorio -->
<input type="text" name="nome" required>

<!-- Pattern: validazione regex -->
<input type="text" name="codice_fiscale"
       pattern="[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]"
       title="Formato: RSSMRA80A01H501U">

<!-- Min/Max: range numerico -->
<input type="number" name="eta" min="18" max="100">

<!-- Minlength/Maxlength: lunghezza stringa -->
<input type="password" name="password"
       minlength="8" maxlength="50">

<!-- Step: incremento numerico -->
<input type="number" name="quantita"
       min="0" step="0.01">
\end{lstlisting}

\subsection{Messaggi di Errore Personalizzati}

\begin{lstlisting}[language=HTML]
<input type="email" name="email" id="email" required>

<script>
const emailInput = document.getElementById('email');

emailInput.addEventListener('invalid', function(e) {
    if (emailInput.validity.valueMissing) {
        emailInput.setCustomValidity('Per favore, inserisci la tua email');
    } else if (emailInput.validity.typeMismatch) {
        emailInput.setCustomValidity('Formato email non valido');
    }
});

emailInput.addEventListener('input', function() {
    emailInput.setCustomValidity(''); // Reset
});
</script>
\end{lstlisting}

\begin{nota}
La validazione HTML5 è facilmente bypassabile (disabilitando JavaScript o manipolando HTML). \textbf{È obbligatoria la validazione lato server}.
\end{nota}

\section{Validazione Lato Server (PHP)}

\subsection{Validazione Base}

\begin{lstlisting}[language=PHP]
<?php
// Verifica metodo POST
if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405); // Method Not Allowed
    die('Metodo non permesso');
}

// Validazione campo richiesto
$nome = trim($_POST['nome'] ?? '');
if (empty($nome)) {
    $errori[] = 'Il nome è obbligatorio';
}

// Validazione lunghezza
if (strlen($nome) < 2 || strlen($nome) > 50) {
    $errori[] = 'Il nome deve essere tra 2 e 50 caratteri';
}

// Validazione email
$email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
if ($email === false || $email === null) {
    $errori[] = 'Email non valida';
}

// Validazione numero
$eta = filter_input(INPUT_POST, 'eta', FILTER_VALIDATE_INT, [
    'options' => ['min_range' => 18, 'max_range' => 120]
]);
if ($eta === false || $eta === null) {
    $errori[] = 'Età deve essere tra 18 e 120';
}

// Validazione URL
$sito = filter_input(INPUT_POST, 'sito', FILTER_VALIDATE_URL);
if ($sito === false) {
    $errori[] = 'URL non valido';
}

// Se ci sono errori, mostrali
if (!empty($errori)) {
    foreach ($errori as $errore) {
        echo htmlspecialchars($errore) . '<br>';
    }
    exit;
}

// Processa dati validi
echo "Dati validi!";
?>
\end{lstlisting}

\subsection{Filtri PHP}

PHP offre filtri built-in per validazione e sanitizzazione:

\begin{lstlisting}[language=PHP]
<?php
// FILTER_VALIDATE_* : validazione (restituisce valore o false)
$email = filter_var($input, FILTER_VALIDATE_EMAIL);
$int = filter_var($input, FILTER_VALIDATE_INT);
$float = filter_var($input, FILTER_VALIDATE_FLOAT);
$url = filter_var($input, FILTER_VALIDATE_URL);
$ip = filter_var($input, FILTER_VALIDATE_IP);
$boolean = filter_var($input, FILTER_VALIDATE_BOOLEAN);

// FILTER_SANITIZE_* : sanitizzazione (modifica valore)
$email = filter_var($input, FILTER_SANITIZE_EMAIL);
$string = filter_var($input, FILTER_SANITIZE_STRING); // Deprecated PHP 8.1
$int = filter_var($input, FILTER_SANITIZE_NUMBER_INT);
$float = filter_var($input, FILTER_SANITIZE_NUMBER_FLOAT);
$url = filter_var($input, FILTER_SANITIZE_URL);

// Con opzioni
$eta = filter_var($input, FILTER_VALIDATE_INT, [
    'options' => [
        'min_range' => 18,
        'max_range' => 100,
        'default' => 18
    ]
]);
?>
\end{lstlisting}

\begin{attenzione}
\texttt{FILTER\_SANITIZE\_STRING} è deprecato in PHP 8.1. Usa \texttt{htmlspecialchars()} per output encoding.
\end{attenzione}

\section{Sicurezza Form}

\subsection{Protezione XSS (Cross-Site Scripting)}

XSS avviene quando input utente viene mostrato senza sanitizzazione:

\begin{lstlisting}[language=PHP]
<?php
// VULNERABILE: XSS
$nome = $_POST['nome'];
echo "Ciao, $nome!"; // Se nome = "<script>alert('XSS')</script>"

// SICURO: Output encoding
$nome = htmlspecialchars($_POST['nome'], ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
echo "Ciao, $nome!";
?>
\end{lstlisting}

\textbf{Regola d'oro}: \textbf{Mai fidarsi dell'input utente}. Sempre sanitizzare in output con \texttt{htmlspecialchars()}.

\subsection{Protezione SQL Injection}

SQL Injection avviene quando input utente è concatenato in query SQL:

\begin{lstlisting}[language=PHP]
<?php
// VULNERABILE: SQL Injection
$username = $_POST['username'];
$query = "SELECT * FROM users WHERE username = '$username'";
// Se username = "' OR '1'='1" -> bypassa autenticazione

// SICURO: Prepared Statements
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ?");
$stmt->execute([$username]);
$user = $stmt->fetch();
?>
\end{lstlisting}

\textbf{Soluzione}: Usa sempre \textbf{prepared statements} (PDO o MySQLi).

\subsection{Protezione CSRF (Cross-Site Request Forgery)}

CSRF avviene quando un sito malevolo invia richieste autenticate a nome dell'utente:

\begin{lstlisting}[language=PHP]
<?php
session_start();

// Genera token CSRF
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}
?>

<form method="POST">
    <input type="hidden" name="csrf_token"
           value="<?= htmlspecialchars($_SESSION['csrf_token']) ?>">
    <!-- Altri campi -->
    <button type="submit">Invia</button>
</form>

<?php
// Verifica token CSRF
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (!isset($_POST['csrf_token']) ||
        !hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'])) {
        die('CSRF token non valido');
    }

    // Processa form
}
?>
\end{lstlisting}

\begin{attenzione}
Usa \texttt{hash\_equals()} invece di \texttt{===} per prevenire timing attacks.
\end{attenzione}

\section{Pattern Post/Redirect/Get (PRG)}

Il pattern PRG evita il ri-submit del form premendo F5:

\begin{enumerate}
    \item User invia form (POST)
    \item Server processa dati
    \item Server invia redirect (HTTP 303)
    \item Browser richiede pagina successo (GET)
\end{enumerate}

\begin{center}
\begin{tikzpicture}[
    node distance=2.5cm,
    box/.style={rectangle, draw, fill=blue!20, text width=3cm, align=center, minimum height=1cm},
    action/.style={rectangle, draw, fill=green!20, text width=3cm, align=center, minimum height=0.8cm}
]
    % Nodi
    \node[box] (browser1) {Browser};
    \node[action, right=of browser1] (post) {1. POST form\\(submit)};
    \node[action, right=of post] (server) {2. Server\\processa};
    \node[action, below=of server] (redirect) {3. HTTP 303\\Redirect};
    \node[action, left=of redirect] (get) {4. GET\\nuova pagina};
    \node[box, left=of get] (browser2) {Browser};

    % Frecce
    \draw[->, thick, blue] (browser1) -- (post);
    \draw[->, thick, blue] (post) -- (server);
    \draw[->, thick, red] (server) -- (redirect);
    \draw[->, thick, red] (redirect) -- (get);
    \draw[->, thick, green!60!black] (get) -- (browser2);

    % Etichette
    \node[below=0.3cm of browser1, font=\small] {Stato iniziale};
    \node[below=0.3cm of browser2, font=\small] {Stato finale};

    % Problema risolto
    \node[draw, fill=yellow!30, text width=4cm, align=center, below=1cm of get, font=\small]
        {F5 = GET ripetuto\\(safe, no re-submit)};
\end{tikzpicture}
\end{center}

\textbf{Vantaggi PRG}:
\begin{itemize}
    \item F5/Refresh esegue GET (sicuro), non POST
    \item Bookmark funziona (pagina di successo, non form)
    \item Back button non causa warning "Reinviare dati?"
    \item Migliore UX e prevenzione duplicazioni
\end{itemize}

\subsection{Implementazione PRG}

\begin{lstlisting}[language=PHP]
<?php
session_start();

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Validazione CSRF
    if (!hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'] ?? '')) {
        die('CSRF token non valido');
    }

    // Validazione dati
    $email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
    if ($email === false || $email === null) {
        $_SESSION['errore'] = 'Email non valida';
        header('Location: /contatto.php', true, 303);
        exit;
    }

    // Salva dati (database, email, ecc.)
    // ...

    // Successo: salva messaggio in sessione
    $_SESSION['successo'] = 'Email inviata con successo!';

    // Redirect con HTTP 303 (See Other)
    header('Location: /grazie.php', true, 303);
    exit; // IMPORTANTE: termina esecuzione
}
?>
\end{lstlisting}

\textbf{Pagina successo} (\texttt{grazie.php}):

\begin{lstlisting}[language=PHP]
<?php
session_start();

$messaggio = $_SESSION['successo'] ?? null;
unset($_SESSION['successo']); // Cancella dopo visualizzazione
?>
<!DOCTYPE html>
<html>
<head><title>Grazie</title></head>
<body>
    <?php if ($messaggio): ?>
        <p class="successo"><?= htmlspecialchars($messaggio) ?></p>
    <?php endif; ?>

    <p>Grazie per averci contattato!</p>
</body>
</html>
\end{lstlisting}

\begin{nota}
Usa HTTP 303 (See Other) invece di 302 (Found) per garantire che il browser usi GET nel redirect.
\end{nota}

\section{Form Completo con Validazione}

\begin{lstlisting}[language=HTML]
<?php
session_start();

// Genera CSRF token
if (empty($_SESSION['csrf_token'])) {
    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
}

$errori = [];
$valori = [
    'nome' => '',
    'email' => '',
    'messaggio' => ''
];

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // Verifica CSRF
    if (!hash_equals($_SESSION['csrf_token'], $_POST['csrf_token'] ?? '')) {
        die('CSRF token non valido');
    }

    // Validazione nome
    $nome = trim($_POST['nome'] ?? '');
    $valori['nome'] = $nome;
    if (empty($nome)) {
        $errori['nome'] = 'Il nome è obbligatorio';
    } elseif (strlen($nome) < 2 || strlen($nome) > 50) {
        $errori['nome'] = 'Il nome deve essere tra 2 e 50 caratteri';
    }

    // Validazione email
    $email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
    $valori['email'] = $_POST['email'] ?? '';
    if ($email === false || $email === null) {
        $errori['email'] = 'Email non valida';
    }

    // Validazione messaggio
    $messaggio = trim($_POST['messaggio'] ?? '');
    $valori['messaggio'] = $messaggio;
    if (empty($messaggio)) {
        $errori['messaggio'] = 'Il messaggio è obbligatorio';
    } elseif (strlen($messaggio) < 10) {
        $errori['messaggio'] = 'Il messaggio deve essere almeno 10 caratteri';
    }

    // Se nessun errore, processa
    if (empty($errori)) {
        // Salva in database / invia email
        // ...

        $_SESSION['successo'] = 'Messaggio inviato con successo!';
        header('Location: /grazie.php', true, 303);
        exit;
    }
}
?>
<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Form Contatto</title>
    <style>
        .errore { color: red; font-size: 0.9em; }
        input, textarea { display: block; margin: 10px 0; }
        input.invalido { border: 2px solid red; }
    </style>
</head>
<body>
    <h1>Contattaci</h1>

    <form method="POST" novalidate>
        <input type="hidden" name="csrf_token"
               value="<?= htmlspecialchars($_SESSION['csrf_token']) ?>">

        <label for="nome">Nome:</label>
        <input type="text" id="nome" name="nome"
               value="<?= htmlspecialchars($valori['nome']) ?>"
               class="<?= isset($errori['nome']) ? 'invalido' : '' ?>"
               required>
        <?php if (isset($errori['nome'])): ?>
            <span class="errore"><?= htmlspecialchars($errori['nome']) ?></span>
        <?php endif; ?>

        <label for="email">Email:</label>
        <input type="email" id="email" name="email"
               value="<?= htmlspecialchars($valori['email']) ?>"
               class="<?= isset($errori['email']) ? 'invalido' : '' ?>"
               required>
        <?php if (isset($errori['email'])): ?>
            <span class="errore"><?= htmlspecialchars($errori['email']) ?></span>
        <?php endif; ?>

        <label for="messaggio">Messaggio:</label>
        <textarea id="messaggio" name="messaggio" rows="5"
                  class="<?= isset($errori['messaggio']) ? 'invalido' : '' ?>"
                  required><?= htmlspecialchars($valori['messaggio']) ?></textarea>
        <?php if (isset($errori['messaggio'])): ?>
            <span class="errore"><?= htmlspecialchars($errori['messaggio']) ?></span>
        <?php endif; ?>

        <button type="submit">Invia</button>
    </form>
</body>
</html>
\end{lstlisting}

\section{Upload File}

\subsection{Form Upload}

\begin{lstlisting}[language=HTML]
<form method="POST" enctype="multipart/form-data">
    <input type="file" name="documento" accept=".pdf,.doc,.docx" required>
    <button type="submit">Carica</button>
</form>
\end{lstlisting}

\textbf{Importante}: Usa \texttt{enctype="multipart/form-data"} per upload file.

\subsection{Processing Upload}

\begin{lstlisting}[language=PHP]
<?php
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['documento'])) {
    $file = $_FILES['documento'];

    // Verifica errori
    if ($file['error'] !== UPLOAD_ERR_OK) {
        die('Errore upload: ' . $file['error']);
    }

    // Verifica dimensione (max 5MB)
    $maxSize = 5 * 1024 * 1024; // 5MB in byte
    if ($file['size'] > $maxSize) {
        die('File troppo grande (max 5MB)');
    }

    // Verifica tipo MIME
    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $mimeType = finfo_file($finfo, $file['tmp_name']);
    finfo_close($finfo);

    $tipiPermessi = ['application/pdf', 'application/msword',
                     'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
    if (!in_array($mimeType, $tipiPermessi)) {
        die('Tipo file non permesso');
    }

    // Genera nome file sicuro
    $estensione = pathinfo($file['name'], PATHINFO_EXTENSION);
    $nomeFile = bin2hex(random_bytes(16)) . '.' . $estensione;
    $percorsoDestinazione = __DIR__ . '/uploads/' . $nomeFile;

    // Sposta file
    if (move_uploaded_file($file['tmp_name'], $percorsoDestinazione)) {
        echo "File caricato: $nomeFile";
    } else {
        die('Errore spostamento file');
    }
}
?>
\end{lstlisting}

\begin{attenzione}
\textbf{Sicurezza Upload}:
\begin{itemize}
    \item Non fidarti dell'estensione file dall'utente
    \item Verifica tipo MIME con \texttt{finfo\_file()}
    \item Rinomina file con nome random
    \item Salva fuori dalla document root o blocca esecuzione PHP
    \item Limita dimensioni file (\texttt{upload\_max\_filesize} in php.ini)
    \item Limita numero upload simultanei
\end{itemize}
\end{attenzione}

\section{Form con AJAX}

\subsection{Submit Asincrono}

\begin{lstlisting}[language=HTML]
<form id="formContatto">
    <input type="email" name="email" required>
    <button type="submit">Invia</button>
</form>

<div id="risultato"></div>

<script>
document.getElementById('formContatto').addEventListener('submit', async function(e) {
    e.preventDefault(); // Blocca submit normale

    const formData = new FormData(this);
    const risultatoDiv = document.getElementById('risultato');

    try {
        const response = await fetch('/api/contatto.php', {
            method: 'POST',
            body: formData
        });

        const data = await response.json();

        if (response.ok) {
            risultatoDiv.innerHTML = '<p class="successo">' + data.messaggio + '</p>';
            this.reset(); // Pulisci form
        } else {
            risultatoDiv.innerHTML = '<p class="errore">' + data.errore + '</p>';
        }
    } catch (error) {
        risultatoDiv.innerHTML = '<p class="errore">Errore di rete</p>';
    }
});
</script>
\end{lstlisting}

\subsection{API Endpoint PHP}

\begin{lstlisting}[language=PHP]
<?php
header('Content-Type: application/json');

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    echo json_encode(['errore' => 'Metodo non permesso']);
    exit;
}

$email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);

if ($email === false || $email === null) {
    http_response_code(400);
    echo json_encode(['errore' => 'Email non valida']);
    exit;
}

// Processa email
// ...

echo json_encode(['messaggio' => 'Email inviata con successo']);
?>
\end{lstlisting}

\section{Best Practices}

\begin{enumerate}
    \item \textbf{Usa HTTPS}: Proteggi dati in transito
    \item \textbf{Validazione doppia}: Client (UX) + Server (sicurezza)
    \item \textbf{Sanitizza output}: \texttt{htmlspecialchars()} sempre
    \item \textbf{Prepared statements}: Mai concatenare SQL
    \item \textbf{CSRF protection}: Token per form che modificano dati
    \item \textbf{Pattern PRG}: Evita re-submit accidentali
    \item \textbf{Rate limiting}: Limita submit per IP/utente
    \item \textbf{Logging}: Registra tentativi falliti
    \item \textbf{Messaggi errore generici}: Non rivelare dettagli sistema
    \item \textbf{Accessibilità}: Label, ARIA, focus management
\end{enumerate}

\section{Esercizi}

\subsection{Esercizio 1 (Base)}
Crea un form di registrazione con:
\begin{itemize}
    \item Username (alfanumerico, 3-20 caratteri)
    \item Email (validazione)
    \item Password (min 8 caratteri, 1 maiuscola, 1 numero)
    \item Conferma password (deve corrispondere)
    \item Validazione lato server completa
    \item Mostra errori specifici per ogni campo
\end{itemize}

\subsection{Esercizio 2 (Intermedio)}
Estendi l'esercizio 1 aggiungendo:
\begin{itemize}
    \item CSRF protection
    \item Pattern PRG
    \item Salvataggio in sessione dopo validazione
    \item Pagina di conferma
    \item Hashing password con \texttt{password\_hash()}
\end{itemize}

\subsection{Esercizio 3 (Avanzato)}
Implementa un form di upload immagini con:
\begin{itemize}
    \item Validazione tipo (solo PNG, JPG, GIF)
    \item Validazione dimensione (max 2MB)
    \item Resize automatico con GD library
    \item Thumbnail generation
    \item Salvataggio percorso in database
    \item Protezione da file malevoli
\end{itemize}

\subsection{Esercizio 4 (Avanzato)}
Crea un form AJAX con:
\begin{itemize}
    \item Validazione real-time (onblur)
    \item Submit asincrono
    \item Progress bar per upload
    \item Gestione errori JSON
    \item Fallback per JavaScript disabilitato
\end{itemize}

\section{Verifica}

\begin{enumerate}
    \item Qual è la differenza tra GET e POST?
    \item Perché la validazione lato client non è sufficiente?
    \item Come si previene XSS? E SQL Injection?
    \item Cosa fa il pattern PRG e perché è utile?
    \item Come verificare il tipo MIME reale di un file?
    \item Perché usare \texttt{hash\_equals()} per CSRF token?
    \item Qual è il \texttt{enctype} corretto per upload file?
    \item Come gestire errori in form AJAX?
\end{enumerate}

\section{Riferimenti}

\begin{itemize}
    \item \textbf{MDN HTML Forms}: \url{https://developer.mozilla.org/en-US/docs/Learn/Forms}
    \item \textbf{OWASP Form Security}: \url{https://owasp.org/}
    \item \textbf{PHP Filter Functions}: \url{https://www.php.net/manual/en/book.filter.php}
    \item \textbf{PHP File Upload}: \url{https://www.php.net/manual/en/features.file-upload.php}
    \item \textbf{PRG Pattern}: \url{https://en.wikipedia.org/wiki/Post/Redirect/Get}
\end{itemize}
