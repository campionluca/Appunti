\chapter{Array Associativi}\label{cap:array_assoc}

\begin{tcolorbox}[title=Mappa del capitolo]
Teoria, Confronto con array numerici, Funzioni utili, Esempi pratici, Conversioni, Caso di studio, Esercizi, Verifica, Riferimenti.
\end{tcolorbox}

\section{Obiettivi di apprendimento}
\begin{itemize}
  \item Modellare dati semplici con array associativi in PHP.
  \item Applicare funzioni standard per manipolare chiavi e valori.
  \item Integrare array con JSON e query string in modo sicuro.
\end{itemize}

\section{Teoria}
Gli array associativi usano chiavi stringa per mappare valori, ideali per rappresentare oggetti semplici o record.

\section{Differenze con array numerici}

Gli array associativi si distinguono fondamentalmente dagli array numerici per la modalità di accesso ai dati. Mentre gli array numerici utilizzano indici numerici progressivi (0, 1, 2...), gli array associativi impiegano chiavi esplicite, tipicamente stringhe, che fungono da identificatori semantici dei valori. Questa caratteristica permette di costruire strutture dati auto-documentanti, dove il nome della chiave comunica chiaramente il significato del valore associato. Dal punto di vista dell'iterazione, gli array associativi necessitano di un approccio che consenta di accedere contemporaneamente sia alla chiave che al valore, utilizzando la sintassi \verb|foreach ($arr as $k => $v)|. Questa sintassi estesa contrasta con la più semplice iterazione sugli array numerici, dove spesso è sufficiente accedere solo al valore tramite \verb|foreach ($arr as $v)|, poiché l'indice numerico ha solitamente un significato puramente posizionale.

\begin{lstlisting}
<?php
$user = ['id'=>10, 'name'=>'Alice', 'role'=>'admin'];
echo $user['name'];
\end{lstlisting}

\section{Funzioni specifiche}

PHP offre un ricco set di funzioni native ottimizzate per la manipolazione di array associativi. La funzione \texttt{array\_keys()} costituisce uno strumento fondamentale per estrarre l'insieme completo delle chiavi presenti in un array associativo, restituendole sotto forma di array indicizzato numericamente. Complementare a questa, \texttt{array\_values()} si occupa di estrarre esclusivamente i valori, producendo anch'essa un array indicizzato ma sacrificando deliberatamente l'informazione relativa alle chiavi originali. Quando si tratta di combinare più array associativi, \texttt{array\_merge()} si rivela preziosa, unificando le strutture mediante la fusione di chiavi e valori in un'unica collezione. Particolarmente utile negli scenari di configurazione, \texttt{array\_replace()} permette di implementare meccanismi di override sofisticati, sostituendo selettivamente i valori di un array base con quelli provenienti da altri array, tecnica ampiamente impiegata per personalizzare configurazioni predefinite con parametri specifici dell'applicazione.

\begin{lstlisting}
<?php
$users = [
  ['id'=>1,'name'=>'A'],
  ['id'=>2,'name'=>'B'],
];
// Estrazione manuale di una colonna
$names = [];
foreach ($users as $row) { $names[] = $row['name']; } // ['A','B']
\end{lstlisting}

\subsection*{Esempi pratici aggiuntivi}
\begin{lstlisting}
<?php
// Merge con precedenza del secondo array sulle stesse chiavi
$base = ['host'=>'localhost','port'=>3306,'debug'=>false];
$override = ['debug'=>true];
$cfg = array_replace($base, $override); // ['host'=>..., 'port'=>..., 'debug'=>true]

// Ordinamento per chiave (k) e per valore (v)
$map = ['z'=>3, 'a'=>1, 'm'=>2];
ksort($map);  // ['a'=>1, 'm'=>2, 'z'=>3]
asort($map);  // ['a'=>1, 'm'=>2, 'z'=>3] (ordinato per valore crescente)

// Ridenominazione chiavi tramite costruzione manuale
$user = ['id'=>10,'name'=>'Alice'];
$renamed = [];
foreach ($user as $k=>$v) {
    $newKey = ($k==='name') ? 'nome' : $k;
    $renamed[$newKey] = $v;
}
\end{lstlisting}

\section{Conversione da/verso altri formati}

Gli array associativi PHP si prestano naturalmente alla conversione verso formati di serializzazione standard, facilitando l'interoperabilità tra sistemi diversi. Nel contesto della comunicazione web moderna, il formato JSON rappresenta il protocollo dominante: la funzione \texttt{json\_encode} trasforma elegantemente un array associativo in una stringa JSON ben formata, mentre il processo inverso viene gestito da \texttt{json\_decode} che, quando invocata con il parametro booleano \texttt{true}, deserializza la stringa JSON riportandola alla forma di array associativo PHP. Per quanto riguarda le query string utilizzate nella composizione degli URL, il processo di conversione richiede un approccio più artigianale ma comunque sistematico: occorre combinare \texttt{urlencode()} per garantire la corretta codifica di chiavi e valori secondo gli standard URL, quindi utilizzare \texttt{implode()} per concatenare le coppie chiave-valore risultanti mediante il separatore \&. Questa metodologia permette di trasformare efficacemente gli array associativi nel formato standardizzato richiesto per la trasmissione di parametri attraverso gli URL HTTP.

\begin{lstlisting}
<?php
$payload = json_encode($user, JSON_UNESCAPED_UNICODE);
$assoc   = json_decode($payload, true);
// Costruzione manuale di query string
$pairs = [];
foreach ($assoc as $k=>$v) { $pairs[] = urlencode($k).'='.urlencode((string)$v); }
$qs = implode('&', $pairs);
\end{lstlisting}

\section{Caso di studio: impostazioni applicative}
Rappresentazione di una configurazione come mappa chiave\textrightarrow{}valore con override per ambiente (sviluppo/produzione) e esportazione in query string per diagnosticare lo stato.

\section{Esercizi}
\begin{itemize}
  \item Dato un elenco di utenti, costruisci \verb|id=>nome| e ordinane le chiavi alfabeticamente.
  \item Implementa una funzione che rinomini una chiave in un array associativo senza perdere l'ordine.
\end{itemize}

\section{Verifica}
\begin{itemize}
  \item Qual è la differenza tra \texttt{array\_merge} e \texttt{array\_replace}?
  \item Come si impone l'ordinamento per chiave rispetto a per valore?
\end{itemize}

\section{Riferimenti}
\begin{itemize}
  \item Manuale PHP — Array: \url{https://www.php.net/array}
  \item JSON in PHP: \url{https://www.php.net/json}
\end{itemize}

\begin{tcolorbox}[title=Best practice]
- Validare chiavi attese e valori prima dell'uso.
- Per oggetti complessi preferire classi/DTO; usare array associativi per strutture semplici.
\end{tcolorbox}

\begin{tcolorbox}[title=Errori comuni]
- Confondere array associativi e oggetti stdClass dopo \texttt{json\_decode} (usare \texttt{true}).
- Usare \texttt{array\_merge} senza considerare override di chiavi.
\end{tcolorbox}
