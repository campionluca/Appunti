\chapter{Array Associativi}\label{cap:array_assoc}

\begin{tcolorbox}[title=Mappa del capitolo]
Teoria, Confronto con array numerici, Funzioni utili, Esempi pratici, Conversioni, Caso di studio, Esercizi, Verifica, Riferimenti.
\end{tcolorbox}

\section{Obiettivi di apprendimento}
\begin{itemize}
  \item Modellare dati semplici con array associativi in PHP.
  \item Applicare funzioni standard per manipolare chiavi e valori.
  \item Integrare array con JSON e query string in modo sicuro.
\end{itemize}

\section{Teoria}
Gli array associativi usano chiavi stringa per mappare valori, ideali per rappresentare oggetti semplici o record.

\section{Differenze con array numerici}

Gli array associativi differiscono dagli array numerici in aspetti fondamentali. La differenza principale è che gli array associativi utilizzano chiavi esplicite (generalmente stringhe) per accedere ai valori, mentre gli array numerici usano indici numerici. Questa distinzione permette di creare strutture dati semantiche dove le chiavi descrivono il significato del valore. Per quanto riguarda l'iterazione, gli array associativi richiedono l'uso di \verb|foreach ($arr as $k=>$v)| per accedere sia alla chiave che al valore, a differenza degli array numerici dove spesso si usa semplicemente \verb|foreach ($arr as $v)|.

\begin{lstlisting}
<?php
$user = ['id'=>10, 'name'=>'Alice', 'role'=>'admin'];
echo $user['name'];
\end{lstlisting}

\section{Funzioni specifiche}

Diverse funzioni PHP sono specificamente progettate per lavorare efficacemente con array associativi. \texttt{array\_keys()} estrae tutte le chiavi di un array associativo e le restituisce come array indicizzato. \texttt{array\_values()} estrae tutti i valori e li restituisce come array indicizzato, perdendo l'informazione sulle chiavi originali. \texttt{array\_merge()} combina due o più array associativi, unendo le loro chiavi e valori. \texttt{array\_replace()} consente di sostituire i valori di un array con i valori di altri array, utile per l'override di configurazioni predefinite con valori personalizzati.

\begin{lstlisting}
<?php
$users = [
  ['id'=>1,'name'=>'A'],
  ['id'=>2,'name'=>'B'],
];
// Estrazione manuale di una colonna
$names = [];
foreach ($users as $row) { $names[] = $row['name']; } // ['A','B']
\end{lstlisting}

\subsection*{Esempi pratici aggiuntivi}
\begin{lstlisting}
<?php
// Merge con precedenza del secondo array sulle stesse chiavi
$base = ['host'=>'localhost','port'=>3306,'debug'=>false];
$override = ['debug'=>true];
$cfg = array_replace($base, $override); // ['host'=>..., 'port'=>..., 'debug'=>true]

// Ordinamento per chiave (k) e per valore (v)
$map = ['z'=>3, 'a'=>1, 'm'=>2];
ksort($map);  // ['a'=>1, 'm'=>2, 'z'=>3]
asort($map);  // ['a'=>1, 'm'=>2, 'z'=>3] (ordinato per valore crescente)

// Ridenominazione chiavi tramite costruzione manuale
$user = ['id'=>10,'name'=>'Alice'];
$renamed = [];
foreach ($user as $k=>$v) {
    $newKey = ($k==='name') ? 'nome' : $k;
    $renamed[$newKey] = $v;
}
\end{lstlisting}

\section{Conversione da/verso altri formati}

Gli array associativi PHP possono essere facilmente convertiti verso altri formati di serializzazione. Per JSON, \texttt{json\_encode} converte un array associativo in una stringa JSON, mentre \texttt{json\_decode(true)} (con il parametro \texttt{true}) deserializza una stringa JSON back in un array associativo. Per la query string (usata negli URL), la conversione richiede una costruzione manuale combinando \texttt{urlencode()} per codificare le chiavi e valori, e \texttt{implode()} per unire le coppie chiave-valore con il separatore &. Questo permette di trasformare facilmente array associativi in formato standard per la trasmissione nei parametri URL.

\begin{lstlisting}
<?php
$payload = json_encode($user, JSON_UNESCAPED_UNICODE);
$assoc   = json_decode($payload, true);
// Costruzione manuale di query string
$pairs = [];
foreach ($assoc as $k=>$v) { $pairs[] = urlencode($k).'='.urlencode((string)$v); }
$qs = implode('&', $pairs);
\end{lstlisting}

\section{Caso di studio: impostazioni applicative}
Rappresentazione di una configurazione come mappa chiave\textrightarrow{}valore con override per ambiente (sviluppo/produzione) e esportazione in query string per diagnosticare lo stato.

\section{Esercizi}
\begin{itemize}
  \item Dato un elenco di utenti, costruisci \verb|id=>nome| e ordinane le chiavi alfabeticamente.
  \item Implementa una funzione che rinomini una chiave in un array associativo senza perdere l'ordine.
\end{itemize}

\section{Verifica}
\begin{itemize}
  \item Qual è la differenza tra \texttt{array\_merge} e \texttt{array\_replace}?
  \item Come si impone l'ordinamento per chiave rispetto a per valore?
\end{itemize}

\section{Riferimenti}
\begin{itemize}
  \item Manuale PHP — Array: \url{https://www.php.net/array}
  \item JSON in PHP: \url{https://www.php.net/json}
\end{itemize}

\begin{tcolorbox}[title=Best practice]
- Validare chiavi attese e valori prima dell'uso.
- Per oggetti complessi preferire classi/DTO; usare array associativi per strutture semplici.
\end{tcolorbox}

\begin{tcolorbox}[title=Errori comuni]
- Confondere array associativi e oggetti stdClass dopo \texttt{json\_decode} (usare \texttt{true}).
- Usare \texttt{array\_merge} senza considerare override di chiavi.
\end{tcolorbox}
